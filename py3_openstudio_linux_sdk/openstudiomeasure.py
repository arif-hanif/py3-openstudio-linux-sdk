# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openstudiomeasure', [dirname(__file__)])
        except ImportError:
            import _openstudiomeasure
            return _openstudiomeasure
        if fp is not None:
            try:
                _mod = imp.load_module('_openstudiomeasure', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openstudiomeasure = swig_import_helper()
    del swig_import_helper
else:
    import _openstudiomeasure
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _openstudiomeasure.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomeasure.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudiomeasure.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomeasure.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomeasure.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomeasure.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomeasure.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomeasure.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudiomeasure.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openstudiomeasure.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_openstudiomeasure.SHARED_PTR_DISOWN_swigconstant(_openstudiomeasure)
SHARED_PTR_DISOWN = _openstudiomeasure.SHARED_PTR_DISOWN
from .import openstudioutilities
from .import openstudioutilitiescore
from .import openstudioutilitiestime
from .import openstudioutilitiesdata
from .import openstudioutilitiesunits
from .import openstudioutilitiesplot
from .import openstudioutilitiesgeometry
from .import openstudioutilitiessql
from .import openstudioutilitiesbcl
from .import openstudioutilitiesidd
from .import openstudioutilitiesidf
from .import openstudioutilitiesfiletypes
from .import openstudiomodel
from .import openstudiomodelcore
from .import openstudiomodelsimulation
from .import openstudiomodelresources
from .import openstudiomodelgeometry
from .import openstudiomodelhvac
from .import openstudiomodelzonehvac
from .import openstudiomodelavailabilitymanager
from .import openstudiomodelplantequipmentoperationscheme
from .import openstudiomodelstraightcomponent
from .import openstudiomodelairflow
from .import openstudiomodelrefrigeration
from .import openstudiomodelgenerators
class OSArgumentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSArgumentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSArgumentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::measure::OSArgument >::value_type":
        return _openstudiomeasure.OSArgumentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::measure::OSArgument >::difference_type', j: 'std::vector< openstudio::measure::OSArgument >::difference_type') -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > > *":
        return _openstudiomeasure.OSArgumentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::measure::OSArgument >::difference_type', j: 'std::vector< openstudio::measure::OSArgument >::difference_type') -> "void":
        return _openstudiomeasure.OSArgumentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector___setitem__(self, *args)

    def append(self, x: 'OSArgument') -> "void":
        return _openstudiomeasure.OSArgumentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomeasure.OSArgumentVector_empty(self)

    def size(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSArgumentVector_clear(self)

    def swap(self, v: 'OSArgumentVector') -> "void":
        return _openstudiomeasure.OSArgumentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::measure::OSArgument >::allocator_type":
        return _openstudiomeasure.OSArgumentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_begin(self)

    def end(self) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomeasure.OSArgumentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSArgumentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'OSArgument') -> "void":
        return _openstudiomeasure.OSArgumentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector_front(self)

    def back(self) -> "std::vector< openstudio::measure::OSArgument >::value_type const &":
        return _openstudiomeasure.OSArgumentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::measure::OSArgument >::size_type', x: 'OSArgument') -> "void":
        return _openstudiomeasure.OSArgumentVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::measure::OSArgument >::size_type') -> "void":
        return _openstudiomeasure.OSArgumentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentVector_capacity(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentVector
    __del__ = lambda self: None
OSArgumentVector_swigregister = _openstudiomeasure.OSArgumentVector_swigregister
OSArgumentVector_swigregister(OSArgumentVector)

class OptionalOSArgument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalOSArgument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalOSArgument, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OptionalOSArgument(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomeasure.OptionalOSArgument_reset(self)

    def __ref__(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OptionalOSArgument___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomeasure.OptionalOSArgument_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomeasure.OptionalOSArgument_isNull(self)

    def get(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OptionalOSArgument_get(self)

    def set(self, t: 'OSArgument') -> "void":
        return _openstudiomeasure.OptionalOSArgument_set(self, t)
    __swig_destroy__ = _openstudiomeasure.delete_OptionalOSArgument
    __del__ = lambda self: None
OptionalOSArgument_swigregister = _openstudiomeasure.OptionalOSArgument_swigregister
OptionalOSArgument_swigregister(OptionalOSArgument)

class OSArgumentMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSArgumentMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSArgumentMap, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap___bool__(self)

    def __len__(self) -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "std::map< std::string,openstudio::measure::OSArgument >::mapped_type const &":
        return _openstudiomeasure.OSArgumentMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "void":
        return _openstudiomeasure.OSArgumentMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "bool":
        return _openstudiomeasure.OSArgumentMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_keys(self)

    def values(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_values(self)

    def items(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_items(self)

    def __contains__(self, key: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "bool":
        return _openstudiomeasure.OSArgumentMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSArgumentMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _openstudiomeasure.OSArgumentMap_asdict(self)

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSArgumentMap(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self) -> "bool":
        return _openstudiomeasure.OSArgumentMap_empty(self)

    def size(self) -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap_size(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSArgumentMap_clear(self)

    def swap(self, v: 'OSArgumentMap') -> "void":
        return _openstudiomeasure.OSArgumentMap_swap(self, v)

    def get_allocator(self) -> "std::map< std::string,openstudio::measure::OSArgument >::allocator_type":
        return _openstudiomeasure.OSArgumentMap_get_allocator(self)

    def begin(self) -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_begin(self)

    def end(self) -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_end(self)

    def rbegin(self) -> "std::map< std::string,openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentMap_rbegin(self)

    def rend(self) -> "std::map< std::string,openstudio::measure::OSArgument >::reverse_iterator":
        return _openstudiomeasure.OSArgumentMap_rend(self)

    def count(self, x: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "std::map< std::string,openstudio::measure::OSArgument >::size_type":
        return _openstudiomeasure.OSArgumentMap_count(self, x)

    def erase(self, *args) -> "void":
        return _openstudiomeasure.OSArgumentMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,openstudio::measure::OSArgument >::key_type const &') -> "std::map< std::string,openstudio::measure::OSArgument >::iterator":
        return _openstudiomeasure.OSArgumentMap_upper_bound(self, x)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentMap
    __del__ = lambda self: None
OSArgumentMap_swigregister = _openstudiomeasure.OSArgumentMap_swigregister
OSArgumentMap_swigregister(OSArgumentMap)

class OSOutputVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSOutputVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSOutputVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomeasure.OSOutputVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomeasure.OSOutputVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomeasure.OSOutputVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector___len__(self)

    def pop(self) -> "std::vector< openstudio::measure::OSOutput >::value_type":
        return _openstudiomeasure.OSOutputVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::measure::OSOutput >::difference_type', j: 'std::vector< openstudio::measure::OSOutput >::difference_type') -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > > *":
        return _openstudiomeasure.OSOutputVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::measure::OSOutput >::difference_type', j: 'std::vector< openstudio::measure::OSOutput >::difference_type') -> "void":
        return _openstudiomeasure.OSOutputVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector___setitem__(self, *args)

    def append(self, x: 'OSOutput') -> "void":
        return _openstudiomeasure.OSOutputVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomeasure.OSOutputVector_empty(self)

    def size(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector_size(self)

    def clear(self) -> "void":
        return _openstudiomeasure.OSOutputVector_clear(self)

    def swap(self, v: 'OSOutputVector') -> "void":
        return _openstudiomeasure.OSOutputVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::measure::OSOutput >::allocator_type":
        return _openstudiomeasure.OSOutputVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_begin(self)

    def end(self) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::measure::OSOutput >::reverse_iterator":
        return _openstudiomeasure.OSOutputVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::measure::OSOutput >::reverse_iterator":
        return _openstudiomeasure.OSOutputVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomeasure.OSOutputVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::measure::OSOutput >::iterator":
        return _openstudiomeasure.OSOutputVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSOutputVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'OSOutput') -> "void":
        return _openstudiomeasure.OSOutputVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector_front(self)

    def back(self) -> "std::vector< openstudio::measure::OSOutput >::value_type const &":
        return _openstudiomeasure.OSOutputVector_back(self)

    def assign(self, n: 'std::vector< openstudio::measure::OSOutput >::size_type', x: 'OSOutput') -> "void":
        return _openstudiomeasure.OSOutputVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::measure::OSOutput >::size_type', x: 'OSOutput') -> "void":
        return _openstudiomeasure.OSOutputVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomeasure.OSOutputVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::measure::OSOutput >::size_type') -> "void":
        return _openstudiomeasure.OSOutputVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::measure::OSOutput >::size_type":
        return _openstudiomeasure.OSOutputVector_capacity(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutputVector
    __del__ = lambda self: None
OSOutputVector_swigregister = _openstudiomeasure.OSOutputVector_swigregister
OSOutputVector_swigregister(OSOutputVector)

class OptionalOSOutput(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalOSOutput, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalOSOutput, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OptionalOSOutput(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomeasure.OptionalOSOutput_reset(self)

    def __ref__(self) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OptionalOSOutput___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomeasure.OptionalOSOutput_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomeasure.OptionalOSOutput_isNull(self)

    def get(self) -> "openstudio::measure::OSOutput":
        return _openstudiomeasure.OptionalOSOutput_get(self)

    def set(self, t: 'OSOutput') -> "void":
        return _openstudiomeasure.OptionalOSOutput_set(self, t)
    __swig_destroy__ = _openstudiomeasure.delete_OptionalOSOutput
    __del__ = lambda self: None
OptionalOSOutput_swigregister = _openstudiomeasure.OptionalOSOutput_swigregister
OptionalOSOutput_swigregister(OptionalOSOutput)

class OSArgumentType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSArgumentType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSArgumentType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSArgumentType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSArgumentType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSArgumentType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSArgumentType_valueDescription(self)

    def __eq__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___eq__(self, other)

    def __ne__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___ne__(self, other)

    def __gt__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___gt__(self, other)

    def __ge__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___ge__(self, other)

    def __lt__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___lt__(self, other)

    def __le__(self, other: 'OSArgumentType') -> "bool":
        return _openstudiomeasure.OSArgumentType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudiomeasure.OSArgumentType_enumName
    if _newclass:
        enumName = staticmethod(_openstudiomeasure.OSArgumentType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudiomeasure.OSArgumentType_getValues
    if _newclass:
        getValues = staticmethod(_openstudiomeasure.OSArgumentType_getValues)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgumentType
    __del__ = lambda self: None
OSArgumentType_swigregister = _openstudiomeasure.OSArgumentType_swigregister
OSArgumentType_swigregister(OSArgumentType)

def OSArgumentType_enumName() -> "std::string":
    return _openstudiomeasure.OSArgumentType_enumName()
OSArgumentType_enumName = _openstudiomeasure.OSArgumentType_enumName

def OSArgumentType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSArgumentType_getValues()
OSArgumentType_getValues = _openstudiomeasure.OSArgumentType_getValues

class OSDomainType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSDomainType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSDomainType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSDomainType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSDomainType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSDomainType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSDomainType_valueDescription(self)

    def __eq__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___eq__(self, other)

    def __ne__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___ne__(self, other)

    def __gt__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___gt__(self, other)

    def __ge__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___ge__(self, other)

    def __lt__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___lt__(self, other)

    def __le__(self, other: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSDomainType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudiomeasure.OSDomainType_enumName
    if _newclass:
        enumName = staticmethod(_openstudiomeasure.OSDomainType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudiomeasure.OSDomainType_getValues
    if _newclass:
        getValues = staticmethod(_openstudiomeasure.OSDomainType_getValues)
    __swig_destroy__ = _openstudiomeasure.delete_OSDomainType
    __del__ = lambda self: None
OSDomainType_swigregister = _openstudiomeasure.OSDomainType_swigregister
OSDomainType_swigregister(OSDomainType)

def OSDomainType_enumName() -> "std::string":
    return _openstudiomeasure.OSDomainType_enumName()
OSDomainType_enumName = _openstudiomeasure.OSDomainType_enumName

def OSDomainType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSDomainType_getValues()
OSDomainType_getValues = _openstudiomeasure.OSDomainType_getValues

class OSArgument(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSArgument, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSArgument, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSArgument(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def clone(self) -> "openstudio::measure::OSArgument":
        return _openstudiomeasure.OSArgument_clone(self)
    __swig_getmethods__["makeBoolArgument"] = lambda x: _openstudiomeasure.OSArgument_makeBoolArgument
    if _newclass:
        makeBoolArgument = staticmethod(_openstudiomeasure.OSArgument_makeBoolArgument)
    __swig_getmethods__["makeDoubleArgument"] = lambda x: _openstudiomeasure.OSArgument_makeDoubleArgument
    if _newclass:
        makeDoubleArgument = staticmethod(_openstudiomeasure.OSArgument_makeDoubleArgument)
    __swig_getmethods__["makeQuantityArgument"] = lambda x: _openstudiomeasure.OSArgument_makeQuantityArgument
    if _newclass:
        makeQuantityArgument = staticmethod(_openstudiomeasure.OSArgument_makeQuantityArgument)
    __swig_getmethods__["makeIntegerArgument"] = lambda x: _openstudiomeasure.OSArgument_makeIntegerArgument
    if _newclass:
        makeIntegerArgument = staticmethod(_openstudiomeasure.OSArgument_makeIntegerArgument)
    __swig_getmethods__["makeStringArgument"] = lambda x: _openstudiomeasure.OSArgument_makeStringArgument
    if _newclass:
        makeStringArgument = staticmethod(_openstudiomeasure.OSArgument_makeStringArgument)
    __swig_getmethods__["makeChoiceArgument"] = lambda x: _openstudiomeasure.OSArgument_makeChoiceArgument
    if _newclass:
        makeChoiceArgument = staticmethod(_openstudiomeasure.OSArgument_makeChoiceArgument)
    __swig_getmethods__["makePathArgument"] = lambda x: _openstudiomeasure.OSArgument_makePathArgument
    if _newclass:
        makePathArgument = staticmethod(_openstudiomeasure.OSArgument_makePathArgument)
    __swig_getmethods__["makeSeparatorArgument"] = lambda x: _openstudiomeasure.OSArgument_makeSeparatorArgument
    if _newclass:
        makeSeparatorArgument = staticmethod(_openstudiomeasure.OSArgument_makeSeparatorArgument)

    def name(self) -> "std::string":
        return _openstudiomeasure.OSArgument_name(self)

    def displayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_displayName(self)

    def description(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSArgument_description(self)

    def type(self) -> "openstudio::measure::OSArgumentType":
        return _openstudiomeasure.OSArgument_type(self)

    def units(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSArgument_units(self)

    def required(self) -> "bool":
        return _openstudiomeasure.OSArgument_required(self)

    def modelDependent(self) -> "bool":
        return _openstudiomeasure.OSArgument_modelDependent(self)

    def hasValue(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasValue(self)

    def valueAsBool(self) -> "bool":
        return _openstudiomeasure.OSArgument_valueAsBool(self)

    def valueAsDouble(self) -> "double":
        return _openstudiomeasure.OSArgument_valueAsDouble(self)

    def valueAsQuantity(self) -> "openstudio::Quantity":
        return _openstudiomeasure.OSArgument_valueAsQuantity(self)

    def valueAsInteger(self) -> "int":
        return _openstudiomeasure.OSArgument_valueAsInteger(self)

    def valueAsString(self) -> "std::string":
        return _openstudiomeasure.OSArgument_valueAsString(self)

    def valueAsPath(self) -> "openstudio::path":
        return _openstudiomeasure.OSArgument_valueAsPath(self)

    def hasDefaultValue(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasDefaultValue(self)

    def defaultValueAsBool(self) -> "bool":
        return _openstudiomeasure.OSArgument_defaultValueAsBool(self)

    def defaultValueAsDouble(self) -> "double":
        return _openstudiomeasure.OSArgument_defaultValueAsDouble(self)

    def defaultValueAsQuantity(self) -> "openstudio::Quantity":
        return _openstudiomeasure.OSArgument_defaultValueAsQuantity(self)

    def defaultValueAsInteger(self) -> "int":
        return _openstudiomeasure.OSArgument_defaultValueAsInteger(self)

    def defaultValueAsString(self) -> "std::string":
        return _openstudiomeasure.OSArgument_defaultValueAsString(self)

    def defaultValueAsPath(self) -> "openstudio::path":
        return _openstudiomeasure.OSArgument_defaultValueAsPath(self)

    def hasDomain(self) -> "bool":
        return _openstudiomeasure.OSArgument_hasDomain(self)

    def domainType(self) -> "openstudio::measure::OSDomainType":
        return _openstudiomeasure.OSArgument_domainType(self)

    def domainAsBool(self) -> "std::vector< bool,std::allocator< bool > >":
        return _openstudiomeasure.OSArgument_domainAsBool(self)

    def domainAsDouble(self) -> "std::vector< double,std::allocator< double > >":
        return _openstudiomeasure.OSArgument_domainAsDouble(self)

    def domainAsQuantity(self) -> "std::vector< openstudio::Quantity,std::allocator< openstudio::Quantity > >":
        return _openstudiomeasure.OSArgument_domainAsQuantity(self)

    def domainAsInteger(self) -> "std::vector< int,std::allocator< int > >":
        return _openstudiomeasure.OSArgument_domainAsInteger(self)

    def domainAsString(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_domainAsString(self)

    def domainAsPath(self) -> "std::vector< openstudio::path,std::allocator< openstudio::path > >":
        return _openstudiomeasure.OSArgument_domainAsPath(self)

    def domainAsQVariant(self) -> "std::vector< QVariant,std::allocator< QVariant > >":
        return _openstudiomeasure.OSArgument_domainAsQVariant(self)

    def choiceValues(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_choiceValues(self)

    def choiceValueDisplayNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomeasure.OSArgument_choiceValueDisplayNames(self)

    def valueDisplayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_valueDisplayName(self)

    def defaultValueDisplayName(self) -> "std::string":
        return _openstudiomeasure.OSArgument_defaultValueDisplayName(self)

    def isRead(self) -> "bool":
        return _openstudiomeasure.OSArgument_isRead(self)

    def extension(self) -> "std::string":
        return _openstudiomeasure.OSArgument_extension(self)

    def setDisplayName(self, displayName: 'std::string const &') -> "void":
        return _openstudiomeasure.OSArgument_setDisplayName(self, displayName)

    def setDescription(self, description: 'std::string const &') -> "void":
        return _openstudiomeasure.OSArgument_setDescription(self, description)

    def setUnits(self, units: 'std::string const &') -> "void":
        return _openstudiomeasure.OSArgument_setUnits(self, units)

    def setValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setValue(self, *args)

    def clearValue(self) -> "void":
        return _openstudiomeasure.OSArgument_clearValue(self)

    def setDefaultValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setDefaultValue(self, *args)

    def setDomainType(self, domainType: 'OSDomainType') -> "bool":
        return _openstudiomeasure.OSArgument_setDomainType(self, domainType)

    def setDomain(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setDomain(self, *args)

    def clearDomain(self) -> "void":
        return _openstudiomeasure.OSArgument_clearDomain(self)

    def setMinValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setMinValue(self, *args)

    def setMaxValue(self, *args) -> "bool":
        return _openstudiomeasure.OSArgument_setMaxValue(self, *args)

    def _print(self) -> "std::string":
        return _openstudiomeasure.OSArgument__print(self)

    def printValue(self, printDefault: 'bool'=True) -> "std::string":
        return _openstudiomeasure.OSArgument_printValue(self, printDefault)

    def printDefaultValue(self) -> "std::string":
        return _openstudiomeasure.OSArgument_printDefaultValue(self)

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSArgument___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSArgument
    __del__ = lambda self: None
OSArgument_swigregister = _openstudiomeasure.OSArgument_swigregister
OSArgument_swigregister(OSArgument)

def OSArgument_makeBoolArgument(name: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeBoolArgument(name, required, modelDependent)
OSArgument_makeBoolArgument = _openstudiomeasure.OSArgument_makeBoolArgument

def OSArgument_makeDoubleArgument(name: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeDoubleArgument(name, required, modelDependent)
OSArgument_makeDoubleArgument = _openstudiomeasure.OSArgument_makeDoubleArgument

def OSArgument_makeQuantityArgument(name: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeQuantityArgument(name, required, modelDependent)
OSArgument_makeQuantityArgument = _openstudiomeasure.OSArgument_makeQuantityArgument

def OSArgument_makeIntegerArgument(name: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeIntegerArgument(name, required, modelDependent)
OSArgument_makeIntegerArgument = _openstudiomeasure.OSArgument_makeIntegerArgument

def OSArgument_makeStringArgument(name: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeStringArgument(name, required, modelDependent)
OSArgument_makeStringArgument = _openstudiomeasure.OSArgument_makeStringArgument

def OSArgument_makeChoiceArgument(*args) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeChoiceArgument(*args)
OSArgument_makeChoiceArgument = _openstudiomeasure.OSArgument_makeChoiceArgument

def OSArgument_makePathArgument(name: 'std::string const &', isRead: 'bool', extension: 'std::string const &', required: 'bool'=True, modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makePathArgument(name, isRead, extension, required, modelDependent)
OSArgument_makePathArgument = _openstudiomeasure.OSArgument_makePathArgument

def OSArgument_makeSeparatorArgument(name: 'std::string const &', modelDependent: 'bool'=False) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.OSArgument_makeSeparatorArgument(name, modelDependent)
OSArgument_makeSeparatorArgument = _openstudiomeasure.OSArgument_makeSeparatorArgument


def makeChoiceArgumentOfWorkspaceObjects(*args) -> "openstudio::measure::OSArgument":
    return _openstudiomeasure.makeChoiceArgumentOfWorkspaceObjects(*args)
makeChoiceArgumentOfWorkspaceObjects = _openstudiomeasure.makeChoiceArgumentOfWorkspaceObjects

def convertOSArgumentVectorToMap(arguments: 'OSArgumentVector') -> "std::map< std::string,openstudio::measure::OSArgument,std::less< std::string >,std::allocator< std::pair< std::string const,openstudio::measure::OSArgument > > >":
    return _openstudiomeasure.convertOSArgumentVectorToMap(arguments)
convertOSArgumentVectorToMap = _openstudiomeasure.convertOSArgumentVectorToMap
class OSOutputType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSOutputType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSOutputType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSOutputType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudiomeasure.OSOutputType_valueName(self)

    def value(self) -> "int":
        return _openstudiomeasure.OSOutputType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomeasure.OSOutputType_valueDescription(self)

    def __eq__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___eq__(self, other)

    def __ne__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___ne__(self, other)

    def __gt__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___gt__(self, other)

    def __ge__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___ge__(self, other)

    def __lt__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___lt__(self, other)

    def __le__(self, other: 'OSOutputType') -> "bool":
        return _openstudiomeasure.OSOutputType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudiomeasure.OSOutputType_enumName
    if _newclass:
        enumName = staticmethod(_openstudiomeasure.OSOutputType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudiomeasure.OSOutputType_getValues
    if _newclass:
        getValues = staticmethod(_openstudiomeasure.OSOutputType_getValues)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutputType
    __del__ = lambda self: None
OSOutputType_swigregister = _openstudiomeasure.OSOutputType_swigregister
OSOutputType_swigregister(OSOutputType)

def OSOutputType_enumName() -> "std::string":
    return _openstudiomeasure.OSOutputType_enumName()
OSOutputType_enumName = _openstudiomeasure.OSOutputType_enumName

def OSOutputType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomeasure.OSOutputType_getValues()
OSOutputType_getValues = _openstudiomeasure.OSOutputType_getValues

class OSOutput(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSOutput, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSOutput, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomeasure.new_OSOutput(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_getmethods__["makeBoolOutput"] = lambda x: _openstudiomeasure.OSOutput_makeBoolOutput
    if _newclass:
        makeBoolOutput = staticmethod(_openstudiomeasure.OSOutput_makeBoolOutput)
    __swig_getmethods__["makeDoubleOutput"] = lambda x: _openstudiomeasure.OSOutput_makeDoubleOutput
    if _newclass:
        makeDoubleOutput = staticmethod(_openstudiomeasure.OSOutput_makeDoubleOutput)
    __swig_getmethods__["makeIntegerOutput"] = lambda x: _openstudiomeasure.OSOutput_makeIntegerOutput
    if _newclass:
        makeIntegerOutput = staticmethod(_openstudiomeasure.OSOutput_makeIntegerOutput)
    __swig_getmethods__["makeStringOutput"] = lambda x: _openstudiomeasure.OSOutput_makeStringOutput
    if _newclass:
        makeStringOutput = staticmethod(_openstudiomeasure.OSOutput_makeStringOutput)

    def name(self) -> "std::string":
        return _openstudiomeasure.OSOutput_name(self)

    def displayName(self) -> "std::string":
        return _openstudiomeasure.OSOutput_displayName(self)

    def shortName(self) -> "std::string":
        return _openstudiomeasure.OSOutput_shortName(self)

    def description(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSOutput_description(self)

    def type(self) -> "openstudio::measure::OSOutputType":
        return _openstudiomeasure.OSOutput_type(self)

    def units(self) -> "boost::optional< std::string >":
        return _openstudiomeasure.OSOutput_units(self)

    def modelDependent(self) -> "bool":
        return _openstudiomeasure.OSOutput_modelDependent(self)

    def setDisplayName(self, displayName: 'std::string const &') -> "void":
        return _openstudiomeasure.OSOutput_setDisplayName(self, displayName)

    def setShortName(self, shortName: 'std::string const &') -> "void":
        return _openstudiomeasure.OSOutput_setShortName(self, shortName)

    def setDescription(self, description: 'std::string const &') -> "void":
        return _openstudiomeasure.OSOutput_setDescription(self, description)

    def setUnits(self, units: 'std::string const &') -> "void":
        return _openstudiomeasure.OSOutput_setUnits(self, units)

    def _print(self) -> "std::string":
        return _openstudiomeasure.OSOutput__print(self)

    def __str__(self) -> "std::string":
        return _openstudiomeasure.OSOutput___str__(self)
    __swig_destroy__ = _openstudiomeasure.delete_OSOutput
    __del__ = lambda self: None
OSOutput_swigregister = _openstudiomeasure.OSOutput_swigregister
OSOutput_swigregister(OSOutput)

def OSOutput_makeBoolOutput(name: 'std::string const &', modelDependent: 'bool'=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeBoolOutput(name, modelDependent)
OSOutput_makeBoolOutput = _openstudiomeasure.OSOutput_makeBoolOutput

def OSOutput_makeDoubleOutput(name: 'std::string const &', modelDependent: 'bool'=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeDoubleOutput(name, modelDependent)
OSOutput_makeDoubleOutput = _openstudiomeasure.OSOutput_makeDoubleOutput

def OSOutput_makeIntegerOutput(name: 'std::string const &', modelDependent: 'bool'=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeIntegerOutput(name, modelDependent)
OSOutput_makeIntegerOutput = _openstudiomeasure.OSOutput_makeIntegerOutput

def OSOutput_makeStringOutput(name: 'std::string const &', modelDependent: 'bool'=False) -> "openstudio::measure::OSOutput":
    return _openstudiomeasure.OSOutput_makeStringOutput(name, modelDependent)
OSOutput_makeStringOutput = _openstudiomeasure.OSOutput_makeStringOutput


def __lshift__(*args) -> "std::ostream &":
    return _openstudiomeasure.__lshift__(*args)
__lshift__ = _openstudiomeasure.__lshift__
class OSRunner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSRunner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSRunner, name)
    __repr__ = _swig_repr

    def __init__(self, workflow: 'WorkflowJSON'):
        if self.__class__ == OSRunner:
            _self = None
        else:
            _self = self
        this = _openstudiomeasure.new_OSRunner(_self, workflow)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomeasure.delete_OSRunner
    __del__ = lambda self: None

    def workflow(self) -> "openstudio::WorkflowJSON":
        return _openstudiomeasure.OSRunner_workflow(self)

    def unitsPreference(self) -> "std::string":
        return _openstudiomeasure.OSRunner_unitsPreference(self)

    def languagePreference(self) -> "std::string":
        return _openstudiomeasure.OSRunner_languagePreference(self)

    def result(self) -> "openstudio::WorkflowStepResult":
        return _openstudiomeasure.OSRunner_result(self)

    def halted(self) -> "bool":
        return _openstudiomeasure.OSRunner_halted(self)

    def lastOpenStudioModel(self) -> "boost::optional< openstudio::model::Model >":
        return _openstudiomeasure.OSRunner_lastOpenStudioModel(self)

    def lastEnergyPlusWorkspace(self) -> "boost::optional< openstudio::Workspace >":
        return _openstudiomeasure.OSRunner_lastEnergyPlusWorkspace(self)

    def lastEnergyPlusSqlFile(self) -> "boost::optional< openstudio::SqlFile >":
        return _openstudiomeasure.OSRunner_lastEnergyPlusSqlFile(self)

    def lastEpwFile(self) -> "boost::optional< openstudio::EpwFile >":
        return _openstudiomeasure.OSRunner_lastEpwFile(self)

    def lastEpwFilePath(self) -> "boost::optional< openstudio::path >":
        return _openstudiomeasure.OSRunner_lastEpwFilePath(self)

    def inSelection(self, modelObject: 'ModelObject') -> "bool":
        return _openstudiomeasure.OSRunner_inSelection(self, modelObject)

    def getUserInput(self, arguments: 'OSArgumentVector') -> "std::map< std::string,openstudio::measure::OSArgument,std::less< std::string >,std::allocator< std::pair< std::string const,openstudio::measure::OSArgument > > >":
        return _openstudiomeasure.OSRunner_getUserInput(self, arguments)

    def prepareForMeasureRun(self, measure: 'OSMeasure') -> "void":
        return _openstudiomeasure.OSRunner_prepareForMeasureRun(self, measure)

    def registerError(self, message: 'std::string const &') -> "void":
        return _openstudiomeasure.OSRunner_registerError(self, message)

    def registerWarning(self, message: 'std::string const &') -> "bool":
        return _openstudiomeasure.OSRunner_registerWarning(self, message)

    def registerInfo(self, message: 'std::string const &') -> "bool":
        return _openstudiomeasure.OSRunner_registerInfo(self, message)

    def registerAsNotApplicable(self, message: 'std::string const &') -> "void":
        return _openstudiomeasure.OSRunner_registerAsNotApplicable(self, message)

    def registerInitialCondition(self, message: 'std::string const &') -> "void":
        return _openstudiomeasure.OSRunner_registerInitialCondition(self, message)

    def registerFinalCondition(self, message: 'std::string const &') -> "void":
        return _openstudiomeasure.OSRunner_registerFinalCondition(self, message)

    def registerValue(self, *args) -> "void":
        return _openstudiomeasure.OSRunner_registerValue(self, *args)

    def haltWorkflow(self, *args) -> "void":
        return _openstudiomeasure.OSRunner_haltWorkflow(self, *args)

    def createProgressBar(self, text: 'std::string const &') -> "void":
        return _openstudiomeasure.OSRunner_createProgressBar(self, text)

    def updateProgress(self, value: 'double const &') -> "void":
        return _openstudiomeasure.OSRunner_updateProgress(self, value)

    def destroyProgressBar(self) -> "void":
        return _openstudiomeasure.OSRunner_destroyProgressBar(self)

    def validateUserArguments(self, script_arguments: 'OSArgumentVector', user_arguments: 'OSArgumentMap') -> "bool":
        return _openstudiomeasure.OSRunner_validateUserArguments(self, script_arguments, user_arguments)

    def getBoolArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "bool":
        return _openstudiomeasure.OSRunner_getBoolArgumentValue(self, argument_name, user_arguments)

    def getDoubleArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "double":
        return _openstudiomeasure.OSRunner_getDoubleArgumentValue(self, argument_name, user_arguments)

    def getOptionalDoubleArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "boost::optional< double >":
        return _openstudiomeasure.OSRunner_getOptionalDoubleArgumentValue(self, argument_name, user_arguments)

    def getIntegerArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "int":
        return _openstudiomeasure.OSRunner_getIntegerArgumentValue(self, argument_name, user_arguments)

    def getOptionalIntegerArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "boost::optional< int >":
        return _openstudiomeasure.OSRunner_getOptionalIntegerArgumentValue(self, argument_name, user_arguments)

    def getStringArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "std::string":
        return _openstudiomeasure.OSRunner_getStringArgumentValue(self, argument_name, user_arguments)

    def getOptionalStringArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "boost::optional< std::string >":
        return _openstudiomeasure.OSRunner_getOptionalStringArgumentValue(self, argument_name, user_arguments)

    def getPathArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "openstudio::path":
        return _openstudiomeasure.OSRunner_getPathArgumentValue(self, argument_name, user_arguments)

    def getOptionalPathArgumentValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap') -> "boost::optional< openstudio::path >":
        return _openstudiomeasure.OSRunner_getOptionalPathArgumentValue(self, argument_name, user_arguments)

    def getOptionalWorkspaceObjectChoiceValue(self, argument_name: 'std::string const &', user_arguments: 'OSArgumentMap', workspace: 'Workspace') -> "boost::optional< openstudio::WorkspaceObject >":
        return _openstudiomeasure.OSRunner_getOptionalWorkspaceObjectChoiceValue(self, argument_name, user_arguments, workspace)

    def reset(self) -> "void":
        return _openstudiomeasure.OSRunner_reset(self)

    def incrementStep(self) -> "bool":
        return _openstudiomeasure.OSRunner_incrementStep(self)

    def setLastOpenStudioModel(self, lastOpenStudioModel: 'Model') -> "void":
        return _openstudiomeasure.OSRunner_setLastOpenStudioModel(self, lastOpenStudioModel)

    def resetLastOpenStudioModel(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastOpenStudioModel(self)

    def setLastOpenStudioModelPath(self, lastOpenStudioModelPath: 'path') -> "void":
        return _openstudiomeasure.OSRunner_setLastOpenStudioModelPath(self, lastOpenStudioModelPath)

    def resetLastOpenStudioModelPath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastOpenStudioModelPath(self)

    def setLastEnergyPlusWorkspace(self, lastEnergyPlusWorkspace: 'Workspace') -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusWorkspace(self, lastEnergyPlusWorkspace)

    def resetLastEnergyPlusWorkspace(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusWorkspace(self)

    def setLastEnergyPlusWorkspacePath(self, lastEnergyPlusWorkspacePath: 'path') -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusWorkspacePath(self, lastEnergyPlusWorkspacePath)

    def resetLastEnergyPlusWorkspacePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusWorkspacePath(self)

    def setLastEnergyPlusSqlFilePath(self, lastEnergyPlusSqlFilePath: 'path') -> "void":
        return _openstudiomeasure.OSRunner_setLastEnergyPlusSqlFilePath(self, lastEnergyPlusSqlFilePath)

    def resetLastEnergyPlusSqlFilePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEnergyPlusSqlFilePath(self)

    def setLastEpwFilePath(self, lastEpwFilePath: 'path') -> "void":
        return _openstudiomeasure.OSRunner_setLastEpwFilePath(self, lastEpwFilePath)

    def resetLastEpwFilePath(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLastEpwFilePath(self)

    def setUnitsPreference(self, unitsPreference: 'std::string const &') -> "bool":
        return _openstudiomeasure.OSRunner_setUnitsPreference(self, unitsPreference)

    def resetUnitsPreference(self) -> "void":
        return _openstudiomeasure.OSRunner_resetUnitsPreference(self)

    def setLanguagePreference(self, languagePreference: 'std::string const &') -> "bool":
        return _openstudiomeasure.OSRunner_setLanguagePreference(self, languagePreference)

    def resetLanguagePreference(self) -> "void":
        return _openstudiomeasure.OSRunner_resetLanguagePreference(self)
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_OSRunner(self)
        return weakref_proxy(self)
OSRunner_swigregister = _openstudiomeasure.OSRunner_swigregister
OSRunner_swigregister(OSRunner)

class OSMeasure(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OSMeasure, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OSMeasure, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_OSMeasure
    __del__ = lambda self: None

    def name(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_name(self)

    def description(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_description(self)

    def taxonomy(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_taxonomy(self)

    def modeler_description(self) -> "std::string":
        return _openstudiomeasure.OSMeasure_modeler_description(self)

    def registerWithSketchUp(self) -> "bool":
        return _openstudiomeasure.OSMeasure_registerWithSketchUp(self)

    def registerWithApplication(self) -> "bool":
        return _openstudiomeasure.OSMeasure_registerWithApplication(self)

    def __init__(self):
        if self.__class__ == OSMeasure:
            _self = None
        else:
            _self = self
        this = _openstudiomeasure.new_OSMeasure(_self, )
        try:
            self.this.append(this)
        except:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_OSMeasure(self)
        return weakref_proxy(self)
OSMeasure_swigregister = _openstudiomeasure.OSMeasure_swigregister
OSMeasure_swigregister(OSMeasure)

class ModelMeasure(OSMeasure):
    __swig_setmethods__ = {}
    for _s in [OSMeasure]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModelMeasure, name, value)
    __swig_getmethods__ = {}
    for _s in [OSMeasure]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModelMeasure, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_ModelMeasure
    __del__ = lambda self: None

    def arguments(self, model: 'Model') -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.ModelMeasure_arguments(self, model)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.ModelMeasure_outputs(self)

    def run(self, model: 'Model', runner: 'OSRunner', user_arguments: 'OSArgumentMap') -> "bool":
        return _openstudiomeasure.ModelMeasure_run(self, model, runner, user_arguments)

    def __init__(self):
        if self.__class__ == ModelMeasure:
            _self = None
        else:
            _self = self
        this = _openstudiomeasure.new_ModelMeasure(_self, )
        try:
            self.this.append(this)
        except:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_ModelMeasure(self)
        return weakref_proxy(self)
ModelMeasure_swigregister = _openstudiomeasure.ModelMeasure_swigregister
ModelMeasure_swigregister(ModelMeasure)

class EnergyPlusMeasure(OSMeasure):
    __swig_setmethods__ = {}
    for _s in [OSMeasure]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnergyPlusMeasure, name, value)
    __swig_getmethods__ = {}
    for _s in [OSMeasure]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnergyPlusMeasure, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_EnergyPlusMeasure
    __del__ = lambda self: None

    def arguments(self, workspace: 'Workspace') -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.EnergyPlusMeasure_arguments(self, workspace)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.EnergyPlusMeasure_outputs(self)

    def run(self, workspace: 'Workspace', runner: 'OSRunner', user_arguments: 'OSArgumentMap') -> "bool":
        return _openstudiomeasure.EnergyPlusMeasure_run(self, workspace, runner, user_arguments)

    def __init__(self):
        if self.__class__ == EnergyPlusMeasure:
            _self = None
        else:
            _self = self
        this = _openstudiomeasure.new_EnergyPlusMeasure(_self, )
        try:
            self.this.append(this)
        except:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_EnergyPlusMeasure(self)
        return weakref_proxy(self)
EnergyPlusMeasure_swigregister = _openstudiomeasure.EnergyPlusMeasure_swigregister
EnergyPlusMeasure_swigregister(EnergyPlusMeasure)

class ReportingMeasure(OSMeasure):
    __swig_setmethods__ = {}
    for _s in [OSMeasure]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ReportingMeasure, name, value)
    __swig_getmethods__ = {}
    for _s in [OSMeasure]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ReportingMeasure, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomeasure.delete_ReportingMeasure
    __del__ = lambda self: None

    def arguments(self) -> "std::vector< openstudio::measure::OSArgument,std::allocator< openstudio::measure::OSArgument > >":
        return _openstudiomeasure.ReportingMeasure_arguments(self)

    def outputs(self) -> "std::vector< openstudio::measure::OSOutput,std::allocator< openstudio::measure::OSOutput > >":
        return _openstudiomeasure.ReportingMeasure_outputs(self)

    def run(self, runner: 'OSRunner', user_arguments: 'OSArgumentMap') -> "bool":
        return _openstudiomeasure.ReportingMeasure_run(self, runner, user_arguments)

    def energyPlusOutputRequests(self, runner: 'OSRunner', user_arguments: 'OSArgumentMap') -> "std::vector< openstudio::IdfObject,std::allocator< openstudio::IdfObject > >":
        return _openstudiomeasure.ReportingMeasure_energyPlusOutputRequests(self, runner, user_arguments)

    def __init__(self):
        if self.__class__ == ReportingMeasure:
            _self = None
        else:
            _self = self
        this = _openstudiomeasure.new_ReportingMeasure(_self, )
        try:
            self.this.append(this)
        except:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _openstudiomeasure.disown_ReportingMeasure(self)
        return weakref_proxy(self)
ReportingMeasure_swigregister = _openstudiomeasure.ReportingMeasure_swigregister
ReportingMeasure_swigregister(ReportingMeasure)

# This file is compatible with both classic and new-style classes.


