# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openstudiomodelgeometry', [dirname(__file__)])
        except ImportError:
            import _openstudiomodelgeometry
            return _openstudiomodelgeometry
        if fp is not None:
            try:
                _mod = imp.load_module('_openstudiomodelgeometry', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openstudiomodelgeometry = swig_import_helper()
    del swig_import_helper
else:
    import _openstudiomodelgeometry
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _openstudiomodelgeometry.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudiomodelgeometry.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelgeometry.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomodelgeometry.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomodelgeometry.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudiomodelgeometry.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openstudiomodelgeometry.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_openstudiomodelgeometry.SHARED_PTR_DISOWN_swigconstant(_openstudiomodelgeometry)
SHARED_PTR_DISOWN = _openstudiomodelgeometry.SHARED_PTR_DISOWN
from .import openstudioutilities
from .import openstudioutilitiescore
from .import openstudioutilitiestime
from .import openstudioutilitiesdata
from .import openstudioutilitiesunits
from .import openstudioutilitiesplot
from .import openstudioutilitiesgeometry
from .import openstudioutilitiessql
from .import openstudioutilitiesbcl
from .import openstudioutilitiesidd
from .import openstudioutilitiesidf
from .import openstudioutilitiesfiletypes
from .import openstudiomodelcore
from .import openstudiomodelsimulation
from .import openstudiomodelresources
class OptionalSite(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSite, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSite(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSite_reset(self)

    def __ref__(self) -> "openstudio::model::Site":
        return _openstudiomodelgeometry.OptionalSite___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSite_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSite_isNull(self)

    def get(self) -> "openstudio::model::Site":
        return _openstudiomodelgeometry.OptionalSite_get(self)

    def set(self, t: 'Site') -> "void":
        return _openstudiomodelgeometry.OptionalSite_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSite
    __del__ = lambda self: None
OptionalSite_swigregister = _openstudiomodelgeometry.OptionalSite_swigregister
OptionalSite_swigregister(OptionalSite)

class OptionalFacility(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalFacility, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalFacility, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalFacility(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalFacility_reset(self)

    def __ref__(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.OptionalFacility___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFacility_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFacility_isNull(self)

    def get(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.OptionalFacility_get(self)

    def set(self, t: 'Facility') -> "void":
        return _openstudiomodelgeometry.OptionalFacility_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalFacility
    __del__ = lambda self: None
OptionalFacility_swigregister = _openstudiomodelgeometry.OptionalFacility_swigregister
OptionalFacility_swigregister(OptionalFacility)

class OptionalBuilding(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalBuilding, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalBuilding, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalBuilding(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuilding_reset(self)

    def __ref__(self) -> "openstudio::model::Building":
        return _openstudiomodelgeometry.OptionalBuilding___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuilding_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuilding_isNull(self)

    def get(self) -> "openstudio::model::Building":
        return _openstudiomodelgeometry.OptionalBuilding_get(self)

    def set(self, t: 'Building') -> "void":
        return _openstudiomodelgeometry.OptionalBuilding_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuilding
    __del__ = lambda self: None
OptionalBuilding_swigregister = _openstudiomodelgeometry.OptionalBuilding_swigregister
OptionalBuilding_swigregister(OptionalBuilding)

class BuildingStoryVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingStoryVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingStoryVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.BuildingStoryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::BuildingStory >::value_type":
        return _openstudiomodelgeometry.BuildingStoryVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::BuildingStory >::difference_type', j: 'std::vector< openstudio::model::BuildingStory >::difference_type') -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > > *":
        return _openstudiomodelgeometry.BuildingStoryVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::BuildingStory >::difference_type', j: 'std::vector< openstudio::model::BuildingStory >::difference_type') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector___setitem__(self, *args)

    def append(self, x: 'BuildingStory') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.BuildingStoryVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_clear(self)

    def swap(self, v: 'BuildingStoryVector') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::BuildingStory >::allocator_type":
        return _openstudiomodelgeometry.BuildingStoryVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::BuildingStory >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::BuildingStory >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::BuildingStory >::iterator":
        return _openstudiomodelgeometry.BuildingStoryVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_BuildingStoryVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'BuildingStory') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector_front(self)

    def back(self) -> "std::vector< openstudio::model::BuildingStory >::value_type const &":
        return _openstudiomodelgeometry.BuildingStoryVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::BuildingStory >::size_type', x: 'BuildingStory') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::BuildingStory >::size_type', x: 'BuildingStory') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::BuildingStory >::size_type') -> "void":
        return _openstudiomodelgeometry.BuildingStoryVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::BuildingStory >::size_type":
        return _openstudiomodelgeometry.BuildingStoryVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingStoryVector
    __del__ = lambda self: None
BuildingStoryVector_swigregister = _openstudiomodelgeometry.BuildingStoryVector_swigregister
BuildingStoryVector_swigregister(BuildingStoryVector)

class OptionalBuildingStory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalBuildingStory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalBuildingStory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalBuildingStory(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuildingStory_reset(self)

    def __ref__(self) -> "openstudio::model::BuildingStory":
        return _openstudiomodelgeometry.OptionalBuildingStory___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingStory_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingStory_isNull(self)

    def get(self) -> "openstudio::model::BuildingStory":
        return _openstudiomodelgeometry.OptionalBuildingStory_get(self)

    def set(self, t: 'BuildingStory') -> "void":
        return _openstudiomodelgeometry.OptionalBuildingStory_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuildingStory
    __del__ = lambda self: None
OptionalBuildingStory_swigregister = _openstudiomodelgeometry.OptionalBuildingStory_swigregister
OptionalBuildingStory_swigregister(OptionalBuildingStory)

class BuildingUnitVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingUnitVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingUnitVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.BuildingUnitVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type":
        return _openstudiomodelgeometry.BuildingUnitVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::BuildingUnit >::difference_type', j: 'std::vector< openstudio::model::BuildingUnit >::difference_type') -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > > *":
        return _openstudiomodelgeometry.BuildingUnitVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::BuildingUnit >::difference_type', j: 'std::vector< openstudio::model::BuildingUnit >::difference_type') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector___setitem__(self, *args)

    def append(self, x: 'BuildingUnit') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.BuildingUnitVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_clear(self)

    def swap(self, v: 'BuildingUnitVector') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::BuildingUnit >::allocator_type":
        return _openstudiomodelgeometry.BuildingUnitVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::BuildingUnit >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::BuildingUnit >::reverse_iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::BuildingUnit >::iterator":
        return _openstudiomodelgeometry.BuildingUnitVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_BuildingUnitVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'BuildingUnit') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector_front(self)

    def back(self) -> "std::vector< openstudio::model::BuildingUnit >::value_type const &":
        return _openstudiomodelgeometry.BuildingUnitVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::BuildingUnit >::size_type', x: 'BuildingUnit') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::BuildingUnit >::size_type', x: 'BuildingUnit') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::BuildingUnit >::size_type') -> "void":
        return _openstudiomodelgeometry.BuildingUnitVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::BuildingUnit >::size_type":
        return _openstudiomodelgeometry.BuildingUnitVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingUnitVector
    __del__ = lambda self: None
BuildingUnitVector_swigregister = _openstudiomodelgeometry.BuildingUnitVector_swigregister
BuildingUnitVector_swigregister(BuildingUnitVector)

class OptionalBuildingUnit(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalBuildingUnit, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalBuildingUnit, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalBuildingUnit(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalBuildingUnit_reset(self)

    def __ref__(self) -> "openstudio::model::BuildingUnit":
        return _openstudiomodelgeometry.OptionalBuildingUnit___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingUnit_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalBuildingUnit_isNull(self)

    def get(self) -> "openstudio::model::BuildingUnit":
        return _openstudiomodelgeometry.OptionalBuildingUnit_get(self)

    def set(self, t: 'BuildingUnit') -> "void":
        return _openstudiomodelgeometry.OptionalBuildingUnit_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalBuildingUnit
    __del__ = lambda self: None
OptionalBuildingUnit_swigregister = _openstudiomodelgeometry.OptionalBuildingUnit_swigregister
OptionalBuildingUnit_swigregister(OptionalBuildingUnit)

class PlanarSurfaceGroupVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlanarSurfaceGroupVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PlanarSurfaceGroupVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type') -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > > *":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::PlanarSurfaceGroup >::difference_type') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector___setitem__(self, *args)

    def append(self, x: 'PlanarSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_clear(self)

    def swap(self, v: 'PlanarSurfaceGroupVector') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_PlanarSurfaceGroupVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'PlanarSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::PlanarSurfaceGroup >::size_type', x: 'PlanarSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::PlanarSurfaceGroup >::size_type', x: 'PlanarSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::PlanarSurfaceGroup >::size_type') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::PlanarSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceGroupVector
    __del__ = lambda self: None
PlanarSurfaceGroupVector_swigregister = _openstudiomodelgeometry.PlanarSurfaceGroupVector_swigregister
PlanarSurfaceGroupVector_swigregister(PlanarSurfaceGroupVector)

class OptionalPlanarSurfaceGroup(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalPlanarSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalPlanarSurfaceGroup, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalPlanarSurfaceGroup(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::PlanarSurfaceGroup":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::PlanarSurfaceGroup":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_get(self)

    def set(self, t: 'PlanarSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPlanarSurfaceGroup
    __del__ = lambda self: None
OptionalPlanarSurfaceGroup_swigregister = _openstudiomodelgeometry.OptionalPlanarSurfaceGroup_swigregister
OptionalPlanarSurfaceGroup_swigregister(OptionalPlanarSurfaceGroup)

class SpaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::Space >::value_type":
        return _openstudiomodelgeometry.SpaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::Space >::difference_type', j: 'std::vector< openstudio::model::Space >::difference_type') -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > > *":
        return _openstudiomodelgeometry.SpaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::Space >::difference_type', j: 'std::vector< openstudio::model::Space >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector___setitem__(self, *args)

    def append(self, x: 'Space') -> "void":
        return _openstudiomodelgeometry.SpaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceVector_clear(self)

    def swap(self, v: 'SpaceVector') -> "void":
        return _openstudiomodelgeometry.SpaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::Space >::allocator_type":
        return _openstudiomodelgeometry.SpaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Space >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Space >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Space >::iterator":
        return _openstudiomodelgeometry.SpaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Space') -> "void":
        return _openstudiomodelgeometry.SpaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Space >::value_type const &":
        return _openstudiomodelgeometry.SpaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::Space >::size_type', x: 'Space') -> "void":
        return _openstudiomodelgeometry.SpaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::Space >::size_type', x: 'Space') -> "void":
        return _openstudiomodelgeometry.SpaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::Space >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Space >::size_type":
        return _openstudiomodelgeometry.SpaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceVector
    __del__ = lambda self: None
SpaceVector_swigregister = _openstudiomodelgeometry.SpaceVector_swigregister
SpaceVector_swigregister(SpaceVector)

class OptionalSpace(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpace, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpace, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpace(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpace_reset(self)

    def __ref__(self) -> "openstudio::model::Space":
        return _openstudiomodelgeometry.OptionalSpace___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpace_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpace_isNull(self)

    def get(self) -> "openstudio::model::Space":
        return _openstudiomodelgeometry.OptionalSpace_get(self)

    def set(self, t: 'Space') -> "void":
        return _openstudiomodelgeometry.OptionalSpace_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpace
    __del__ = lambda self: None
OptionalSpace_swigregister = _openstudiomodelgeometry.OptionalSpace_swigregister
OptionalSpace_swigregister(OptionalSpace)

class SpaceItemVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceItemVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceItemVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceItemVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceItem >::value_type":
        return _openstudiomodelgeometry.SpaceItemVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceItem >::difference_type', j: 'std::vector< openstudio::model::SpaceItem >::difference_type') -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > > *":
        return _openstudiomodelgeometry.SpaceItemVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceItem >::difference_type', j: 'std::vector< openstudio::model::SpaceItem >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector___setitem__(self, *args)

    def append(self, x: 'SpaceItem') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceItemVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_clear(self)

    def swap(self, v: 'SpaceItemVector') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceItem >::allocator_type":
        return _openstudiomodelgeometry.SpaceItemVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceItem >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceItemVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceItem >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceItemVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceItem >::iterator":
        return _openstudiomodelgeometry.SpaceItemVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceItemVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceItem') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceItem >::value_type const &":
        return _openstudiomodelgeometry.SpaceItemVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceItem >::size_type', x: 'SpaceItem') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceItem >::size_type', x: 'SpaceItem') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceItem >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceItemVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceItem >::size_type":
        return _openstudiomodelgeometry.SpaceItemVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceItemVector
    __del__ = lambda self: None
SpaceItemVector_swigregister = _openstudiomodelgeometry.SpaceItemVector_swigregister
SpaceItemVector_swigregister(SpaceItemVector)

class OptionalSpaceItem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceItem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceItem, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceItem(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceItem_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceItem":
        return _openstudiomodelgeometry.OptionalSpaceItem___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceItem_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceItem_isNull(self)

    def get(self) -> "openstudio::model::SpaceItem":
        return _openstudiomodelgeometry.OptionalSpaceItem_get(self)

    def set(self, t: 'SpaceItem') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceItem_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceItem
    __del__ = lambda self: None
OptionalSpaceItem_swigregister = _openstudiomodelgeometry.OptionalSpaceItem_swigregister
OptionalSpaceItem_swigregister(OptionalSpaceItem)

class SpaceLoadVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceLoadVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceLoadVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceLoadVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type":
        return _openstudiomodelgeometry.SpaceLoadVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceLoad >::difference_type', j: 'std::vector< openstudio::model::SpaceLoad >::difference_type') -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > > *":
        return _openstudiomodelgeometry.SpaceLoadVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceLoad >::difference_type', j: 'std::vector< openstudio::model::SpaceLoad >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector___setitem__(self, *args)

    def append(self, x: 'SpaceLoad') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_clear(self)

    def swap(self, v: 'SpaceLoadVector') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceLoad >::allocator_type":
        return _openstudiomodelgeometry.SpaceLoadVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceLoad >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceLoad >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceLoad >::iterator":
        return _openstudiomodelgeometry.SpaceLoadVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceLoadVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceLoad') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceLoad >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceLoad >::size_type', x: 'SpaceLoad') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceLoad >::size_type', x: 'SpaceLoad') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceLoad >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceLoadVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceLoad >::size_type":
        return _openstudiomodelgeometry.SpaceLoadVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadVector
    __del__ = lambda self: None
SpaceLoadVector_swigregister = _openstudiomodelgeometry.SpaceLoadVector_swigregister
SpaceLoadVector_swigregister(SpaceLoadVector)

class OptionalSpaceLoad(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceLoad, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceLoad, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceLoad(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoad_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceLoad":
        return _openstudiomodelgeometry.OptionalSpaceLoad___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoad_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoad_isNull(self)

    def get(self) -> "openstudio::model::SpaceLoad":
        return _openstudiomodelgeometry.OptionalSpaceLoad_get(self)

    def set(self, t: 'SpaceLoad') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoad_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceLoad
    __del__ = lambda self: None
OptionalSpaceLoad_swigregister = _openstudiomodelgeometry.OptionalSpaceLoad_swigregister
OptionalSpaceLoad_swigregister(OptionalSpaceLoad)

class SpaceLoadInstanceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceLoadInstanceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceLoadInstanceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceLoadInstance >::difference_type', j: 'std::vector< openstudio::model::SpaceLoadInstance >::difference_type') -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > > *":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceLoadInstance >::difference_type', j: 'std::vector< openstudio::model::SpaceLoadInstance >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector___setitem__(self, *args)

    def append(self, x: 'SpaceLoadInstance') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_clear(self)

    def swap(self, v: 'SpaceLoadInstanceVector') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::allocator_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceLoadInstance >::iterator":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceLoadInstanceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceLoadInstance') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceLoadInstance >::size_type', x: 'SpaceLoadInstance') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceLoadInstance >::size_type', x: 'SpaceLoadInstance') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceLoadInstance >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceLoadInstance >::size_type":
        return _openstudiomodelgeometry.SpaceLoadInstanceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadInstanceVector
    __del__ = lambda self: None
SpaceLoadInstanceVector_swigregister = _openstudiomodelgeometry.SpaceLoadInstanceVector_swigregister
SpaceLoadInstanceVector_swigregister(SpaceLoadInstanceVector)

class OptionalSpaceLoadInstance(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceLoadInstance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceLoadInstance, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceLoadInstance(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceLoadInstance":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_isNull(self)

    def get(self) -> "openstudio::model::SpaceLoadInstance":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_get(self)

    def set(self, t: 'SpaceLoadInstance') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceLoadInstance_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceLoadInstance
    __del__ = lambda self: None
OptionalSpaceLoadInstance_swigregister = _openstudiomodelgeometry.OptionalSpaceLoadInstance_swigregister
OptionalSpaceLoadInstance_swigregister(OptionalSpaceLoadInstance)

class LightsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LightsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LightsVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LightsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::Lights >::value_type":
        return _openstudiomodelgeometry.LightsVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::Lights >::difference_type', j: 'std::vector< openstudio::model::Lights >::difference_type') -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > > *":
        return _openstudiomodelgeometry.LightsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::Lights >::difference_type', j: 'std::vector< openstudio::model::Lights >::difference_type') -> "void":
        return _openstudiomodelgeometry.LightsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector___setitem__(self, *args)

    def append(self, x: 'Lights') -> "void":
        return _openstudiomodelgeometry.LightsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LightsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LightsVector_clear(self)

    def swap(self, v: 'LightsVector') -> "void":
        return _openstudiomodelgeometry.LightsVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::Lights >::allocator_type":
        return _openstudiomodelgeometry.LightsVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Lights >::reverse_iterator":
        return _openstudiomodelgeometry.LightsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Lights >::reverse_iterator":
        return _openstudiomodelgeometry.LightsVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LightsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Lights >::iterator":
        return _openstudiomodelgeometry.LightsVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_LightsVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Lights') -> "void":
        return _openstudiomodelgeometry.LightsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Lights >::value_type const &":
        return _openstudiomodelgeometry.LightsVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::Lights >::size_type', x: 'Lights') -> "void":
        return _openstudiomodelgeometry.LightsVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::Lights >::size_type', x: 'Lights') -> "void":
        return _openstudiomodelgeometry.LightsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LightsVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::Lights >::size_type') -> "void":
        return _openstudiomodelgeometry.LightsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Lights >::size_type":
        return _openstudiomodelgeometry.LightsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightsVector
    __del__ = lambda self: None
LightsVector_swigregister = _openstudiomodelgeometry.LightsVector_swigregister
LightsVector_swigregister(LightsVector)

class OptionalLights(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalLights, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalLights, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalLights(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLights_reset(self)

    def __ref__(self) -> "openstudio::model::Lights":
        return _openstudiomodelgeometry.OptionalLights___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLights_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLights_isNull(self)

    def get(self) -> "openstudio::model::Lights":
        return _openstudiomodelgeometry.OptionalLights_get(self)

    def set(self, t: 'Lights') -> "void":
        return _openstudiomodelgeometry.OptionalLights_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLights
    __del__ = lambda self: None
OptionalLights_swigregister = _openstudiomodelgeometry.OptionalLights_swigregister
OptionalLights_swigregister(OptionalLights)

class PlanarSurfaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlanarSurfaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PlanarSurfaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PlanarSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::PlanarSurface >::difference_type', j: 'std::vector< openstudio::model::PlanarSurface >::difference_type') -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > > *":
        return _openstudiomodelgeometry.PlanarSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::PlanarSurface >::difference_type', j: 'std::vector< openstudio::model::PlanarSurface >::difference_type') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector___setitem__(self, *args)

    def append(self, x: 'PlanarSurface') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_clear(self)

    def swap(self, v: 'PlanarSurfaceVector') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::PlanarSurface >::allocator_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::PlanarSurface >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::PlanarSurface >::reverse_iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::PlanarSurface >::iterator":
        return _openstudiomodelgeometry.PlanarSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_PlanarSurfaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'PlanarSurface') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::PlanarSurface >::value_type const &":
        return _openstudiomodelgeometry.PlanarSurfaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::PlanarSurface >::size_type', x: 'PlanarSurface') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::PlanarSurface >::size_type', x: 'PlanarSurface') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::PlanarSurface >::size_type') -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::PlanarSurface >::size_type":
        return _openstudiomodelgeometry.PlanarSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceVector
    __del__ = lambda self: None
PlanarSurfaceVector_swigregister = _openstudiomodelgeometry.PlanarSurfaceVector_swigregister
PlanarSurfaceVector_swigregister(PlanarSurfaceVector)

class OptionalPlanarSurface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalPlanarSurface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalPlanarSurface, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalPlanarSurface(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurface_reset(self)

    def __ref__(self) -> "openstudio::model::PlanarSurface":
        return _openstudiomodelgeometry.OptionalPlanarSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPlanarSurface_isNull(self)

    def get(self) -> "openstudio::model::PlanarSurface":
        return _openstudiomodelgeometry.OptionalPlanarSurface_get(self)

    def set(self, t: 'PlanarSurface') -> "void":
        return _openstudiomodelgeometry.OptionalPlanarSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPlanarSurface
    __del__ = lambda self: None
OptionalPlanarSurface_swigregister = _openstudiomodelgeometry.OptionalPlanarSurface_swigregister
OptionalPlanarSurface_swigregister(OptionalPlanarSurface)

class DefaultConstructionSetVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultConstructionSetVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultConstructionSetVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::DefaultConstructionSet >::difference_type', j: 'std::vector< openstudio::model::DefaultConstructionSet >::difference_type') -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > > *":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::DefaultConstructionSet >::difference_type', j: 'std::vector< openstudio::model::DefaultConstructionSet >::difference_type') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector___setitem__(self, *args)

    def append(self, x: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_clear(self)

    def swap(self, v: 'DefaultConstructionSetVector') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::allocator_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::reverse_iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::reverse_iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DefaultConstructionSet >::iterator":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_DefaultConstructionSetVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::value_type const &":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::DefaultConstructionSet >::size_type', x: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::DefaultConstructionSet >::size_type', x: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::DefaultConstructionSet >::size_type') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DefaultConstructionSet >::size_type":
        return _openstudiomodelgeometry.DefaultConstructionSetVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DefaultConstructionSetVector
    __del__ = lambda self: None
DefaultConstructionSetVector_swigregister = _openstudiomodelgeometry.DefaultConstructionSetVector_swigregister
DefaultConstructionSetVector_swigregister(DefaultConstructionSetVector)

class OptionalDefaultConstructionSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDefaultConstructionSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDefaultConstructionSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalDefaultConstructionSet(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_reset(self)

    def __ref__(self) -> "openstudio::model::DefaultConstructionSet":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_isNull(self)

    def get(self) -> "openstudio::model::DefaultConstructionSet":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_get(self)

    def set(self, t: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.OptionalDefaultConstructionSet_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDefaultConstructionSet
    __del__ = lambda self: None
OptionalDefaultConstructionSet_swigregister = _openstudiomodelgeometry.OptionalDefaultConstructionSet_swigregister
OptionalDefaultConstructionSet_swigregister(OptionalDefaultConstructionSet)

class SurfaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::Surface >::value_type":
        return _openstudiomodelgeometry.SurfaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::Surface >::difference_type', j: 'std::vector< openstudio::model::Surface >::difference_type') -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > > *":
        return _openstudiomodelgeometry.SurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::Surface >::difference_type', j: 'std::vector< openstudio::model::Surface >::difference_type') -> "void":
        return _openstudiomodelgeometry.SurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector___setitem__(self, *args)

    def append(self, x: 'Surface') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_clear(self)

    def swap(self, v: 'SurfaceVector') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::Surface >::allocator_type":
        return _openstudiomodelgeometry.SurfaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Surface >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Surface >::reverse_iterator":
        return _openstudiomodelgeometry.SurfaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Surface >::iterator":
        return _openstudiomodelgeometry.SurfaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Surface') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Surface >::value_type const &":
        return _openstudiomodelgeometry.SurfaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::Surface >::size_type', x: 'Surface') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::Surface >::size_type', x: 'Surface') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::Surface >::size_type') -> "void":
        return _openstudiomodelgeometry.SurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Surface >::size_type":
        return _openstudiomodelgeometry.SurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceVector
    __del__ = lambda self: None
SurfaceVector_swigregister = _openstudiomodelgeometry.SurfaceVector_swigregister
SurfaceVector_swigregister(SurfaceVector)

class OptionalSurface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSurface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSurface, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSurface(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurface_reset(self)

    def __ref__(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.OptionalSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurface_isNull(self)

    def get(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.OptionalSurface_get(self)

    def set(self, t: 'Surface') -> "void":
        return _openstudiomodelgeometry.OptionalSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurface
    __del__ = lambda self: None
OptionalSurface_swigregister = _openstudiomodelgeometry.OptionalSurface_swigregister
OptionalSurface_swigregister(OptionalSurface)

class SubSurfaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubSurfaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SubSurfaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SubSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SubSurface >::value_type":
        return _openstudiomodelgeometry.SubSurfaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SubSurface >::difference_type', j: 'std::vector< openstudio::model::SubSurface >::difference_type') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > > *":
        return _openstudiomodelgeometry.SubSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SubSurface >::difference_type', j: 'std::vector< openstudio::model::SubSurface >::difference_type') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector___setitem__(self, *args)

    def append(self, x: 'SubSurface') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SubSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_clear(self)

    def swap(self, v: 'SubSurfaceVector') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SubSurface >::allocator_type":
        return _openstudiomodelgeometry.SubSurfaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SubSurface >::reverse_iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SubSurface >::reverse_iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SubSurface >::iterator":
        return _openstudiomodelgeometry.SubSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SubSurfaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SubSurface') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SubSurface >::value_type const &":
        return _openstudiomodelgeometry.SubSurfaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SubSurface >::size_type', x: 'SubSurface') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SubSurface >::size_type', x: 'SubSurface') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SubSurface >::size_type') -> "void":
        return _openstudiomodelgeometry.SubSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SubSurface >::size_type":
        return _openstudiomodelgeometry.SubSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SubSurfaceVector
    __del__ = lambda self: None
SubSurfaceVector_swigregister = _openstudiomodelgeometry.SubSurfaceVector_swigregister
SubSurfaceVector_swigregister(SubSurfaceVector)

class OptionalSubSurface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSubSurface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSubSurface, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSubSurface(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSubSurface_reset(self)

    def __ref__(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.OptionalSubSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSubSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSubSurface_isNull(self)

    def get(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.OptionalSubSurface_get(self)

    def set(self, t: 'SubSurface') -> "void":
        return _openstudiomodelgeometry.OptionalSubSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSubSurface
    __del__ = lambda self: None
OptionalSubSurface_swigregister = _openstudiomodelgeometry.OptionalSubSurface_swigregister
OptionalSubSurface_swigregister(OptionalSubSurface)

class ShadingSurfaceGroupVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShadingSurfaceGroupVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShadingSurfaceGroupVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type') -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > > *":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::ShadingSurfaceGroup >::difference_type') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector___setitem__(self, *args)

    def append(self, x: 'ShadingSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_clear(self)

    def swap(self, v: 'ShadingSurfaceGroupVector') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ShadingSurfaceGroupVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ShadingSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ShadingSurfaceGroup >::size_type', x: 'ShadingSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ShadingSurfaceGroup >::size_type', x: 'ShadingSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ShadingSurfaceGroup >::size_type') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceGroupVector
    __del__ = lambda self: None
ShadingSurfaceGroupVector_swigregister = _openstudiomodelgeometry.ShadingSurfaceGroupVector_swigregister
ShadingSurfaceGroupVector_swigregister(ShadingSurfaceGroupVector)

class OptionalShadingSurfaceGroup(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalShadingSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalShadingSurfaceGroup, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalShadingSurfaceGroup(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::ShadingSurfaceGroup":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::ShadingSurfaceGroup":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_get(self)

    def set(self, t: 'ShadingSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalShadingSurfaceGroup
    __del__ = lambda self: None
OptionalShadingSurfaceGroup_swigregister = _openstudiomodelgeometry.OptionalShadingSurfaceGroup_swigregister
OptionalShadingSurfaceGroup_swigregister(OptionalShadingSurfaceGroup)

class ShadingSurfaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShadingSurfaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShadingSurfaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ShadingSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ShadingSurface >::difference_type', j: 'std::vector< openstudio::model::ShadingSurface >::difference_type') -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > > *":
        return _openstudiomodelgeometry.ShadingSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ShadingSurface >::difference_type', j: 'std::vector< openstudio::model::ShadingSurface >::difference_type') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector___setitem__(self, *args)

    def append(self, x: 'ShadingSurface') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_clear(self)

    def swap(self, v: 'ShadingSurfaceVector') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ShadingSurface >::allocator_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ShadingSurface >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ShadingSurface >::reverse_iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ShadingSurface >::iterator":
        return _openstudiomodelgeometry.ShadingSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ShadingSurfaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ShadingSurface') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ShadingSurface >::value_type const &":
        return _openstudiomodelgeometry.ShadingSurfaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ShadingSurface >::size_type', x: 'ShadingSurface') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ShadingSurface >::size_type', x: 'ShadingSurface') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ShadingSurface >::size_type') -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ShadingSurface >::size_type":
        return _openstudiomodelgeometry.ShadingSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceVector
    __del__ = lambda self: None
ShadingSurfaceVector_swigregister = _openstudiomodelgeometry.ShadingSurfaceVector_swigregister
ShadingSurfaceVector_swigregister(ShadingSurfaceVector)

class OptionalShadingSurface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalShadingSurface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalShadingSurface, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalShadingSurface(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurface_reset(self)

    def __ref__(self) -> "openstudio::model::ShadingSurface":
        return _openstudiomodelgeometry.OptionalShadingSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalShadingSurface_isNull(self)

    def get(self) -> "openstudio::model::ShadingSurface":
        return _openstudiomodelgeometry.OptionalShadingSurface_get(self)

    def set(self, t: 'ShadingSurface') -> "void":
        return _openstudiomodelgeometry.OptionalShadingSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalShadingSurface
    __del__ = lambda self: None
OptionalShadingSurface_swigregister = _openstudiomodelgeometry.OptionalShadingSurface_swigregister
OptionalShadingSurface_swigregister(OptionalShadingSurface)

class InteriorPartitionSurfaceGroupVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteriorPartitionSurfaceGroupVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InteriorPartitionSurfaceGroupVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type') -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > > *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type', j: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::difference_type') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector___setitem__(self, *args)

    def append(self, x: 'InteriorPartitionSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_clear(self)

    def swap(self, v: 'InteriorPartitionSurfaceGroupVector') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::allocator_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_InteriorPartitionSurfaceGroupVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'InteriorPartitionSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type', x: 'InteriorPartitionSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type', x: 'InteriorPartitionSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceGroupVector
    __del__ = lambda self: None
InteriorPartitionSurfaceGroupVector_swigregister = _openstudiomodelgeometry.InteriorPartitionSurfaceGroupVector_swigregister
InteriorPartitionSurfaceGroupVector_swigregister(InteriorPartitionSurfaceGroupVector)

class OptionalInteriorPartitionSurfaceGroup(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalInteriorPartitionSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalInteriorPartitionSurfaceGroup, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalInteriorPartitionSurfaceGroup(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_reset(self)

    def __ref__(self) -> "openstudio::model::InteriorPartitionSurfaceGroup":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_isNull(self)

    def get(self) -> "openstudio::model::InteriorPartitionSurfaceGroup":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_get(self)

    def set(self, t: 'InteriorPartitionSurfaceGroup') -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInteriorPartitionSurfaceGroup
    __del__ = lambda self: None
OptionalInteriorPartitionSurfaceGroup_swigregister = _openstudiomodelgeometry.OptionalInteriorPartitionSurfaceGroup_swigregister
OptionalInteriorPartitionSurfaceGroup_swigregister(OptionalInteriorPartitionSurfaceGroup)

class InteriorPartitionSurfaceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteriorPartitionSurfaceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InteriorPartitionSurfaceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::InteriorPartitionSurface >::difference_type', j: 'std::vector< openstudio::model::InteriorPartitionSurface >::difference_type') -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > > *":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::InteriorPartitionSurface >::difference_type', j: 'std::vector< openstudio::model::InteriorPartitionSurface >::difference_type') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector___setitem__(self, *args)

    def append(self, x: 'InteriorPartitionSurface') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_clear(self)

    def swap(self, v: 'InteriorPartitionSurfaceVector') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::allocator_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::reverse_iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InteriorPartitionSurface >::iterator":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_InteriorPartitionSurfaceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'InteriorPartitionSurface') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::value_type const &":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::InteriorPartitionSurface >::size_type', x: 'InteriorPartitionSurface') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::InteriorPartitionSurface >::size_type', x: 'InteriorPartitionSurface') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::InteriorPartitionSurface >::size_type') -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InteriorPartitionSurface >::size_type":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceVector
    __del__ = lambda self: None
InteriorPartitionSurfaceVector_swigregister = _openstudiomodelgeometry.InteriorPartitionSurfaceVector_swigregister
InteriorPartitionSurfaceVector_swigregister(InteriorPartitionSurfaceVector)

class OptionalInteriorPartitionSurface(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalInteriorPartitionSurface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalInteriorPartitionSurface, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalInteriorPartitionSurface(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_reset(self)

    def __ref__(self) -> "openstudio::model::InteriorPartitionSurface":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_isNull(self)

    def get(self) -> "openstudio::model::InteriorPartitionSurface":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_get(self)

    def set(self, t: 'InteriorPartitionSurface') -> "void":
        return _openstudiomodelgeometry.OptionalInteriorPartitionSurface_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInteriorPartitionSurface
    __del__ = lambda self: None
OptionalInteriorPartitionSurface_swigregister = _openstudiomodelgeometry.OptionalInteriorPartitionSurface_swigregister
OptionalInteriorPartitionSurface_swigregister(OptionalInteriorPartitionSurface)

class SurfacePropertyOtherSideCoefficientsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyOtherSideCoefficientsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyOtherSideCoefficientsVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type') -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > > *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::difference_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector___setitem__(self, *args)

    def append(self, x: 'SurfacePropertyOtherSideCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_clear(self)

    def swap(self, v: 'SurfacePropertyOtherSideCoefficientsVector') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfacePropertyOtherSideCoefficientsVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SurfacePropertyOtherSideCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type', x: 'SurfacePropertyOtherSideCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type', x: 'SurfacePropertyOtherSideCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideCoefficientsVector
    __del__ = lambda self: None
SurfacePropertyOtherSideCoefficientsVector_swigregister = _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficientsVector_swigregister
SurfacePropertyOtherSideCoefficientsVector_swigregister(SurfacePropertyOtherSideCoefficientsVector)

class OptionalSurfacePropertyOtherSideCoefficients(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSurfacePropertyOtherSideCoefficients, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSurfacePropertyOtherSideCoefficients, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSurfacePropertyOtherSideCoefficients(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyOtherSideCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyOtherSideCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_get(self)

    def set(self, t: 'SurfacePropertyOtherSideCoefficients') -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyOtherSideCoefficients
    __del__ = lambda self: None
OptionalSurfacePropertyOtherSideCoefficients_swigregister = _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideCoefficients_swigregister
OptionalSurfacePropertyOtherSideCoefficients_swigregister(OptionalSurfacePropertyOtherSideCoefficients)

class SurfacePropertyOtherSideConditionsModelVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyOtherSideConditionsModelVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyOtherSideConditionsModelVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type') -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > > *":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::difference_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector___setitem__(self, *args)

    def append(self, x: 'SurfacePropertyOtherSideConditionsModel') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_clear(self)

    def swap(self, v: 'SurfacePropertyOtherSideConditionsModelVector') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfacePropertyOtherSideConditionsModelVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SurfacePropertyOtherSideConditionsModel') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type', x: 'SurfacePropertyOtherSideConditionsModel') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type', x: 'SurfacePropertyOtherSideConditionsModel') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideConditionsModelVector
    __del__ = lambda self: None
SurfacePropertyOtherSideConditionsModelVector_swigregister = _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModelVector_swigregister
SurfacePropertyOtherSideConditionsModelVector_swigregister(SurfacePropertyOtherSideConditionsModelVector)

class OptionalSurfacePropertyOtherSideConditionsModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSurfacePropertyOtherSideConditionsModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSurfacePropertyOtherSideConditionsModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSurfacePropertyOtherSideConditionsModel(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyOtherSideConditionsModel":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyOtherSideConditionsModel":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_get(self)

    def set(self, t: 'SurfacePropertyOtherSideConditionsModel') -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyOtherSideConditionsModel
    __del__ = lambda self: None
OptionalSurfacePropertyOtherSideConditionsModel_swigregister = _openstudiomodelgeometry.OptionalSurfacePropertyOtherSideConditionsModel_swigregister
OptionalSurfacePropertyOtherSideConditionsModel_swigregister(OptionalSurfacePropertyOtherSideConditionsModel)

class SurfacePropertyConvectionCoefficientsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyConvectionCoefficientsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyConvectionCoefficientsVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type') -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > > *":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::difference_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector___setitem__(self, *args)

    def append(self, x: 'SurfacePropertyConvectionCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_clear(self)

    def swap(self, v: 'SurfacePropertyConvectionCoefficientsVector') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfacePropertyConvectionCoefficientsVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SurfacePropertyConvectionCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type', x: 'SurfacePropertyConvectionCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type', x: 'SurfacePropertyConvectionCoefficients') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyConvectionCoefficientsVector
    __del__ = lambda self: None
SurfacePropertyConvectionCoefficientsVector_swigregister = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficientsVector_swigregister
SurfacePropertyConvectionCoefficientsVector_swigregister(SurfacePropertyConvectionCoefficientsVector)

class OptionalSurfacePropertyConvectionCoefficients(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSurfacePropertyConvectionCoefficients, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSurfacePropertyConvectionCoefficients, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSurfacePropertyConvectionCoefficients(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyConvectionCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyConvectionCoefficients":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_get(self)

    def set(self, t: 'SurfacePropertyConvectionCoefficients') -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyConvectionCoefficients
    __del__ = lambda self: None
OptionalSurfacePropertyConvectionCoefficients_swigregister = _openstudiomodelgeometry.OptionalSurfacePropertyConvectionCoefficients_swigregister
OptionalSurfacePropertyConvectionCoefficients_swigregister(OptionalSurfacePropertyConvectionCoefficients)

class PeopleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PeopleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PeopleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.PeopleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::People >::value_type":
        return _openstudiomodelgeometry.PeopleVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::People >::difference_type', j: 'std::vector< openstudio::model::People >::difference_type') -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > > *":
        return _openstudiomodelgeometry.PeopleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::People >::difference_type', j: 'std::vector< openstudio::model::People >::difference_type') -> "void":
        return _openstudiomodelgeometry.PeopleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector___setitem__(self, *args)

    def append(self, x: 'People') -> "void":
        return _openstudiomodelgeometry.PeopleVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.PeopleVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.PeopleVector_clear(self)

    def swap(self, v: 'PeopleVector') -> "void":
        return _openstudiomodelgeometry.PeopleVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::People >::allocator_type":
        return _openstudiomodelgeometry.PeopleVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::People >::reverse_iterator":
        return _openstudiomodelgeometry.PeopleVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::People >::reverse_iterator":
        return _openstudiomodelgeometry.PeopleVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.PeopleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::People >::iterator":
        return _openstudiomodelgeometry.PeopleVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_PeopleVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'People') -> "void":
        return _openstudiomodelgeometry.PeopleVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector_front(self)

    def back(self) -> "std::vector< openstudio::model::People >::value_type const &":
        return _openstudiomodelgeometry.PeopleVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::People >::size_type', x: 'People') -> "void":
        return _openstudiomodelgeometry.PeopleVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::People >::size_type', x: 'People') -> "void":
        return _openstudiomodelgeometry.PeopleVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.PeopleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::People >::size_type') -> "void":
        return _openstudiomodelgeometry.PeopleVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::People >::size_type":
        return _openstudiomodelgeometry.PeopleVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_PeopleVector
    __del__ = lambda self: None
PeopleVector_swigregister = _openstudiomodelgeometry.PeopleVector_swigregister
PeopleVector_swigregister(PeopleVector)

class OptionalPeople(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalPeople, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalPeople, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalPeople(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalPeople_reset(self)

    def __ref__(self) -> "openstudio::model::People":
        return _openstudiomodelgeometry.OptionalPeople___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPeople_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalPeople_isNull(self)

    def get(self) -> "openstudio::model::People":
        return _openstudiomodelgeometry.OptionalPeople_get(self)

    def set(self, t: 'People') -> "void":
        return _openstudiomodelgeometry.OptionalPeople_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalPeople
    __del__ = lambda self: None
OptionalPeople_swigregister = _openstudiomodelgeometry.OptionalPeople_swigregister
OptionalPeople_swigregister(OptionalPeople)

class LuminaireVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LuminaireVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LuminaireVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LuminaireVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::Luminaire >::value_type":
        return _openstudiomodelgeometry.LuminaireVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::Luminaire >::difference_type', j: 'std::vector< openstudio::model::Luminaire >::difference_type') -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > > *":
        return _openstudiomodelgeometry.LuminaireVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::Luminaire >::difference_type', j: 'std::vector< openstudio::model::Luminaire >::difference_type') -> "void":
        return _openstudiomodelgeometry.LuminaireVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector___setitem__(self, *args)

    def append(self, x: 'Luminaire') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LuminaireVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_clear(self)

    def swap(self, v: 'LuminaireVector') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::Luminaire >::allocator_type":
        return _openstudiomodelgeometry.LuminaireVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::Luminaire >::reverse_iterator":
        return _openstudiomodelgeometry.LuminaireVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::Luminaire >::reverse_iterator":
        return _openstudiomodelgeometry.LuminaireVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::Luminaire >::iterator":
        return _openstudiomodelgeometry.LuminaireVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_LuminaireVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Luminaire') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector_front(self)

    def back(self) -> "std::vector< openstudio::model::Luminaire >::value_type const &":
        return _openstudiomodelgeometry.LuminaireVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::Luminaire >::size_type', x: 'Luminaire') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::Luminaire >::size_type', x: 'Luminaire') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LuminaireVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::Luminaire >::size_type') -> "void":
        return _openstudiomodelgeometry.LuminaireVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::Luminaire >::size_type":
        return _openstudiomodelgeometry.LuminaireVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LuminaireVector
    __del__ = lambda self: None
LuminaireVector_swigregister = _openstudiomodelgeometry.LuminaireVector_swigregister
LuminaireVector_swigregister(LuminaireVector)

class OptionalLuminaire(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalLuminaire, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalLuminaire, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalLuminaire(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLuminaire_reset(self)

    def __ref__(self) -> "openstudio::model::Luminaire":
        return _openstudiomodelgeometry.OptionalLuminaire___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLuminaire_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLuminaire_isNull(self)

    def get(self) -> "openstudio::model::Luminaire":
        return _openstudiomodelgeometry.OptionalLuminaire_get(self)

    def set(self, t: 'Luminaire') -> "void":
        return _openstudiomodelgeometry.OptionalLuminaire_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLuminaire
    __del__ = lambda self: None
OptionalLuminaire_swigregister = _openstudiomodelgeometry.OptionalLuminaire_swigregister
OptionalLuminaire_swigregister(OptionalLuminaire)

class ElectricEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElectricEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElectricEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ElectricEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ElectricEquipment >::difference_type', j: 'std::vector< openstudio::model::ElectricEquipment >::difference_type') -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > > *":
        return _openstudiomodelgeometry.ElectricEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ElectricEquipment >::difference_type', j: 'std::vector< openstudio::model::ElectricEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector___setitem__(self, *args)

    def append(self, x: 'ElectricEquipment') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_clear(self)

    def swap(self, v: 'ElectricEquipmentVector') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ElectricEquipment >::allocator_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ElectricEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ElectricEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ElectricEquipment >::iterator":
        return _openstudiomodelgeometry.ElectricEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ElectricEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ElectricEquipment') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ElectricEquipment >::value_type const &":
        return _openstudiomodelgeometry.ElectricEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ElectricEquipment >::size_type', x: 'ElectricEquipment') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ElectricEquipment >::size_type', x: 'ElectricEquipment') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ElectricEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.ElectricEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ElectricEquipment >::size_type":
        return _openstudiomodelgeometry.ElectricEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipmentVector
    __del__ = lambda self: None
ElectricEquipmentVector_swigregister = _openstudiomodelgeometry.ElectricEquipmentVector_swigregister
ElectricEquipmentVector_swigregister(ElectricEquipmentVector)

class OptionalElectricEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalElectricEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalElectricEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalElectricEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ElectricEquipment":
        return _openstudiomodelgeometry.OptionalElectricEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalElectricEquipment_isNull(self)

    def get(self) -> "openstudio::model::ElectricEquipment":
        return _openstudiomodelgeometry.OptionalElectricEquipment_get(self)

    def set(self, t: 'ElectricEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalElectricEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalElectricEquipment
    __del__ = lambda self: None
OptionalElectricEquipment_swigregister = _openstudiomodelgeometry.OptionalElectricEquipment_swigregister
OptionalElectricEquipment_swigregister(OptionalElectricEquipment)

class GasEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GasEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GasEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.GasEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::GasEquipment >::value_type":
        return _openstudiomodelgeometry.GasEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::GasEquipment >::difference_type', j: 'std::vector< openstudio::model::GasEquipment >::difference_type') -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > > *":
        return _openstudiomodelgeometry.GasEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::GasEquipment >::difference_type', j: 'std::vector< openstudio::model::GasEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector___setitem__(self, *args)

    def append(self, x: 'GasEquipment') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_clear(self)

    def swap(self, v: 'GasEquipmentVector') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::GasEquipment >::allocator_type":
        return _openstudiomodelgeometry.GasEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::GasEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::GasEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::GasEquipment >::iterator":
        return _openstudiomodelgeometry.GasEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_GasEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'GasEquipment') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::GasEquipment >::value_type const &":
        return _openstudiomodelgeometry.GasEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::GasEquipment >::size_type', x: 'GasEquipment') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::GasEquipment >::size_type', x: 'GasEquipment') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::GasEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.GasEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::GasEquipment >::size_type":
        return _openstudiomodelgeometry.GasEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_GasEquipmentVector
    __del__ = lambda self: None
GasEquipmentVector_swigregister = _openstudiomodelgeometry.GasEquipmentVector_swigregister
GasEquipmentVector_swigregister(GasEquipmentVector)

class OptionalGasEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalGasEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalGasEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalGasEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalGasEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::GasEquipment":
        return _openstudiomodelgeometry.OptionalGasEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGasEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGasEquipment_isNull(self)

    def get(self) -> "openstudio::model::GasEquipment":
        return _openstudiomodelgeometry.OptionalGasEquipment_get(self)

    def set(self, t: 'GasEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalGasEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalGasEquipment
    __del__ = lambda self: None
OptionalGasEquipment_swigregister = _openstudiomodelgeometry.OptionalGasEquipment_swigregister
OptionalGasEquipment_swigregister(OptionalGasEquipment)

class HotWaterEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotWaterEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HotWaterEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::HotWaterEquipment >::difference_type', j: 'std::vector< openstudio::model::HotWaterEquipment >::difference_type') -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > > *":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::HotWaterEquipment >::difference_type', j: 'std::vector< openstudio::model::HotWaterEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector___setitem__(self, *args)

    def append(self, x: 'HotWaterEquipment') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_clear(self)

    def swap(self, v: 'HotWaterEquipmentVector') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::HotWaterEquipment >::allocator_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::HotWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::HotWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::HotWaterEquipment >::iterator":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_HotWaterEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'HotWaterEquipment') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::HotWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::HotWaterEquipment >::size_type', x: 'HotWaterEquipment') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::HotWaterEquipment >::size_type', x: 'HotWaterEquipment') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::HotWaterEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::HotWaterEquipment >::size_type":
        return _openstudiomodelgeometry.HotWaterEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_HotWaterEquipmentVector
    __del__ = lambda self: None
HotWaterEquipmentVector_swigregister = _openstudiomodelgeometry.HotWaterEquipmentVector_swigregister
HotWaterEquipmentVector_swigregister(HotWaterEquipmentVector)

class OptionalHotWaterEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalHotWaterEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalHotWaterEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalHotWaterEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::HotWaterEquipment":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_isNull(self)

    def get(self) -> "openstudio::model::HotWaterEquipment":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_get(self)

    def set(self, t: 'HotWaterEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalHotWaterEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalHotWaterEquipment
    __del__ = lambda self: None
OptionalHotWaterEquipment_swigregister = _openstudiomodelgeometry.OptionalHotWaterEquipment_swigregister
OptionalHotWaterEquipment_swigregister(OptionalHotWaterEquipment)

class SteamEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SteamEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SteamEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SteamEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SteamEquipment >::difference_type', j: 'std::vector< openstudio::model::SteamEquipment >::difference_type') -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > > *":
        return _openstudiomodelgeometry.SteamEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SteamEquipment >::difference_type', j: 'std::vector< openstudio::model::SteamEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector___setitem__(self, *args)

    def append(self, x: 'SteamEquipment') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_clear(self)

    def swap(self, v: 'SteamEquipmentVector') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SteamEquipment >::allocator_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SteamEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SteamEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SteamEquipment >::iterator":
        return _openstudiomodelgeometry.SteamEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SteamEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SteamEquipment') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SteamEquipment >::value_type const &":
        return _openstudiomodelgeometry.SteamEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SteamEquipment >::size_type', x: 'SteamEquipment') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SteamEquipment >::size_type', x: 'SteamEquipment') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SteamEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.SteamEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SteamEquipment >::size_type":
        return _openstudiomodelgeometry.SteamEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SteamEquipmentVector
    __del__ = lambda self: None
SteamEquipmentVector_swigregister = _openstudiomodelgeometry.SteamEquipmentVector_swigregister
SteamEquipmentVector_swigregister(SteamEquipmentVector)

class OptionalSteamEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSteamEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSteamEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSteamEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSteamEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::SteamEquipment":
        return _openstudiomodelgeometry.OptionalSteamEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSteamEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSteamEquipment_isNull(self)

    def get(self) -> "openstudio::model::SteamEquipment":
        return _openstudiomodelgeometry.OptionalSteamEquipment_get(self)

    def set(self, t: 'SteamEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalSteamEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSteamEquipment
    __del__ = lambda self: None
OptionalSteamEquipment_swigregister = _openstudiomodelgeometry.OptionalSteamEquipment_swigregister
OptionalSteamEquipment_swigregister(OptionalSteamEquipment)

class OtherEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OtherEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OtherEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.OtherEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::OtherEquipment >::difference_type', j: 'std::vector< openstudio::model::OtherEquipment >::difference_type') -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > > *":
        return _openstudiomodelgeometry.OtherEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::OtherEquipment >::difference_type', j: 'std::vector< openstudio::model::OtherEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector___setitem__(self, *args)

    def append(self, x: 'OtherEquipment') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_clear(self)

    def swap(self, v: 'OtherEquipmentVector') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::OtherEquipment >::allocator_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::OtherEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::OtherEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::OtherEquipment >::iterator":
        return _openstudiomodelgeometry.OtherEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OtherEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'OtherEquipment') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::OtherEquipment >::value_type const &":
        return _openstudiomodelgeometry.OtherEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::OtherEquipment >::size_type', x: 'OtherEquipment') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::OtherEquipment >::size_type', x: 'OtherEquipment') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::OtherEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.OtherEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::OtherEquipment >::size_type":
        return _openstudiomodelgeometry.OtherEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OtherEquipmentVector
    __del__ = lambda self: None
OtherEquipmentVector_swigregister = _openstudiomodelgeometry.OtherEquipmentVector_swigregister
OtherEquipmentVector_swigregister(OtherEquipmentVector)

class OptionalOtherEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalOtherEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalOtherEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalOtherEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalOtherEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::OtherEquipment":
        return _openstudiomodelgeometry.OptionalOtherEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalOtherEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalOtherEquipment_isNull(self)

    def get(self) -> "openstudio::model::OtherEquipment":
        return _openstudiomodelgeometry.OptionalOtherEquipment_get(self)

    def set(self, t: 'OtherEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalOtherEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalOtherEquipment
    __del__ = lambda self: None
OptionalOtherEquipment_swigregister = _openstudiomodelgeometry.OptionalOtherEquipment_swigregister
OptionalOtherEquipment_swigregister(OptionalOtherEquipment)

class InternalMassVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InternalMassVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InternalMassVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.InternalMassVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::InternalMass >::value_type":
        return _openstudiomodelgeometry.InternalMassVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::InternalMass >::difference_type', j: 'std::vector< openstudio::model::InternalMass >::difference_type') -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > > *":
        return _openstudiomodelgeometry.InternalMassVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::InternalMass >::difference_type', j: 'std::vector< openstudio::model::InternalMass >::difference_type') -> "void":
        return _openstudiomodelgeometry.InternalMassVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector___setitem__(self, *args)

    def append(self, x: 'InternalMass') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.InternalMassVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_clear(self)

    def swap(self, v: 'InternalMassVector') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::InternalMass >::allocator_type":
        return _openstudiomodelgeometry.InternalMassVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::InternalMass >::reverse_iterator":
        return _openstudiomodelgeometry.InternalMassVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::InternalMass >::reverse_iterator":
        return _openstudiomodelgeometry.InternalMassVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::InternalMass >::iterator":
        return _openstudiomodelgeometry.InternalMassVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_InternalMassVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'InternalMass') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector_front(self)

    def back(self) -> "std::vector< openstudio::model::InternalMass >::value_type const &":
        return _openstudiomodelgeometry.InternalMassVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::InternalMass >::size_type', x: 'InternalMass') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::InternalMass >::size_type', x: 'InternalMass') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.InternalMassVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::InternalMass >::size_type') -> "void":
        return _openstudiomodelgeometry.InternalMassVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::InternalMass >::size_type":
        return _openstudiomodelgeometry.InternalMassVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_InternalMassVector
    __del__ = lambda self: None
InternalMassVector_swigregister = _openstudiomodelgeometry.InternalMassVector_swigregister
InternalMassVector_swigregister(InternalMassVector)

class OptionalInternalMass(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalInternalMass, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalInternalMass, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalInternalMass(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalInternalMass_reset(self)

    def __ref__(self) -> "openstudio::model::InternalMass":
        return _openstudiomodelgeometry.OptionalInternalMass___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInternalMass_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalInternalMass_isNull(self)

    def get(self) -> "openstudio::model::InternalMass":
        return _openstudiomodelgeometry.OptionalInternalMass_get(self)

    def set(self, t: 'InternalMass') -> "void":
        return _openstudiomodelgeometry.OptionalInternalMass_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalInternalMass
    __del__ = lambda self: None
OptionalInternalMass_swigregister = _openstudiomodelgeometry.OptionalInternalMass_swigregister
OptionalInternalMass_swigregister(OptionalInternalMass)

class SpaceInfiltrationDesignFlowRateVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceInfiltrationDesignFlowRateVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceInfiltrationDesignFlowRateVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type', j: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type') -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > > *":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type', j: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector___setitem__(self, *args)

    def append(self, x: 'SpaceInfiltrationDesignFlowRate') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_clear(self)

    def swap(self, v: 'SpaceInfiltrationDesignFlowRateVector') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::allocator_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceInfiltrationDesignFlowRateVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceInfiltrationDesignFlowRate') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type', x: 'SpaceInfiltrationDesignFlowRate') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type', x: 'SpaceInfiltrationDesignFlowRate') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationDesignFlowRateVector
    __del__ = lambda self: None
SpaceInfiltrationDesignFlowRateVector_swigregister = _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRateVector_swigregister
SpaceInfiltrationDesignFlowRateVector_swigregister(SpaceInfiltrationDesignFlowRateVector)

class OptionalSpaceInfiltrationDesignFlowRate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceInfiltrationDesignFlowRate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceInfiltrationDesignFlowRate, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceInfiltrationDesignFlowRate(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceInfiltrationDesignFlowRate":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_isNull(self)

    def get(self) -> "openstudio::model::SpaceInfiltrationDesignFlowRate":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_get(self)

    def set(self, t: 'SpaceInfiltrationDesignFlowRate') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceInfiltrationDesignFlowRate
    __del__ = lambda self: None
OptionalSpaceInfiltrationDesignFlowRate_swigregister = _openstudiomodelgeometry.OptionalSpaceInfiltrationDesignFlowRate_swigregister
OptionalSpaceInfiltrationDesignFlowRate_swigregister(OptionalSpaceInfiltrationDesignFlowRate)

class SpaceInfiltrationEffectiveLeakageAreaVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceInfiltrationEffectiveLeakageAreaVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceInfiltrationEffectiveLeakageAreaVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type', j: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type') -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > > *":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type', j: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector___setitem__(self, *args)

    def append(self, x: 'SpaceInfiltrationEffectiveLeakageArea') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_clear(self)

    def swap(self, v: 'SpaceInfiltrationEffectiveLeakageAreaVector') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::allocator_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::iterator":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceInfiltrationEffectiveLeakageAreaVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceInfiltrationEffectiveLeakageArea') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::value_type const &":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type', x: 'SpaceInfiltrationEffectiveLeakageArea') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type', x: 'SpaceInfiltrationEffectiveLeakageArea') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >::size_type":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationEffectiveLeakageAreaVector
    __del__ = lambda self: None
SpaceInfiltrationEffectiveLeakageAreaVector_swigregister = _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageAreaVector_swigregister
SpaceInfiltrationEffectiveLeakageAreaVector_swigregister(SpaceInfiltrationEffectiveLeakageAreaVector)

class OptionalSpaceInfiltrationEffectiveLeakageArea(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceInfiltrationEffectiveLeakageArea, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceInfiltrationEffectiveLeakageArea, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceInfiltrationEffectiveLeakageArea(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceInfiltrationEffectiveLeakageArea":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_isNull(self)

    def get(self) -> "openstudio::model::SpaceInfiltrationEffectiveLeakageArea":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_get(self)

    def set(self, t: 'SpaceInfiltrationEffectiveLeakageArea') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceInfiltrationEffectiveLeakageArea
    __del__ = lambda self: None
OptionalSpaceInfiltrationEffectiveLeakageArea_swigregister = _openstudiomodelgeometry.OptionalSpaceInfiltrationEffectiveLeakageArea_swigregister
OptionalSpaceInfiltrationEffectiveLeakageArea_swigregister(OptionalSpaceInfiltrationEffectiveLeakageArea)

class DaylightingControlVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaylightingControlVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DaylightingControlVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DaylightingControlVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type":
        return _openstudiomodelgeometry.DaylightingControlVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::DaylightingControl >::difference_type', j: 'std::vector< openstudio::model::DaylightingControl >::difference_type') -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > > *":
        return _openstudiomodelgeometry.DaylightingControlVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::DaylightingControl >::difference_type', j: 'std::vector< openstudio::model::DaylightingControl >::difference_type') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector___setitem__(self, *args)

    def append(self, x: 'DaylightingControl') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControlVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_clear(self)

    def swap(self, v: 'DaylightingControlVector') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::DaylightingControl >::allocator_type":
        return _openstudiomodelgeometry.DaylightingControlVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DaylightingControl >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DaylightingControl >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DaylightingControl >::iterator":
        return _openstudiomodelgeometry.DaylightingControlVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_DaylightingControlVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'DaylightingControl') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DaylightingControl >::value_type const &":
        return _openstudiomodelgeometry.DaylightingControlVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::DaylightingControl >::size_type', x: 'DaylightingControl') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::DaylightingControl >::size_type', x: 'DaylightingControl') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::DaylightingControl >::size_type') -> "void":
        return _openstudiomodelgeometry.DaylightingControlVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DaylightingControl >::size_type":
        return _openstudiomodelgeometry.DaylightingControlVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingControlVector
    __del__ = lambda self: None
DaylightingControlVector_swigregister = _openstudiomodelgeometry.DaylightingControlVector_swigregister
DaylightingControlVector_swigregister(DaylightingControlVector)

class OptionalDaylightingControl(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDaylightingControl, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDaylightingControl, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalDaylightingControl(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingControl_reset(self)

    def __ref__(self) -> "openstudio::model::DaylightingControl":
        return _openstudiomodelgeometry.OptionalDaylightingControl___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingControl_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingControl_isNull(self)

    def get(self) -> "openstudio::model::DaylightingControl":
        return _openstudiomodelgeometry.OptionalDaylightingControl_get(self)

    def set(self, t: 'DaylightingControl') -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingControl_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDaylightingControl
    __del__ = lambda self: None
OptionalDaylightingControl_swigregister = _openstudiomodelgeometry.OptionalDaylightingControl_swigregister
OptionalDaylightingControl_swigregister(OptionalDaylightingControl)

class GlareSensorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GlareSensorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GlareSensorVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.GlareSensorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::GlareSensor >::value_type":
        return _openstudiomodelgeometry.GlareSensorVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::GlareSensor >::difference_type', j: 'std::vector< openstudio::model::GlareSensor >::difference_type') -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > > *":
        return _openstudiomodelgeometry.GlareSensorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::GlareSensor >::difference_type', j: 'std::vector< openstudio::model::GlareSensor >::difference_type') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector___setitem__(self, *args)

    def append(self, x: 'GlareSensor') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensorVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_clear(self)

    def swap(self, v: 'GlareSensorVector') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::GlareSensor >::allocator_type":
        return _openstudiomodelgeometry.GlareSensorVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::GlareSensor >::reverse_iterator":
        return _openstudiomodelgeometry.GlareSensorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::GlareSensor >::reverse_iterator":
        return _openstudiomodelgeometry.GlareSensorVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::GlareSensor >::iterator":
        return _openstudiomodelgeometry.GlareSensorVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_GlareSensorVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'GlareSensor') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector_front(self)

    def back(self) -> "std::vector< openstudio::model::GlareSensor >::value_type const &":
        return _openstudiomodelgeometry.GlareSensorVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::GlareSensor >::size_type', x: 'GlareSensor') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::GlareSensor >::size_type', x: 'GlareSensor') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::GlareSensor >::size_type') -> "void":
        return _openstudiomodelgeometry.GlareSensorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::GlareSensor >::size_type":
        return _openstudiomodelgeometry.GlareSensorVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_GlareSensorVector
    __del__ = lambda self: None
GlareSensorVector_swigregister = _openstudiomodelgeometry.GlareSensorVector_swigregister
GlareSensorVector_swigregister(GlareSensorVector)

class OptionalGlareSensor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalGlareSensor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalGlareSensor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalGlareSensor(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalGlareSensor_reset(self)

    def __ref__(self) -> "openstudio::model::GlareSensor":
        return _openstudiomodelgeometry.OptionalGlareSensor___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGlareSensor_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalGlareSensor_isNull(self)

    def get(self) -> "openstudio::model::GlareSensor":
        return _openstudiomodelgeometry.OptionalGlareSensor_get(self)

    def set(self, t: 'GlareSensor') -> "void":
        return _openstudiomodelgeometry.OptionalGlareSensor_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalGlareSensor
    __del__ = lambda self: None
OptionalGlareSensor_swigregister = _openstudiomodelgeometry.OptionalGlareSensor_swigregister
OptionalGlareSensor_swigregister(OptionalGlareSensor)

class IlluminanceMapVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IlluminanceMapVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IlluminanceMapVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.IlluminanceMapVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::IlluminanceMap >::difference_type', j: 'std::vector< openstudio::model::IlluminanceMap >::difference_type') -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > > *":
        return _openstudiomodelgeometry.IlluminanceMapVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::IlluminanceMap >::difference_type', j: 'std::vector< openstudio::model::IlluminanceMap >::difference_type') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector___setitem__(self, *args)

    def append(self, x: 'IlluminanceMap') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMapVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_clear(self)

    def swap(self, v: 'IlluminanceMapVector') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::IlluminanceMap >::allocator_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::IlluminanceMap >::reverse_iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::IlluminanceMap >::reverse_iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::IlluminanceMap >::iterator":
        return _openstudiomodelgeometry.IlluminanceMapVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_IlluminanceMapVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'IlluminanceMap') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector_front(self)

    def back(self) -> "std::vector< openstudio::model::IlluminanceMap >::value_type const &":
        return _openstudiomodelgeometry.IlluminanceMapVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::IlluminanceMap >::size_type', x: 'IlluminanceMap') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::IlluminanceMap >::size_type', x: 'IlluminanceMap') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::IlluminanceMap >::size_type') -> "void":
        return _openstudiomodelgeometry.IlluminanceMapVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::IlluminanceMap >::size_type":
        return _openstudiomodelgeometry.IlluminanceMapVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_IlluminanceMapVector
    __del__ = lambda self: None
IlluminanceMapVector_swigregister = _openstudiomodelgeometry.IlluminanceMapVector_swigregister
IlluminanceMapVector_swigregister(IlluminanceMapVector)

class OptionalIlluminanceMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalIlluminanceMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalIlluminanceMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalIlluminanceMap(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_reset(self)

    def __ref__(self) -> "openstudio::model::IlluminanceMap":
        return _openstudiomodelgeometry.OptionalIlluminanceMap___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_isNull(self)

    def get(self) -> "openstudio::model::IlluminanceMap":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_get(self)

    def set(self, t: 'IlluminanceMap') -> "void":
        return _openstudiomodelgeometry.OptionalIlluminanceMap_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalIlluminanceMap
    __del__ = lambda self: None
OptionalIlluminanceMap_swigregister = _openstudiomodelgeometry.OptionalIlluminanceMap_swigregister
OptionalIlluminanceMap_swigregister(OptionalIlluminanceMap)

class DaylightingDeviceShelfVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaylightingDeviceShelfVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DaylightingDeviceShelfVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type', j: 'std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type') -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > > *":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type', j: 'std::vector< openstudio::model::DaylightingDeviceShelf >::difference_type') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector___setitem__(self, *args)

    def append(self, x: 'DaylightingDeviceShelf') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_clear(self)

    def swap(self, v: 'DaylightingDeviceShelfVector') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::allocator_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::reverse_iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::iterator":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_DaylightingDeviceShelfVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'DaylightingDeviceShelf') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_front(self)

    def back(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::value_type const &":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::DaylightingDeviceShelf >::size_type', x: 'DaylightingDeviceShelf') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::DaylightingDeviceShelf >::size_type', x: 'DaylightingDeviceShelf') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::DaylightingDeviceShelf >::size_type') -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::DaylightingDeviceShelf >::size_type":
        return _openstudiomodelgeometry.DaylightingDeviceShelfVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingDeviceShelfVector
    __del__ = lambda self: None
DaylightingDeviceShelfVector_swigregister = _openstudiomodelgeometry.DaylightingDeviceShelfVector_swigregister
DaylightingDeviceShelfVector_swigregister(DaylightingDeviceShelfVector)

class OptionalDaylightingDeviceShelf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDaylightingDeviceShelf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDaylightingDeviceShelf, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalDaylightingDeviceShelf(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_reset(self)

    def __ref__(self) -> "openstudio::model::DaylightingDeviceShelf":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_isNull(self)

    def get(self) -> "openstudio::model::DaylightingDeviceShelf":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_get(self)

    def set(self, t: 'DaylightingDeviceShelf') -> "void":
        return _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalDaylightingDeviceShelf
    __del__ = lambda self: None
OptionalDaylightingDeviceShelf_swigregister = _openstudiomodelgeometry.OptionalDaylightingDeviceShelf_swigregister
OptionalDaylightingDeviceShelf_swigregister(OptionalDaylightingDeviceShelf)

class SpaceTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SpaceTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SpaceType >::value_type":
        return _openstudiomodelgeometry.SpaceTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SpaceType >::difference_type', j: 'std::vector< openstudio::model::SpaceType >::difference_type') -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > > *":
        return _openstudiomodelgeometry.SpaceTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SpaceType >::difference_type', j: 'std::vector< openstudio::model::SpaceType >::difference_type') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector___setitem__(self, *args)

    def append(self, x: 'SpaceType') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SpaceTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_clear(self)

    def swap(self, v: 'SpaceTypeVector') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SpaceType >::allocator_type":
        return _openstudiomodelgeometry.SpaceTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SpaceType >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SpaceType >::reverse_iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SpaceType >::iterator":
        return _openstudiomodelgeometry.SpaceTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SpaceTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SpaceType') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SpaceType >::value_type const &":
        return _openstudiomodelgeometry.SpaceTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SpaceType >::size_type', x: 'SpaceType') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SpaceType >::size_type', x: 'SpaceType') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SpaceType >::size_type') -> "void":
        return _openstudiomodelgeometry.SpaceTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SpaceType >::size_type":
        return _openstudiomodelgeometry.SpaceTypeVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceTypeVector
    __del__ = lambda self: None
SpaceTypeVector_swigregister = _openstudiomodelgeometry.SpaceTypeVector_swigregister
SpaceTypeVector_swigregister(SpaceTypeVector)

class OptionalSpaceType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSpaceType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSpaceType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSpaceType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSpaceType_reset(self)

    def __ref__(self) -> "openstudio::model::SpaceType":
        return _openstudiomodelgeometry.OptionalSpaceType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSpaceType_isNull(self)

    def get(self) -> "openstudio::model::SpaceType":
        return _openstudiomodelgeometry.OptionalSpaceType_get(self)

    def set(self, t: 'SpaceType') -> "void":
        return _openstudiomodelgeometry.OptionalSpaceType_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSpaceType
    __del__ = lambda self: None
OptionalSpaceType_swigregister = _openstudiomodelgeometry.OptionalSpaceType_swigregister
OptionalSpaceType_swigregister(OptionalSpaceType)

class LightingSimulationZoneVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LightingSimulationZoneVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LightingSimulationZoneVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::LightingSimulationZone >::difference_type', j: 'std::vector< openstudio::model::LightingSimulationZone >::difference_type') -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > > *":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::LightingSimulationZone >::difference_type', j: 'std::vector< openstudio::model::LightingSimulationZone >::difference_type') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector___setitem__(self, *args)

    def append(self, x: 'LightingSimulationZone') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_clear(self)

    def swap(self, v: 'LightingSimulationZoneVector') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::LightingSimulationZone >::allocator_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::LightingSimulationZone >::reverse_iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::LightingSimulationZone >::reverse_iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::LightingSimulationZone >::iterator":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_LightingSimulationZoneVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'LightingSimulationZone') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_front(self)

    def back(self) -> "std::vector< openstudio::model::LightingSimulationZone >::value_type const &":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::LightingSimulationZone >::size_type', x: 'LightingSimulationZone') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::LightingSimulationZone >::size_type', x: 'LightingSimulationZone') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::LightingSimulationZone >::size_type') -> "void":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::LightingSimulationZone >::size_type":
        return _openstudiomodelgeometry.LightingSimulationZoneVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightingSimulationZoneVector
    __del__ = lambda self: None
LightingSimulationZoneVector_swigregister = _openstudiomodelgeometry.LightingSimulationZoneVector_swigregister
LightingSimulationZoneVector_swigregister(LightingSimulationZoneVector)

class OptionalLightingSimulationZone(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalLightingSimulationZone, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalLightingSimulationZone, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalLightingSimulationZone(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_reset(self)

    def __ref__(self) -> "openstudio::model::LightingSimulationZone":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_isNull(self)

    def get(self) -> "openstudio::model::LightingSimulationZone":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_get(self)

    def set(self, t: 'LightingSimulationZone') -> "void":
        return _openstudiomodelgeometry.OptionalLightingSimulationZone_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalLightingSimulationZone
    __del__ = lambda self: None
OptionalLightingSimulationZone_swigregister = _openstudiomodelgeometry.OptionalLightingSimulationZone_swigregister
OptionalLightingSimulationZone_swigregister(OptionalLightingSimulationZone)

class FoundationKivaVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FoundationKivaVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FoundationKivaVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.FoundationKivaVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type":
        return _openstudiomodelgeometry.FoundationKivaVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::FoundationKiva >::difference_type', j: 'std::vector< openstudio::model::FoundationKiva >::difference_type') -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > > *":
        return _openstudiomodelgeometry.FoundationKivaVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::FoundationKiva >::difference_type', j: 'std::vector< openstudio::model::FoundationKiva >::difference_type') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector___setitem__(self, *args)

    def append(self, x: 'FoundationKiva') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKivaVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_clear(self)

    def swap(self, v: 'FoundationKivaVector') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::FoundationKiva >::allocator_type":
        return _openstudiomodelgeometry.FoundationKivaVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::FoundationKiva >::reverse_iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::FoundationKiva >::reverse_iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::FoundationKiva >::iterator":
        return _openstudiomodelgeometry.FoundationKivaVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_FoundationKivaVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'FoundationKiva') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector_front(self)

    def back(self) -> "std::vector< openstudio::model::FoundationKiva >::value_type const &":
        return _openstudiomodelgeometry.FoundationKivaVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::FoundationKiva >::size_type', x: 'FoundationKiva') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::FoundationKiva >::size_type', x: 'FoundationKiva') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::FoundationKiva >::size_type') -> "void":
        return _openstudiomodelgeometry.FoundationKivaVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::FoundationKiva >::size_type":
        return _openstudiomodelgeometry.FoundationKivaVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_FoundationKivaVector
    __del__ = lambda self: None
FoundationKivaVector_swigregister = _openstudiomodelgeometry.FoundationKivaVector_swigregister
FoundationKivaVector_swigregister(FoundationKivaVector)

class OptionalFoundationKiva(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalFoundationKiva, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalFoundationKiva, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalFoundationKiva(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalFoundationKiva_reset(self)

    def __ref__(self) -> "openstudio::model::FoundationKiva":
        return _openstudiomodelgeometry.OptionalFoundationKiva___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFoundationKiva_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalFoundationKiva_isNull(self)

    def get(self) -> "openstudio::model::FoundationKiva":
        return _openstudiomodelgeometry.OptionalFoundationKiva_get(self)

    def set(self, t: 'FoundationKiva') -> "void":
        return _openstudiomodelgeometry.OptionalFoundationKiva_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalFoundationKiva
    __del__ = lambda self: None
OptionalFoundationKiva_swigregister = _openstudiomodelgeometry.OptionalFoundationKiva_swigregister
OptionalFoundationKiva_swigregister(OptionalFoundationKiva)

class SurfacePropertyExposedFoundationPerimeterVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyExposedFoundationPerimeterVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyExposedFoundationPerimeterVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type') -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > > *":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type', j: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::difference_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector___setitem__(self, *args)

    def append(self, x: 'SurfacePropertyExposedFoundationPerimeter') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_clear(self)

    def swap(self, v: 'SurfacePropertyExposedFoundationPerimeterVector') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::allocator_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::reverse_iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::iterator":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfacePropertyExposedFoundationPerimeterVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'SurfacePropertyExposedFoundationPerimeter') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_front(self)

    def back(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::value_type const &":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type', x: 'SurfacePropertyExposedFoundationPerimeter') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type', x: 'SurfacePropertyExposedFoundationPerimeter') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type') -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter >::size_type":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyExposedFoundationPerimeterVector
    __del__ = lambda self: None
SurfacePropertyExposedFoundationPerimeterVector_swigregister = _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeterVector_swigregister
SurfacePropertyExposedFoundationPerimeterVector_swigregister(SurfacePropertyExposedFoundationPerimeterVector)

class OptionalSurfacePropertyExposedFoundationPerimeter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalSurfacePropertyExposedFoundationPerimeter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalSurfacePropertyExposedFoundationPerimeter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalSurfacePropertyExposedFoundationPerimeter(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_reset(self)

    def __ref__(self) -> "openstudio::model::SurfacePropertyExposedFoundationPerimeter":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_isNull(self)

    def get(self) -> "openstudio::model::SurfacePropertyExposedFoundationPerimeter":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_get(self)

    def set(self, t: 'SurfacePropertyExposedFoundationPerimeter') -> "void":
        return _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalSurfacePropertyExposedFoundationPerimeter
    __del__ = lambda self: None
OptionalSurfacePropertyExposedFoundationPerimeter_swigregister = _openstudiomodelgeometry.OptionalSurfacePropertyExposedFoundationPerimeter_swigregister
OptionalSurfacePropertyExposedFoundationPerimeter_swigregister(OptionalSurfacePropertyExposedFoundationPerimeter)

class ExteriorLoadInstanceVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorLoadInstanceVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorLoadInstanceVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ExteriorLoadInstance >::difference_type', j: 'std::vector< openstudio::model::ExteriorLoadInstance >::difference_type') -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > > *":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ExteriorLoadInstance >::difference_type', j: 'std::vector< openstudio::model::ExteriorLoadInstance >::difference_type') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector___setitem__(self, *args)

    def append(self, x: 'ExteriorLoadInstance') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_clear(self)

    def swap(self, v: 'ExteriorLoadInstanceVector') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::allocator_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorLoadInstance >::iterator":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorLoadInstanceVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ExteriorLoadInstance') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ExteriorLoadInstance >::size_type', x: 'ExteriorLoadInstance') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ExteriorLoadInstance >::size_type', x: 'ExteriorLoadInstance') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ExteriorLoadInstance >::size_type') -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorLoadInstance >::size_type":
        return _openstudiomodelgeometry.ExteriorLoadInstanceVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLoadInstanceVector
    __del__ = lambda self: None
ExteriorLoadInstanceVector_swigregister = _openstudiomodelgeometry.ExteriorLoadInstanceVector_swigregister
ExteriorLoadInstanceVector_swigregister(ExteriorLoadInstanceVector)

class OptionalExteriorLoadInstance(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalExteriorLoadInstance, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalExteriorLoadInstance, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalExteriorLoadInstance(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorLoadInstance":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_isNull(self)

    def get(self) -> "openstudio::model::ExteriorLoadInstance":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_get(self)

    def set(self, t: 'ExteriorLoadInstance') -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLoadInstance_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorLoadInstance
    __del__ = lambda self: None
OptionalExteriorLoadInstance_swigregister = _openstudiomodelgeometry.OptionalExteriorLoadInstance_swigregister
OptionalExteriorLoadInstance_swigregister(OptionalExteriorLoadInstance)

class ExteriorLightsVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorLightsVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorLightsVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorLightsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ExteriorLights >::difference_type', j: 'std::vector< openstudio::model::ExteriorLights >::difference_type') -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > > *":
        return _openstudiomodelgeometry.ExteriorLightsVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ExteriorLights >::difference_type', j: 'std::vector< openstudio::model::ExteriorLights >::difference_type') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector___setitem__(self, *args)

    def append(self, x: 'ExteriorLights') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLightsVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_clear(self)

    def swap(self, v: 'ExteriorLightsVector') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorLights >::allocator_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorLights >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorLights >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorLights >::iterator":
        return _openstudiomodelgeometry.ExteriorLightsVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorLightsVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ExteriorLights') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorLights >::value_type const &":
        return _openstudiomodelgeometry.ExteriorLightsVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ExteriorLights >::size_type', x: 'ExteriorLights') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ExteriorLights >::size_type', x: 'ExteriorLights') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ExteriorLights >::size_type') -> "void":
        return _openstudiomodelgeometry.ExteriorLightsVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorLights >::size_type":
        return _openstudiomodelgeometry.ExteriorLightsVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLightsVector
    __del__ = lambda self: None
ExteriorLightsVector_swigregister = _openstudiomodelgeometry.ExteriorLightsVector_swigregister
ExteriorLightsVector_swigregister(ExteriorLightsVector)

class OptionalExteriorLights(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalExteriorLights, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalExteriorLights, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalExteriorLights(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLights_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorLights":
        return _openstudiomodelgeometry.OptionalExteriorLights___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLights_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorLights_isNull(self)

    def get(self) -> "openstudio::model::ExteriorLights":
        return _openstudiomodelgeometry.OptionalExteriorLights_get(self)

    def set(self, t: 'ExteriorLights') -> "void":
        return _openstudiomodelgeometry.OptionalExteriorLights_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorLights
    __del__ = lambda self: None
OptionalExteriorLights_swigregister = _openstudiomodelgeometry.OptionalExteriorLights_swigregister
OptionalExteriorLights_swigregister(OptionalExteriorLights)

class ExteriorFuelEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorFuelEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorFuelEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type', j: 'std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type') -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > > *":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type', j: 'std::vector< openstudio::model::ExteriorFuelEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector___setitem__(self, *args)

    def append(self, x: 'ExteriorFuelEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_clear(self)

    def swap(self, v: 'ExteriorFuelEquipmentVector') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::allocator_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorFuelEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ExteriorFuelEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ExteriorFuelEquipment >::size_type', x: 'ExteriorFuelEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ExteriorFuelEquipment >::size_type', x: 'ExteriorFuelEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ExteriorFuelEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorFuelEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorFuelEquipmentVector
    __del__ = lambda self: None
ExteriorFuelEquipmentVector_swigregister = _openstudiomodelgeometry.ExteriorFuelEquipmentVector_swigregister
ExteriorFuelEquipmentVector_swigregister(ExteriorFuelEquipmentVector)

class OptionalExteriorFuelEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalExteriorFuelEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalExteriorFuelEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalExteriorFuelEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorFuelEquipment":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_isNull(self)

    def get(self) -> "openstudio::model::ExteriorFuelEquipment":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_get(self)

    def set(self, t: 'ExteriorFuelEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalExteriorFuelEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorFuelEquipment
    __del__ = lambda self: None
OptionalExteriorFuelEquipment_swigregister = _openstudiomodelgeometry.OptionalExteriorFuelEquipment_swigregister
OptionalExteriorFuelEquipment_swigregister(OptionalExteriorFuelEquipment)

class ExteriorWaterEquipmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorWaterEquipmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorWaterEquipmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type', j: 'std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type') -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > > *":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type', j: 'std::vector< openstudio::model::ExteriorWaterEquipment >::difference_type') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector___setitem__(self, *args)

    def append(self, x: 'ExteriorWaterEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_clear(self)

    def swap(self, v: 'ExteriorWaterEquipmentVector') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::allocator_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::reverse_iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::iterator":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorWaterEquipmentVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'ExteriorWaterEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_front(self)

    def back(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::value_type const &":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::ExteriorWaterEquipment >::size_type', x: 'ExteriorWaterEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::ExteriorWaterEquipment >::size_type', x: 'ExteriorWaterEquipment') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::ExteriorWaterEquipment >::size_type') -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment >::size_type":
        return _openstudiomodelgeometry.ExteriorWaterEquipmentVector_capacity(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorWaterEquipmentVector
    __del__ = lambda self: None
ExteriorWaterEquipmentVector_swigregister = _openstudiomodelgeometry.ExteriorWaterEquipmentVector_swigregister
ExteriorWaterEquipmentVector_swigregister(ExteriorWaterEquipmentVector)

class OptionalExteriorWaterEquipment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalExteriorWaterEquipment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalExteriorWaterEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_OptionalExteriorWaterEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_reset(self)

    def __ref__(self) -> "openstudio::model::ExteriorWaterEquipment":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_isNull(self)

    def get(self) -> "openstudio::model::ExteriorWaterEquipment":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_get(self)

    def set(self, t: 'ExteriorWaterEquipment') -> "void":
        return _openstudiomodelgeometry.OptionalExteriorWaterEquipment_set(self, t)
    __swig_destroy__ = _openstudiomodelgeometry.delete_OptionalExteriorWaterEquipment
    __del__ = lambda self: None
OptionalExteriorWaterEquipment_swigregister = _openstudiomodelgeometry.OptionalExteriorWaterEquipment_swigregister
OptionalExteriorWaterEquipment_swigregister(OptionalExteriorWaterEquipment)

class Site(openstudiomodelcore.ParentObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Site, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Site, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Site
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Site_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Site_iddObjectType)
    __swig_getmethods__["validTerrainValues"] = lambda x: _openstudiomodelgeometry.Site_validTerrainValues
    if _newclass:
        validTerrainValues = staticmethod(_openstudiomodelgeometry.Site_validTerrainValues)

    def latitude(self) -> "double":
        return _openstudiomodelgeometry.Site_latitude(self)

    def isLatitudeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isLatitudeDefaulted(self)

    def longitude(self) -> "double":
        return _openstudiomodelgeometry.Site_longitude(self)

    def isLongitudeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isLongitudeDefaulted(self)

    def timeZone(self) -> "double":
        return _openstudiomodelgeometry.Site_timeZone(self)

    def isTimeZoneDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isTimeZoneDefaulted(self)

    def elevation(self) -> "double":
        return _openstudiomodelgeometry.Site_elevation(self)

    def isElevationDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isElevationDefaulted(self)

    def terrain(self) -> "std::string":
        return _openstudiomodelgeometry.Site_terrain(self)

    def isTerrainDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Site_isTerrainDefaulted(self)

    def setLatitude(self, latitude: 'double') -> "bool":
        return _openstudiomodelgeometry.Site_setLatitude(self, latitude)

    def resetLatitude(self) -> "void":
        return _openstudiomodelgeometry.Site_resetLatitude(self)

    def setLongitude(self, longitude: 'double') -> "bool":
        return _openstudiomodelgeometry.Site_setLongitude(self, longitude)

    def resetLongitude(self) -> "void":
        return _openstudiomodelgeometry.Site_resetLongitude(self)

    def setTimeZone(self, timeZone: 'double') -> "bool":
        return _openstudiomodelgeometry.Site_setTimeZone(self, timeZone)

    def resetTimeZone(self) -> "void":
        return _openstudiomodelgeometry.Site_resetTimeZone(self)

    def setElevation(self, elevation: 'double') -> "bool":
        return _openstudiomodelgeometry.Site_setElevation(self, elevation)

    def resetElevation(self) -> "void":
        return _openstudiomodelgeometry.Site_resetElevation(self)

    def setTerrain(self, terrain: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Site_setTerrain(self, terrain)

    def resetTerrain(self) -> "void":
        return _openstudiomodelgeometry.Site_resetTerrain(self)

    def weatherFile(self) -> "boost::optional< openstudio::model::WeatherFile >":
        return _openstudiomodelgeometry.Site_weatherFile(self)

    def siteGroundReflectance(self) -> "boost::optional< openstudio::model::SiteGroundReflectance >":
        return _openstudiomodelgeometry.Site_siteGroundReflectance(self)

    def siteGroundTemperatureBuildingSurface(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureBuildingSurface >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureBuildingSurface(self)

    def siteGroundTemperatureDeep(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureDeep >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureDeep(self)

    def siteGroundTemperatureShallow(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureShallow >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureShallow(self)

    def siteGroundTemperatureFCfactorMethod(self) -> "boost::optional< openstudio::model::SiteGroundTemperatureFCfactorMethod >":
        return _openstudiomodelgeometry.Site_siteGroundTemperatureFCfactorMethod(self)

    def siteWaterMainsTemperature(self) -> "boost::optional< openstudio::model::SiteWaterMainsTemperature >":
        return _openstudiomodelgeometry.Site_siteWaterMainsTemperature(self)

    def climateZones(self) -> "boost::optional< openstudio::model::ClimateZones >":
        return _openstudiomodelgeometry.Site_climateZones(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Site_shadingSurfaceGroups(self)
Site_swigregister = _openstudiomodelgeometry.Site_swigregister
Site_swigregister(Site)

def Site_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Site_iddObjectType()
Site_iddObjectType = _openstudiomodelgeometry.Site_iddObjectType

def Site_validTerrainValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Site_validTerrainValues()
Site_validTerrainValues = _openstudiomodelgeometry.Site_validTerrainValues


def toSite(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Site >":
    return _openstudiomodelgeometry.toSite(idfObject)
toSite = _openstudiomodelgeometry.toSite

def getSite(t_model: 'Model') -> "openstudio::model::Site":
    return _openstudiomodelgeometry.getSite(t_model)
getSite = _openstudiomodelgeometry.getSite

def getOptionalSite(t_model: 'Model') -> "boost::optional< openstudio::model::Site >":
    return _openstudiomodelgeometry.getOptionalSite(t_model)
getOptionalSite = _openstudiomodelgeometry.getOptionalSite
class Facility(openstudiomodelcore.ParentObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Facility, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Facility, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Facility
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Facility_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Facility_iddObjectType)
    __swig_getmethods__["fossilFuels"] = lambda x: _openstudiomodelgeometry.Facility_fossilFuels
    if _newclass:
        fossilFuels = staticmethod(_openstudiomodelgeometry.Facility_fossilFuels)

    def building(self) -> "boost::optional< openstudio::model::Building >":
        return _openstudiomodelgeometry.Facility_building(self)

    def meters(self) -> "std::vector< openstudio::model::OutputMeter,std::allocator< openstudio::model::OutputMeter > >":
        return _openstudiomodelgeometry.Facility_meters(self)

    def getMeterByFuelType(self, *args) -> "boost::optional< openstudio::model::OutputMeter >":
        return _openstudiomodelgeometry.Facility_getMeterByFuelType(self, *args)

    def exteriorLights(self) -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
        return _openstudiomodelgeometry.Facility_exteriorLights(self)

    def exteriorFuelEquipments(self) -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
        return _openstudiomodelgeometry.Facility_exteriorFuelEquipments(self)

    def exteriorWaterEquipments(self) -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
        return _openstudiomodelgeometry.Facility_exteriorWaterEquipments(self)

    def totalSiteEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_totalSiteEnergy(self)

    def netSiteEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_netSiteEnergy(self)

    def totalSourceEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_totalSourceEnergy(self)

    def netSourceEnergy(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_netSourceEnergy(self)

    def annualTotalCost(self, fuel: 'FuelType') -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCost(self, fuel)

    def annualTotalCostPerBldgArea(self, fuel: 'FuelType') -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCostPerBldgArea(self, fuel)

    def annualTotalCostPerNetConditionedBldgArea(self, fuel: 'FuelType') -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalCostPerNetConditionedBldgArea(self, fuel)

    def annualTotalUtilityCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualTotalUtilityCost(self)

    def annualElectricTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualElectricTotalCost(self)

    def annualGasTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualGasTotalCost(self)

    def annualDistrictCoolingTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualDistrictCoolingTotalCost(self)

    def annualDistrictHeatingTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualDistrictHeatingTotalCost(self)

    def annualWaterTotalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_annualWaterTotalCost(self)

    def economicsCapitalCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsCapitalCost(self)

    def economicsEnergyCost(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsEnergyCost(self)

    def economicsTLCC(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsTLCC(self)

    def economicsVirtualRateGas(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateGas(self)

    def economicsVirtualRateElec(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateElec(self)

    def economicsVirtualRateCombined(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsVirtualRateCombined(self)

    def economicsSPB(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsSPB(self)

    def economicsDPB(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsDPB(self)

    def economicsNPV(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsNPV(self)

    def economicsIRR(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_economicsIRR(self)

    def electricityHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeating(self)

    def electricityCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityCooling(self)

    def electricityInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityInteriorLighting(self)

    def electricityExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityExteriorLighting(self)

    def electricityInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityInteriorEquipment(self)

    def electricityExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityExteriorEquipment(self)

    def electricityFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityFans(self)

    def electricityPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityPumps(self)

    def electricityHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeatRejection(self)

    def electricityHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHumidification(self)

    def electricityHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityHeatRecovery(self)

    def electricityWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityWaterSystems(self)

    def electricityRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityRefrigeration(self)

    def electricityGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityGenerators(self)

    def electricityTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_electricityTotalEndUses(self)

    def naturalGasHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeating(self)

    def naturalGasCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasCooling(self)

    def naturalGasInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasInteriorLighting(self)

    def naturalGasExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasExteriorLighting(self)

    def naturalGasInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasInteriorEquipment(self)

    def naturalGasExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasExteriorEquipment(self)

    def naturalGasFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasFans(self)

    def naturalGasPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasPumps(self)

    def naturalGasHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeatRejection(self)

    def naturalGasHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHumidification(self)

    def naturalGasHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasHeatRecovery(self)

    def naturalGasWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasWaterSystems(self)

    def naturalGasRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasRefrigeration(self)

    def naturalGasGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasGenerators(self)

    def naturalGasTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_naturalGasTotalEndUses(self)

    def otherFuelHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeating(self)

    def otherFuelCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelCooling(self)

    def otherFuelInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelInteriorLighting(self)

    def otherFuelExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelExteriorLighting(self)

    def otherFuelInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelInteriorEquipment(self)

    def otherFuelExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelExteriorEquipment(self)

    def otherFuelFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelFans(self)

    def otherFuelPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelPumps(self)

    def otherFuelHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeatRejection(self)

    def otherFuelHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHumidification(self)

    def otherFuelHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelHeatRecovery(self)

    def otherFuelWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelWaterSystems(self)

    def otherFuelRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelRefrigeration(self)

    def otherFuelGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelGenerators(self)

    def otherFuelTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_otherFuelTotalEndUses(self)

    def districtCoolingHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeating(self)

    def districtCoolingCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingCooling(self)

    def districtCoolingInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingInteriorLighting(self)

    def districtCoolingExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingExteriorLighting(self)

    def districtCoolingInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingInteriorEquipment(self)

    def districtCoolingExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingExteriorEquipment(self)

    def districtCoolingFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingFans(self)

    def districtCoolingPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingPumps(self)

    def districtCoolingHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeatRejection(self)

    def districtCoolingHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHumidification(self)

    def districtCoolingHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingHeatRecovery(self)

    def districtCoolingWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingWaterSystems(self)

    def districtCoolingRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingRefrigeration(self)

    def districtCoolingGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingGenerators(self)

    def districtCoolingTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtCoolingTotalEndUses(self)

    def districtHeatingHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeating(self)

    def districtHeatingCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingCooling(self)

    def districtHeatingInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingInteriorLighting(self)

    def districtHeatingExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingExteriorLighting(self)

    def districtHeatingInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingInteriorEquipment(self)

    def districtHeatingExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingExteriorEquipment(self)

    def districtHeatingFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingFans(self)

    def districtHeatingPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingPumps(self)

    def districtHeatingHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeatRejection(self)

    def districtHeatingHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHumidification(self)

    def districtHeatingHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingHeatRecovery(self)

    def districtHeatingWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingWaterSystems(self)

    def districtHeatingRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingRefrigeration(self)

    def districtHeatingGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingGenerators(self)

    def districtHeatingTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_districtHeatingTotalEndUses(self)

    def waterHeating(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeating(self)

    def waterCooling(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterCooling(self)

    def waterInteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterInteriorLighting(self)

    def waterExteriorLighting(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterExteriorLighting(self)

    def waterInteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterInteriorEquipment(self)

    def waterExteriorEquipment(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterExteriorEquipment(self)

    def waterFans(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterFans(self)

    def waterPumps(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterPumps(self)

    def waterHeatRejection(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeatRejection(self)

    def waterHumidification(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHumidification(self)

    def waterHeatRecovery(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterHeatRecovery(self)

    def waterWaterSystems(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterWaterSystems(self)

    def waterRefrigeration(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterRefrigeration(self)

    def waterGenerators(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterGenerators(self)

    def waterTotalEndUses(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_waterTotalEndUses(self)

    def hoursHeatingSetpointNotMet(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_hoursHeatingSetpointNotMet(self)

    def hoursCoolingSetpointNotMet(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Facility_hoursCoolingSetpointNotMet(self)

    def endUses(self) -> "boost::optional< openstudio::EndUses >":
        return _openstudiomodelgeometry.Facility_endUses(self)

    def endUsesAttribute(self) -> "boost::optional< openstudio::Attribute >":
        return _openstudiomodelgeometry.Facility_endUsesAttribute(self)

    def calibrationResult(self) -> "boost::optional< openstudio::CalibrationResult >":
        return _openstudiomodelgeometry.Facility_calibrationResult(self)

    def calibrationResultAttribute(self) -> "boost::optional< openstudio::Attribute >":
        return _openstudiomodelgeometry.Facility_calibrationResultAttribute(self)
Facility_swigregister = _openstudiomodelgeometry.Facility_swigregister
Facility_swigregister(Facility)

def Facility_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Facility_iddObjectType()
Facility_iddObjectType = _openstudiomodelgeometry.Facility_iddObjectType

def Facility_fossilFuels() -> "std::vector< openstudio::FuelType,std::allocator< openstudio::FuelType > >":
    return _openstudiomodelgeometry.Facility_fossilFuels()
Facility_fossilFuels = _openstudiomodelgeometry.Facility_fossilFuels


def toFacility(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Facility >":
    return _openstudiomodelgeometry.toFacility(idfObject)
toFacility = _openstudiomodelgeometry.toFacility

def getFacility(t_model: 'Model') -> "openstudio::model::Facility":
    return _openstudiomodelgeometry.getFacility(t_model)
getFacility = _openstudiomodelgeometry.getFacility

def getOptionalFacility(t_model: 'Model') -> "boost::optional< openstudio::model::Facility >":
    return _openstudiomodelgeometry.getOptionalFacility(t_model)
getOptionalFacility = _openstudiomodelgeometry.getOptionalFacility
class Building(openstudiomodelcore.ParentObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Building, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Building, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_Building
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Building_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Building_iddObjectType)

    def northAxis(self) -> "double":
        return _openstudiomodelgeometry.Building_northAxis(self)

    def isNorthAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Building_isNorthAxisDefaulted(self)

    def nominalFloortoFloorHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_nominalFloortoFloorHeight(self)

    def standardsNumberOfStories(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfStories(self)

    def standardsNumberOfAboveGroundStories(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfAboveGroundStories(self)

    def standardsNumberOfLivingUnits(self) -> "boost::optional< int >":
        return _openstudiomodelgeometry.Building_standardsNumberOfLivingUnits(self)

    def nominalFloortoCeilingHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_nominalFloortoCeilingHeight(self)

    def standardsTemplate(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.Building_standardsTemplate(self)

    def suggestedStandardsTemplates(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Building_suggestedStandardsTemplates(self)

    def standardsBuildingType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.Building_standardsBuildingType(self)

    def suggestedStandardsBuildingTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.Building_suggestedStandardsBuildingTypes(self)

    def relocatable(self) -> "bool":
        return _openstudiomodelgeometry.Building_relocatable(self)

    def isRelocatableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Building_isRelocatableDefaulted(self)

    def setNorthAxis(self, northAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.Building_setNorthAxis(self, northAxis)

    def resetNorthAxis(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNorthAxis(self)

    def setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight: 'double') -> "bool":
        return _openstudiomodelgeometry.Building_setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight)

    def resetNominalFloortoFloorHeight(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNominalFloortoFloorHeight(self)

    def setStandardsNumberOfStories(self, value: 'int') -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfStories(self, value)

    def resetStandardsNumberOfStories(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfStories(self)

    def setStandardsNumberOfAboveGroundStories(self, value: 'int') -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfAboveGroundStories(self, value)

    def resetStandardsNumberOfAboveGroundStories(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfAboveGroundStories(self)

    def setStandardsNumberOfLivingUnits(self, value: 'int') -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsNumberOfLivingUnits(self, value)

    def resetStandardsNumberOfLivingUnits(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsNumberOfLivingUnits(self)

    def setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight: 'double') -> "bool":
        return _openstudiomodelgeometry.Building_setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight)

    def resetNominalFloortoCeilingHeight(self) -> "void":
        return _openstudiomodelgeometry.Building_resetNominalFloortoCeilingHeight(self)

    def setStandardsTemplate(self, standardsTemplate: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsTemplate(self, standardsTemplate)

    def resetStandardsTemplate(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsTemplate(self)

    def setStandardsBuildingType(self, standardsBuildingType: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.Building_setStandardsBuildingType(self, standardsBuildingType)

    def resetStandardsBuildingType(self) -> "void":
        return _openstudiomodelgeometry.Building_resetStandardsBuildingType(self)

    def setRelocatable(self, isRelocatable: 'bool') -> "bool":
        return _openstudiomodelgeometry.Building_setRelocatable(self, isRelocatable)

    def setRelocatableNoFail(self, isRelocatable: 'bool') -> "void":
        return _openstudiomodelgeometry.Building_setRelocatableNoFail(self, isRelocatable)

    def resetRelocatable(self) -> "void":
        return _openstudiomodelgeometry.Building_resetRelocatable(self)

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.Building_spaceType(self)

    def setSpaceType(self, spaceType: 'SpaceType') -> "bool":
        return _openstudiomodelgeometry.Building_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.Building_resetSpaceType(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.Building_defaultConstructionSet(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: 'DefaultConstructionSet') -> "bool":
        return _openstudiomodelgeometry.Building_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.Building_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.Building_defaultScheduleSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: 'DefaultScheduleSet') -> "bool":
        return _openstudiomodelgeometry.Building_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.Building_resetDefaultScheduleSet(self)

    def meters(self) -> "std::vector< openstudio::model::OutputMeter,std::allocator< openstudio::model::OutputMeter > >":
        return _openstudiomodelgeometry.Building_meters(self)

    def facility(self) -> "boost::optional< openstudio::model::Facility >":
        return _openstudiomodelgeometry.Building_facility(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.Building_spaces(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Building_shadingSurfaceGroups(self)

    def thermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelgeometry.Building_thermalZones(self)

    def exteriorWalls(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Building_exteriorWalls(self)

    def roofs(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Building_roofs(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_floorArea(self)

    def conditionedFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Building_conditionedFloorArea(self)

    def exteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Building_exteriorSurfaceArea(self)

    def exteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Building_exteriorWallArea(self)

    def airVolume(self) -> "double":
        return _openstudiomodelgeometry.Building_airVolume(self)

    def numberOfPeople(self) -> "double":
        return _openstudiomodelgeometry.Building_numberOfPeople(self)

    def peoplePerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_peoplePerFloorArea(self)

    def floorAreaPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_floorAreaPerPerson(self)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPower(self)

    def lightingPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPowerPerFloorArea(self)

    def lightingPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_lightingPowerPerPerson(self)

    def electricEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPower(self)

    def electricEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPowerPerFloorArea(self)

    def electricEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_electricEquipmentPowerPerPerson(self)

    def gasEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPower(self)

    def gasEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPowerPerFloorArea(self)

    def gasEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Building_gasEquipmentPowerPerPerson(self)

    def infiltrationDesignFlowRate(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowRate(self)

    def infiltrationDesignFlowPerSpaceFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerSpaceFloorArea(self)

    def infiltrationDesignFlowPerExteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerExteriorSurfaceArea(self)

    def infiltrationDesignFlowPerExteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignFlowPerExteriorWallArea(self)

    def infiltrationDesignAirChangesPerHour(self) -> "double":
        return _openstudiomodelgeometry.Building_infiltrationDesignAirChangesPerHour(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.Building_transformation(self)

    def generateSkylightPattern(self, skylightToProjectedFloorRatio: 'double', desiredWidth: 'double', desiredHeight: 'double') -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
        return _openstudiomodelgeometry.Building_generateSkylightPattern(self, skylightToProjectedFloorRatio, desiredWidth, desiredHeight)
Building_swigregister = _openstudiomodelgeometry.Building_swigregister
Building_swigregister(Building)

def Building_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Building_iddObjectType()
Building_iddObjectType = _openstudiomodelgeometry.Building_iddObjectType


def toBuilding(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Building >":
    return _openstudiomodelgeometry.toBuilding(idfObject)
toBuilding = _openstudiomodelgeometry.toBuilding

def getBuilding(t_model: 'Model') -> "openstudio::model::Building":
    return _openstudiomodelgeometry.getBuilding(t_model)
getBuilding = _openstudiomodelgeometry.getBuilding

def getOptionalBuilding(t_model: 'Model') -> "boost::optional< openstudio::model::Building >":
    return _openstudiomodelgeometry.getOptionalBuilding(t_model)
getOptionalBuilding = _openstudiomodelgeometry.getOptionalBuilding
class BuildingStory(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingStory, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingStory, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_BuildingStory(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingStory
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.BuildingStory_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.BuildingStory_iddObjectType)

    def nominalZCoordinate(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalZCoordinate(self)

    def nominalFloortoFloorHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalFloortoFloorHeight(self)

    def nominalFloortoCeilingHeight(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingStory_nominalFloortoCeilingHeight(self)

    def setNominalZCoordinate(self, nominalZCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalZCoordinate(self, nominalZCoordinate)

    def resetNominalZCoordinate(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalZCoordinate(self)

    def setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight: 'double') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalFloortoFloorHeight(self, nominalFloortoFloorHeight)

    def resetNominalFloortoFloorHeight(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalFloortoFloorHeight(self)

    def setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight: 'double') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setNominalFloortoCeilingHeight(self, nominalFloortoCeilingHeight)

    def resetNominalFloortoCeilingHeight(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetNominalFloortoCeilingHeight(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.BuildingStory_spaces(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.BuildingStory_defaultConstructionSet(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: 'DefaultConstructionSet') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.BuildingStory_defaultScheduleSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: 'DefaultScheduleSet') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetDefaultScheduleSet(self)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.BuildingStory_renderingColor(self)

    def setRenderingColor(self, renderingColor: 'RenderingColor') -> "bool":
        return _openstudiomodelgeometry.BuildingStory_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.BuildingStory_resetRenderingColor(self)
BuildingStory_swigregister = _openstudiomodelgeometry.BuildingStory_swigregister
BuildingStory_swigregister(BuildingStory)

def BuildingStory_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.BuildingStory_iddObjectType()
BuildingStory_iddObjectType = _openstudiomodelgeometry.BuildingStory_iddObjectType


def toBuildingStory(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.toBuildingStory(idfObject)
toBuildingStory = _openstudiomodelgeometry.toBuildingStory

def getBuildingStory(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.getBuildingStory(t_model, t_handle)
getBuildingStory = _openstudiomodelgeometry.getBuildingStory

def getBuildingStorys(t_model: 'Model') -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > >":
    return _openstudiomodelgeometry.getBuildingStorys(t_model)
getBuildingStorys = _openstudiomodelgeometry.getBuildingStorys

def getBuildingStoryByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::BuildingStory >":
    return _openstudiomodelgeometry.getBuildingStoryByName(t_model, t_name)
getBuildingStoryByName = _openstudiomodelgeometry.getBuildingStoryByName

def getBuildingStorysByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::BuildingStory,std::allocator< openstudio::model::BuildingStory > >":
    return _openstudiomodelgeometry.getBuildingStorysByName(t_model, t_name, t_exactMatch)
getBuildingStorysByName = _openstudiomodelgeometry.getBuildingStorysByName
class BuildingUnit(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingUnit, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingUnit, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_BuildingUnit(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_BuildingUnit
    __del__ = lambda self: None
    __swig_getmethods__["buildingUnitTypeValues"] = lambda x: _openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues
    if _newclass:
        buildingUnitTypeValues = staticmethod(_openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues)
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.BuildingUnit_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.BuildingUnit_iddObjectType)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.BuildingUnit_renderingColor(self)

    def buildingUnitType(self) -> "std::string":
        return _openstudiomodelgeometry.BuildingUnit_buildingUnitType(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.BuildingUnit_spaces(self)

    def featureNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.BuildingUnit_featureNames(self)

    def getFeatureDataType(self, name: 'std::string const &') -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureDataType(self, name)

    def getFeatureAsString(self, name: 'std::string const &') -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsString(self, name)

    def getFeatureAsDouble(self, name: 'std::string const &') -> "boost::optional< double >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsDouble(self, name)

    def getFeatureAsInteger(self, name: 'std::string const &') -> "boost::optional< int >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsInteger(self, name)

    def getFeatureAsBoolean(self, name: 'std::string const &') -> "boost::optional< bool >":
        return _openstudiomodelgeometry.BuildingUnit_getFeatureAsBoolean(self, name)

    def suggestedFeatures(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.BuildingUnit_suggestedFeatures(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.BuildingUnit_floorArea(self)

    def setRenderingColor(self, renderingColor: 'RenderingColor') -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnit_resetRenderingColor(self)

    def setBuildingUnitType(self, buildingUnitType: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setBuildingUnitType(self, buildingUnitType)

    def resetBuildingUnitType(self) -> "void":
        return _openstudiomodelgeometry.BuildingUnit_resetBuildingUnitType(self)

    def setFeature(self, *args) -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_setFeature(self, *args)

    def resetFeature(self, name: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.BuildingUnit_resetFeature(self, name)
BuildingUnit_swigregister = _openstudiomodelgeometry.BuildingUnit_swigregister
BuildingUnit_swigregister(BuildingUnit)

def BuildingUnit_buildingUnitTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues()
BuildingUnit_buildingUnitTypeValues = _openstudiomodelgeometry.BuildingUnit_buildingUnitTypeValues

def BuildingUnit_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.BuildingUnit_iddObjectType()
BuildingUnit_iddObjectType = _openstudiomodelgeometry.BuildingUnit_iddObjectType


def toBuildingUnit(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.toBuildingUnit(idfObject)
toBuildingUnit = _openstudiomodelgeometry.toBuildingUnit

def getBuildingUnit(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.getBuildingUnit(t_model, t_handle)
getBuildingUnit = _openstudiomodelgeometry.getBuildingUnit

def getBuildingUnits(t_model: 'Model') -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > >":
    return _openstudiomodelgeometry.getBuildingUnits(t_model)
getBuildingUnits = _openstudiomodelgeometry.getBuildingUnits

def getBuildingUnitByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::BuildingUnit >":
    return _openstudiomodelgeometry.getBuildingUnitByName(t_model, t_name)
getBuildingUnitByName = _openstudiomodelgeometry.getBuildingUnitByName

def getBuildingUnitsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::BuildingUnit,std::allocator< openstudio::model::BuildingUnit > >":
    return _openstudiomodelgeometry.getBuildingUnitsByName(t_model, t_name, t_exactMatch)
getBuildingUnitsByName = _openstudiomodelgeometry.getBuildingUnitsByName
class PlanarSurfaceGroup(openstudiomodelcore.ParentObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlanarSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlanarSurfaceGroup, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurfaceGroup
    __del__ = lambda self: None

    def directionofRelativeNorth(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_directionofRelativeNorth(self)

    def isDirectionofRelativeNorthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isDirectionofRelativeNorthDefaulted(self)

    def xOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_xOrigin(self)

    def isXOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isXOriginDefaulted(self)

    def yOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_yOrigin(self)

    def isYOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isYOriginDefaulted(self)

    def zOrigin(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_zOrigin(self)

    def isZOriginDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_isZOriginDefaulted(self)

    def setDirectionofRelativeNorth(self, directionofRelativeNorth: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setDirectionofRelativeNorth(self, directionofRelativeNorth)

    def resetDirectionofRelativeNorth(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetDirectionofRelativeNorth(self)

    def setXOrigin(self, xOrigin: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setXOrigin(self, xOrigin)

    def resetXOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetXOrigin(self)

    def setYOrigin(self, yOrigin: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setYOrigin(self, yOrigin)

    def resetYOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetYOrigin(self)

    def setZOrigin(self, zOrigin: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setZOrigin(self, zOrigin)

    def resetZOrigin(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_resetZOrigin(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_transformation(self)

    def buildingTransformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_buildingTransformation(self)

    def siteTransformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_siteTransformation(self)

    def setTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_setTransformation(self, transformation)

    def changeTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_changeTransformation(self, transformation)

    def boundingBox(self) -> "openstudio::BoundingBox":
        return _openstudiomodelgeometry.PlanarSurfaceGroup_boundingBox(self)
PlanarSurfaceGroup_swigregister = _openstudiomodelgeometry.PlanarSurfaceGroup_swigregister
PlanarSurfaceGroup_swigregister(PlanarSurfaceGroup)


def toPlanarSurfaceGroup(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.toPlanarSurfaceGroup(idfObject)
toPlanarSurfaceGroup = _openstudiomodelgeometry.toPlanarSurfaceGroup

def getPlanarSurfaceGroup(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroup(t_model, t_handle)
getPlanarSurfaceGroup = _openstudiomodelgeometry.getPlanarSurfaceGroup

def getPlanarSurfaceGroups(t_model: 'Model') -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroups(t_model)
getPlanarSurfaceGroups = _openstudiomodelgeometry.getPlanarSurfaceGroups

def getPlanarSurfaceGroupByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroupByName(t_model, t_name)
getPlanarSurfaceGroupByName = _openstudiomodelgeometry.getPlanarSurfaceGroupByName

def getPlanarSurfaceGroupsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::PlanarSurfaceGroup,std::allocator< openstudio::model::PlanarSurfaceGroup > >":
    return _openstudiomodelgeometry.getPlanarSurfaceGroupsByName(t_model, t_name, t_exactMatch)
getPlanarSurfaceGroupsByName = _openstudiomodelgeometry.getPlanarSurfaceGroupsByName
class Space(PlanarSurfaceGroup):
    __swig_setmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Space, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Space, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_Space(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_Space
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Space_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Space_iddObjectType)
    __swig_getmethods__["fromFloorPrint"] = lambda x: _openstudiomodelgeometry.Space_fromFloorPrint
    if _newclass:
        fromFloorPrint = staticmethod(_openstudiomodelgeometry.Space_fromFloorPrint)

    def partofTotalFloorArea(self) -> "bool":
        return _openstudiomodelgeometry.Space_partofTotalFloorArea(self)

    def isPartofTotalFloorAreaDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isPartofTotalFloorAreaDefaulted(self)

    def setPartofTotalFloorArea(self, partofTotalFloorArea: 'bool') -> "bool":
        return _openstudiomodelgeometry.Space_setPartofTotalFloorArea(self, partofTotalFloorArea)

    def resetPartofTotalFloorArea(self) -> "void":
        return _openstudiomodelgeometry.Space_resetPartofTotalFloorArea(self)

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.Space_spaceType(self)

    def isSpaceTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isSpaceTypeDefaulted(self)

    def setSpaceType(self, spaceType: 'SpaceType') -> "bool":
        return _openstudiomodelgeometry.Space_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.Space_resetSpaceType(self)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.Space_defaultConstructionSet(self)

    def getDefaultConstruction(self, planarSurface: 'PlanarSurface') -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.Space_getDefaultConstruction(self, planarSurface)

    def setDefaultConstructionSet(self, defaultConstructionSet: 'DefaultConstructionSet') -> "bool":
        return _openstudiomodelgeometry.Space_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDefaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.Space_defaultScheduleSet(self)

    def getDefaultSchedule(self, defaultScheduleType: 'DefaultScheduleType') -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Space_getDefaultSchedule(self, defaultScheduleType)

    def setDefaultScheduleSet(self, defaultScheduleSet: 'DefaultScheduleSet') -> "bool":
        return _openstudiomodelgeometry.Space_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDefaultScheduleSet(self)

    def thermalZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelgeometry.Space_thermalZone(self)

    def setThermalZone(self, thermalZone: 'openstudio::model::ThermalZone &') -> "bool":
        return _openstudiomodelgeometry.Space_setThermalZone(self, thermalZone)

    def resetThermalZone(self) -> "void":
        return _openstudiomodelgeometry.Space_resetThermalZone(self)

    def buildingStory(self) -> "boost::optional< openstudio::model::BuildingStory >":
        return _openstudiomodelgeometry.Space_buildingStory(self)

    def setBuildingStory(self, buildingStory: 'BuildingStory') -> "bool":
        return _openstudiomodelgeometry.Space_setBuildingStory(self, buildingStory)

    def resetBuildingStory(self) -> "void":
        return _openstudiomodelgeometry.Space_resetBuildingStory(self)

    def buildingUnit(self) -> "boost::optional< openstudio::model::BuildingUnit >":
        return _openstudiomodelgeometry.Space_buildingUnit(self)

    def setBuildingUnit(self, buildingUnit: 'BuildingUnit') -> "bool":
        return _openstudiomodelgeometry.Space_setBuildingUnit(self, buildingUnit)

    def resetBuildingUnit(self) -> "void":
        return _openstudiomodelgeometry.Space_resetBuildingUnit(self)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Space_shadingSurfaceGroups(self)

    def interiorPartitionSurfaceGroups(self) -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
        return _openstudiomodelgeometry.Space_interiorPartitionSurfaceGroups(self)

    def surfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Space_surfaces(self)

    def internalMass(self) -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
        return _openstudiomodelgeometry.Space_internalMass(self)

    def people(self) -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
        return _openstudiomodelgeometry.Space_people(self)

    def lights(self) -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
        return _openstudiomodelgeometry.Space_lights(self)

    def luminaires(self) -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
        return _openstudiomodelgeometry.Space_luminaires(self)

    def electricEquipment(self) -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
        return _openstudiomodelgeometry.Space_electricEquipment(self)

    def gasEquipment(self) -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
        return _openstudiomodelgeometry.Space_gasEquipment(self)

    def hotWaterEquipment(self) -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
        return _openstudiomodelgeometry.Space_hotWaterEquipment(self)

    def steamEquipment(self) -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
        return _openstudiomodelgeometry.Space_steamEquipment(self)

    def otherEquipment(self) -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
        return _openstudiomodelgeometry.Space_otherEquipment(self)

    def waterUseEquipment(self) -> "std::vector< openstudio::model::WaterUseEquipment,std::allocator< openstudio::model::WaterUseEquipment > >":
        return _openstudiomodelgeometry.Space_waterUseEquipment(self)

    def daylightingControls(self) -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
        return _openstudiomodelgeometry.Space_daylightingControls(self)

    def illuminanceMaps(self) -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
        return _openstudiomodelgeometry.Space_illuminanceMaps(self)

    def glareSensors(self) -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
        return _openstudiomodelgeometry.Space_glareSensors(self)

    def spaceInfiltrationDesignFlowRates(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
        return _openstudiomodelgeometry.Space_spaceInfiltrationDesignFlowRates(self)

    def spaceInfiltrationEffectiveLeakageAreas(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
        return _openstudiomodelgeometry.Space_spaceInfiltrationEffectiveLeakageAreas(self)

    def designSpecificationOutdoorAir(self) -> "boost::optional< openstudio::model::DesignSpecificationOutdoorAir >":
        return _openstudiomodelgeometry.Space_designSpecificationOutdoorAir(self)

    def isDesignSpecificationOutdoorAirDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Space_isDesignSpecificationOutdoorAirDefaulted(self)

    def setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir: 'DesignSpecificationOutdoorAir') -> "bool":
        return _openstudiomodelgeometry.Space_setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir)

    def resetDesignSpecificationOutdoorAir(self) -> "void":
        return _openstudiomodelgeometry.Space_resetDesignSpecificationOutdoorAir(self)

    def multiplier(self) -> "int":
        return _openstudiomodelgeometry.Space_multiplier(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_floorArea(self)

    def exteriorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_exteriorArea(self)

    def exteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Space_exteriorWallArea(self)

    def volume(self) -> "double":
        return _openstudiomodelgeometry.Space_volume(self)

    def numberOfPeople(self) -> "double":
        return _openstudiomodelgeometry.Space_numberOfPeople(self)

    def setNumberOfPeople(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setNumberOfPeople(self, *args)

    def peoplePerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_peoplePerFloorArea(self)

    def setPeoplePerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setPeoplePerFloorArea(self, *args)

    def floorAreaPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_floorAreaPerPerson(self)

    def setFloorAreaPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setFloorAreaPerPerson(self, *args)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPower(self)

    def setLightingPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPower(self, *args)

    def lightingPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPowerPerFloorArea(self)

    def setLightingPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPowerPerFloorArea(self, *args)

    def lightingPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_lightingPowerPerPerson(self)

    def setLightingPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setLightingPowerPerPerson(self, *args)

    def electricEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPower(self)

    def setElectricEquipmentPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPower(self, *args)

    def electricEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPowerPerFloorArea(self)

    def setElectricEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPowerPerFloorArea(self, *args)

    def electricEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_electricEquipmentPowerPerPerson(self)

    def setElectricEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setElectricEquipmentPowerPerPerson(self, *args)

    def gasEquipmentPower(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPower(self)

    def setGasEquipmentPower(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPower(self, *args)

    def gasEquipmentPowerPerFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPowerPerFloorArea(self)

    def setGasEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPowerPerFloorArea(self, *args)

    def gasEquipmentPowerPerPerson(self) -> "double":
        return _openstudiomodelgeometry.Space_gasEquipmentPowerPerPerson(self)

    def setGasEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.Space_setGasEquipmentPowerPerPerson(self, *args)

    def infiltrationDesignFlowRate(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowRate(self)

    def infiltrationDesignFlowPerSpaceFloorArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerSpaceFloorArea(self)

    def infiltrationDesignFlowPerExteriorSurfaceArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerExteriorSurfaceArea(self)

    def infiltrationDesignFlowPerExteriorWallArea(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignFlowPerExteriorWallArea(self)

    def infiltrationDesignAirChangesPerHour(self) -> "double":
        return _openstudiomodelgeometry.Space_infiltrationDesignAirChangesPerHour(self)

    def hardApplySpaceType(self, hardSizeLoads: 'bool') -> "void":
        return _openstudiomodelgeometry.Space_hardApplySpaceType(self, hardSizeLoads)

    def hardApplySpaceLoadSchedules(self) -> "void":
        return _openstudiomodelgeometry.Space_hardApplySpaceLoadSchedules(self)

    def hardApplyConstructions(self) -> "void":
        return _openstudiomodelgeometry.Space_hardApplyConstructions(self)

    def unmatchSurfaces(self) -> "void":
        return _openstudiomodelgeometry.Space_unmatchSurfaces(self)

    def matchSurfaces(self, other: 'Space') -> "void":
        return _openstudiomodelgeometry.Space_matchSurfaces(self, other)

    def intersectSurfaces(self, other: 'Space') -> "void":
        return _openstudiomodelgeometry.Space_intersectSurfaces(self, other)

    def findSurfaces(self, minDegreesFromNorth: 'OptionalDouble', maxDegreesFromNorth: 'OptionalDouble', minDegreesTilt: 'OptionalDouble', maxDegreesTilt: 'OptionalDouble', tol: 'double'=1) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Space_findSurfaces(self, minDegreesFromNorth, maxDegreesFromNorth, minDegreesTilt, maxDegreesTilt, tol)

    def floorPrint(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.Space_floorPrint(self)

    def isPlenum(self) -> "bool":
        return _openstudiomodelgeometry.Space_isPlenum(self)
Space_swigregister = _openstudiomodelgeometry.Space_swigregister
Space_swigregister(Space)

def Space_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Space_iddObjectType()
Space_iddObjectType = _openstudiomodelgeometry.Space_iddObjectType

def Space_fromFloorPrint(floorPrint: 'Point3dVector', floorHeight: 'double', model: 'Model') -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.Space_fromFloorPrint(floorPrint, floorHeight, model)
Space_fromFloorPrint = _openstudiomodelgeometry.Space_fromFloorPrint


def intersectSurfaces(spaces: 'SpaceVector') -> "void":
    return _openstudiomodelgeometry.intersectSurfaces(spaces)
intersectSurfaces = _openstudiomodelgeometry.intersectSurfaces

def matchSurfaces(spaces: 'SpaceVector') -> "void":
    return _openstudiomodelgeometry.matchSurfaces(spaces)
matchSurfaces = _openstudiomodelgeometry.matchSurfaces

def unmatchSurfaces(spaces: 'SpaceVector') -> "void":
    return _openstudiomodelgeometry.unmatchSurfaces(spaces)
unmatchSurfaces = _openstudiomodelgeometry.unmatchSurfaces

def generateSkylightPattern(spaces: 'SpaceVector', directionOfRelativeNorth: 'double', skylightToProjectedFloorRatio: 'double', desiredWidth: 'double', desiredHeight: 'double') -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
    return _openstudiomodelgeometry.generateSkylightPattern(spaces, directionOfRelativeNorth, skylightToProjectedFloorRatio, desiredWidth, desiredHeight)
generateSkylightPattern = _openstudiomodelgeometry.generateSkylightPattern

def toSpace(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.toSpace(idfObject)
toSpace = _openstudiomodelgeometry.toSpace

def getSpace(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.getSpace(t_model, t_handle)
getSpace = _openstudiomodelgeometry.getSpace

def getSpaces(t_model: 'Model') -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
    return _openstudiomodelgeometry.getSpaces(t_model)
getSpaces = _openstudiomodelgeometry.getSpaces

def getSpaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::Space >":
    return _openstudiomodelgeometry.getSpaceByName(t_model, t_name)
getSpaceByName = _openstudiomodelgeometry.getSpaceByName

def getSpacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
    return _openstudiomodelgeometry.getSpacesByName(t_model, t_name, t_exactMatch)
getSpacesByName = _openstudiomodelgeometry.getSpacesByName
class SpaceItem(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceItem, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceItem, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceItem
    __del__ = lambda self: None

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.SpaceItem_space(self)

    def setSpace(self, space: 'Space') -> "bool":
        return _openstudiomodelgeometry.SpaceItem_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.SpaceItem_resetSpace(self)
SpaceItem_swigregister = _openstudiomodelgeometry.SpaceItem_swigregister
SpaceItem_swigregister(SpaceItem)


def toSpaceItem(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.toSpaceItem(idfObject)
toSpaceItem = _openstudiomodelgeometry.toSpaceItem

def getSpaceItem(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.getSpaceItem(t_model, t_handle)
getSpaceItem = _openstudiomodelgeometry.getSpaceItem

def getSpaceItems(t_model: 'Model') -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > >":
    return _openstudiomodelgeometry.getSpaceItems(t_model)
getSpaceItems = _openstudiomodelgeometry.getSpaceItems

def getSpaceItemByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceItem >":
    return _openstudiomodelgeometry.getSpaceItemByName(t_model, t_name)
getSpaceItemByName = _openstudiomodelgeometry.getSpaceItemByName

def getSpaceItemsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceItem,std::allocator< openstudio::model::SpaceItem > >":
    return _openstudiomodelgeometry.getSpaceItemsByName(t_model, t_name, t_exactMatch)
getSpaceItemsByName = _openstudiomodelgeometry.getSpaceItemsByName
class SpaceLoad(SpaceItem):
    __swig_setmethods__ = {}
    for _s in [SpaceItem]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceLoad, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceItem]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceLoad, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoad
    __del__ = lambda self: None

    def spaceType(self) -> "boost::optional< openstudio::model::SpaceType >":
        return _openstudiomodelgeometry.SpaceLoad_spaceType(self)

    def setSpaceType(self, spaceType: 'SpaceType') -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_setSpaceType(self, spaceType)

    def resetSpaceType(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoad_resetSpaceType(self)

    def hardSize(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_hardSize(self)

    def hardApplySchedules(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_hardApplySchedules(self)

    def isAbsolute(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoad_isAbsolute(self)
SpaceLoad_swigregister = _openstudiomodelgeometry.SpaceLoad_swigregister
SpaceLoad_swigregister(SpaceLoad)


def toSpaceLoad(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.toSpaceLoad(idfObject)
toSpaceLoad = _openstudiomodelgeometry.toSpaceLoad

def getSpaceLoad(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.getSpaceLoad(t_model, t_handle)
getSpaceLoad = _openstudiomodelgeometry.getSpaceLoad

def getSpaceLoads(t_model: 'Model') -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > >":
    return _openstudiomodelgeometry.getSpaceLoads(t_model)
getSpaceLoads = _openstudiomodelgeometry.getSpaceLoads

def getSpaceLoadByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceLoad >":
    return _openstudiomodelgeometry.getSpaceLoadByName(t_model, t_name)
getSpaceLoadByName = _openstudiomodelgeometry.getSpaceLoadByName

def getSpaceLoadsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceLoad,std::allocator< openstudio::model::SpaceLoad > >":
    return _openstudiomodelgeometry.getSpaceLoadsByName(t_model, t_name, t_exactMatch)
getSpaceLoadsByName = _openstudiomodelgeometry.getSpaceLoadsByName
class SpaceLoadInstance(SpaceLoad):
    __swig_setmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceLoadInstance, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceLoadInstance, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceLoadInstance
    __del__ = lambda self: None

    def definition(self) -> "openstudio::model::SpaceLoadDefinition":
        return _openstudiomodelgeometry.SpaceLoadInstance_definition(self)

    def setDefinition(self, definition: 'SpaceLoadDefinition') -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstance_setDefinition(self, definition)

    def makeUnique(self) -> "void":
        return _openstudiomodelgeometry.SpaceLoadInstance_makeUnique(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.SpaceLoadInstance_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceLoadInstance_isMultiplierDefaulted(self)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceLoadInstance_floorArea(self)

    def quantity(self) -> "int":
        return _openstudiomodelgeometry.SpaceLoadInstance_quantity(self)
SpaceLoadInstance_swigregister = _openstudiomodelgeometry.SpaceLoadInstance_swigregister
SpaceLoadInstance_swigregister(SpaceLoadInstance)


def toSpaceLoadInstance(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.toSpaceLoadInstance(idfObject)
toSpaceLoadInstance = _openstudiomodelgeometry.toSpaceLoadInstance

def getSpaceLoadInstance(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.getSpaceLoadInstance(t_model, t_handle)
getSpaceLoadInstance = _openstudiomodelgeometry.getSpaceLoadInstance

def getSpaceLoadInstances(t_model: 'Model') -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > >":
    return _openstudiomodelgeometry.getSpaceLoadInstances(t_model)
getSpaceLoadInstances = _openstudiomodelgeometry.getSpaceLoadInstances

def getSpaceLoadInstanceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceLoadInstance >":
    return _openstudiomodelgeometry.getSpaceLoadInstanceByName(t_model, t_name)
getSpaceLoadInstanceByName = _openstudiomodelgeometry.getSpaceLoadInstanceByName

def getSpaceLoadInstancesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceLoadInstance,std::allocator< openstudio::model::SpaceLoadInstance > >":
    return _openstudiomodelgeometry.getSpaceLoadInstancesByName(t_model, t_name, t_exactMatch)
getSpaceLoadInstancesByName = _openstudiomodelgeometry.getSpaceLoadInstancesByName
class Lights(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lights, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Lights, name)
    __repr__ = _swig_repr

    def __init__(self, lightsDefinition: 'LightsDefinition'):
        this = _openstudiomodelgeometry.new_Lights(lightsDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_Lights
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Lights_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Lights_iddObjectType)

    def lightsDefinition(self) -> "openstudio::model::LightsDefinition":
        return _openstudiomodelgeometry.Lights_lightsDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Lights_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isScheduleDefaulted(self)

    def fractionReplaceable(self) -> "double":
        return _openstudiomodelgeometry.Lights_fractionReplaceable(self)

    def isFractionReplaceableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isFractionReplaceableDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.Lights_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Lights_isEndUseSubcategoryDefaulted(self)

    def setLightsDefinition(self, definition: 'LightsDefinition') -> "bool":
        return _openstudiomodelgeometry.Lights_setLightsDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.Lights_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetSchedule(self)

    def setFractionReplaceable(self, fractionReplaceable: 'double') -> "bool":
        return _openstudiomodelgeometry.Lights_setFractionReplaceable(self, fractionReplaceable)

    def resetFractionReplaceable(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetFractionReplaceable(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.Lights_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Lights_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.Lights_resetEndUseSubcategory(self)

    def lightingLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_lightingLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Lights_powerPerPerson(self)

    def getLightingPower(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.Lights_getLightingPower(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.Lights_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.Lights_getPowerPerPerson(self, floorArea, numPeople)
Lights_swigregister = _openstudiomodelgeometry.Lights_swigregister
Lights_swigregister(Lights)

def Lights_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Lights_iddObjectType()
Lights_iddObjectType = _openstudiomodelgeometry.Lights_iddObjectType


def toLights(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.toLights(idfObject)
toLights = _openstudiomodelgeometry.toLights

def getLights(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.getLights(t_model, t_handle)
getLights = _openstudiomodelgeometry.getLights

def getLightss(t_model: 'Model') -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
    return _openstudiomodelgeometry.getLightss(t_model)
getLightss = _openstudiomodelgeometry.getLightss

def getLightsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::Lights >":
    return _openstudiomodelgeometry.getLightsByName(t_model, t_name)
getLightsByName = _openstudiomodelgeometry.getLightsByName

def getLightssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
    return _openstudiomodelgeometry.getLightssByName(t_model, t_name, t_exactMatch)
getLightssByName = _openstudiomodelgeometry.getLightssByName
class FilmResistanceType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilmResistanceType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FilmResistanceType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_FilmResistanceType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType_valueName(self)

    def value(self) -> "int":
        return _openstudiomodelgeometry.FilmResistanceType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudiomodelgeometry.FilmResistanceType_valueDescription(self)

    def __eq__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___eq__(self, other)

    def __ne__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___ne__(self, other)

    def __gt__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___gt__(self, other)

    def __ge__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___ge__(self, other)

    def __lt__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___lt__(self, other)

    def __le__(self, other: 'FilmResistanceType') -> "bool":
        return _openstudiomodelgeometry.FilmResistanceType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudiomodelgeometry.FilmResistanceType_enumName
    if _newclass:
        enumName = staticmethod(_openstudiomodelgeometry.FilmResistanceType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudiomodelgeometry.FilmResistanceType_getValues
    if _newclass:
        getValues = staticmethod(_openstudiomodelgeometry.FilmResistanceType_getValues)
    __swig_destroy__ = _openstudiomodelgeometry.delete_FilmResistanceType
    __del__ = lambda self: None
FilmResistanceType_swigregister = _openstudiomodelgeometry.FilmResistanceType_swigregister
FilmResistanceType_swigregister(FilmResistanceType)

def FilmResistanceType_enumName() -> "std::string":
    return _openstudiomodelgeometry.FilmResistanceType_enumName()
FilmResistanceType_enumName = _openstudiomodelgeometry.FilmResistanceType_enumName

def FilmResistanceType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudiomodelgeometry.FilmResistanceType_getValues()
FilmResistanceType_getValues = _openstudiomodelgeometry.FilmResistanceType_getValues

class PlanarSurface(openstudiomodelcore.ParentObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlanarSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ParentObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlanarSurface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_PlanarSurface
    __del__ = lambda self: None

    def construction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.PlanarSurface_construction(self)

    def isConstructionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_isConstructionDefaulted(self)

    def planarSurfaceGroup(self) -> "boost::optional< openstudio::model::PlanarSurfaceGroup >":
        return _openstudiomodelgeometry.PlanarSurface_planarSurfaceGroup(self)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.PlanarSurface_space(self)

    def vertices(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.PlanarSurface_vertices(self)

    def setVertices(self, vertices: 'Point3dVector') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setVertices(self, vertices)

    def setConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setConstruction(self, construction)

    def resetConstruction(self) -> "void":
        return _openstudiomodelgeometry.PlanarSurface_resetConstruction(self)
    __swig_getmethods__["findPlanarSurfaces"] = lambda x: _openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces
    if _newclass:
        findPlanarSurfaces = staticmethod(_openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces)
    __swig_getmethods__["filmResistance"] = lambda x: _openstudiomodelgeometry.PlanarSurface_filmResistance
    if _newclass:
        filmResistance = staticmethod(_openstudiomodelgeometry.PlanarSurface_filmResistance)
    __swig_getmethods__["stillAirFilmResistance"] = lambda x: _openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance
    if _newclass:
        stillAirFilmResistance = staticmethod(_openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance)

    def isAirWall(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_isAirWall(self)

    def grossArea(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_grossArea(self)

    def subtractFromGrossArea(self) -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_subtractFromGrossArea(self)

    def netArea(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_netArea(self)

    def outwardNormal(self) -> "openstudio::Vector3d":
        return _openstudiomodelgeometry.PlanarSurface_outwardNormal(self)

    def tilt(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_tilt(self)

    def azimuth(self) -> "double":
        return _openstudiomodelgeometry.PlanarSurface_azimuth(self)

    def uFactor(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_uFactor(self)

    def setUFactor(self, value: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setUFactor(self, value)

    def thermalConductance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_thermalConductance(self)

    def setThermalConductance(self, value: 'double') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_setThermalConductance(self, value)

    def heatCapacity(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_heatCapacity(self)

    def interiorVisibleAbsorptance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_interiorVisibleAbsorptance(self)

    def interiorVisibleAbsorbtance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_interiorVisibleAbsorbtance(self)

    def exteriorVisibleAbsorptance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_exteriorVisibleAbsorptance(self)

    def exteriorVisibleAbsorbtance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_exteriorVisibleAbsorbtance(self)

    def visibleTransmittance(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.PlanarSurface_visibleTransmittance(self)

    def equalVertices(self, other: 'PlanarSurface') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_equalVertices(self, other)

    def reverseEqualVertices(self, other: 'PlanarSurface') -> "bool":
        return _openstudiomodelgeometry.PlanarSurface_reverseEqualVertices(self, other)

    def plane(self) -> "openstudio::Plane":
        return _openstudiomodelgeometry.PlanarSurface_plane(self)

    def triangulation(self) -> "std::vector< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >,std::allocator< std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > > > >":
        return _openstudiomodelgeometry.PlanarSurface_triangulation(self)

    def centroid(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.PlanarSurface_centroid(self)

    def solarCollectors(self) -> "std::vector< openstudio::model::ModelObject,std::allocator< openstudio::model::ModelObject > >":
        return _openstudiomodelgeometry.PlanarSurface_solarCollectors(self)

    def generatorPhotovoltaics(self) -> "std::vector< openstudio::model::GeneratorPhotovoltaic,std::allocator< openstudio::model::GeneratorPhotovoltaic > >":
        return _openstudiomodelgeometry.PlanarSurface_generatorPhotovoltaics(self)

    def surfacePropertyConvectionCoefficients(self) -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
        return _openstudiomodelgeometry.PlanarSurface_surfacePropertyConvectionCoefficients(self)
PlanarSurface_swigregister = _openstudiomodelgeometry.PlanarSurface_swigregister
PlanarSurface_swigregister(PlanarSurface)

def PlanarSurface_findPlanarSurfaces(planarSurfaces: 'PlanarSurfaceVector', minDegreesFromNorth: 'OptionalDouble', maxDegreesFromNorth: 'OptionalDouble', minDegreesTilt: 'OptionalDouble', maxDegreesTilt: 'OptionalDouble', tol: 'double'=1) -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces(planarSurfaces, minDegreesFromNorth, maxDegreesFromNorth, minDegreesTilt, maxDegreesTilt, tol)
PlanarSurface_findPlanarSurfaces = _openstudiomodelgeometry.PlanarSurface_findPlanarSurfaces

def PlanarSurface_filmResistance(type: 'FilmResistanceType') -> "double":
    return _openstudiomodelgeometry.PlanarSurface_filmResistance(type)
PlanarSurface_filmResistance = _openstudiomodelgeometry.PlanarSurface_filmResistance

def PlanarSurface_stillAirFilmResistance(tilt: 'double') -> "double":
    return _openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance(tilt)
PlanarSurface_stillAirFilmResistance = _openstudiomodelgeometry.PlanarSurface_stillAirFilmResistance


def toPlanarSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.toPlanarSurface(idfObject)
toPlanarSurface = _openstudiomodelgeometry.toPlanarSurface

def getPlanarSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.getPlanarSurface(t_model, t_handle)
getPlanarSurface = _openstudiomodelgeometry.getPlanarSurface

def getPlanarSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.getPlanarSurfaces(t_model)
getPlanarSurfaces = _openstudiomodelgeometry.getPlanarSurfaces

def getPlanarSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::PlanarSurface >":
    return _openstudiomodelgeometry.getPlanarSurfaceByName(t_model, t_name)
getPlanarSurfaceByName = _openstudiomodelgeometry.getPlanarSurfaceByName

def getPlanarSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::PlanarSurface,std::allocator< openstudio::model::PlanarSurface > >":
    return _openstudiomodelgeometry.getPlanarSurfacesByName(t_model, t_name, t_exactMatch)
getPlanarSurfacesByName = _openstudiomodelgeometry.getPlanarSurfacesByName
class DefaultConstructionSet(openstudiomodelcore.ResourceObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefaultConstructionSet, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DefaultConstructionSet, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_DefaultConstructionSet(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_DefaultConstructionSet
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.DefaultConstructionSet_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.DefaultConstructionSet_iddObjectType)

    def defaultExteriorSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultExteriorSurfaceConstructions(self)

    def defaultInteriorSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultInteriorSurfaceConstructions(self)

    def defaultGroundContactSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultGroundContactSurfaceConstructions(self)

    def defaultExteriorSubSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSubSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultExteriorSubSurfaceConstructions(self)

    def defaultInteriorSubSurfaceConstructions(self) -> "boost::optional< openstudio::model::DefaultSubSurfaceConstructions >":
        return _openstudiomodelgeometry.DefaultConstructionSet_defaultInteriorSubSurfaceConstructions(self)

    def interiorPartitionConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_interiorPartitionConstruction(self)

    def spaceShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_spaceShadingConstruction(self)

    def buildingShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_buildingShadingConstruction(self)

    def siteShadingConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_siteShadingConstruction(self)

    def setDefaultExteriorSurfaceConstructions(self, defaultSurfaceConstructions: 'DefaultSurfaceConstructions') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultExteriorSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultExteriorSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultExteriorSurfaceConstructions(self)

    def setDefaultInteriorSurfaceConstructions(self, defaultSurfaceConstructions: 'DefaultSurfaceConstructions') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultInteriorSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultInteriorSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultInteriorSurfaceConstructions(self)

    def setDefaultGroundContactSurfaceConstructions(self, defaultSurfaceConstructions: 'DefaultSurfaceConstructions') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultGroundContactSurfaceConstructions(self, defaultSurfaceConstructions)

    def resetDefaultGroundContactSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultGroundContactSurfaceConstructions(self)

    def setDefaultExteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions: 'DefaultSubSurfaceConstructions') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultExteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions)

    def resetDefaultExteriorSubSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultExteriorSubSurfaceConstructions(self)

    def setDefaultInteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions: 'DefaultSubSurfaceConstructions') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setDefaultInteriorSubSurfaceConstructions(self, defaultSubSurfaceConstructions)

    def resetDefaultInteriorSubSurfaceConstructions(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetDefaultInteriorSubSurfaceConstructions(self)

    def setInteriorPartitionConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setInteriorPartitionConstruction(self, construction)

    def resetInteriorPartitionConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetInteriorPartitionConstruction(self)

    def setSpaceShadingConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setSpaceShadingConstruction(self, construction)

    def resetSpaceShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetSpaceShadingConstruction(self)

    def setBuildingShadingConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setBuildingShadingConstruction(self, construction)

    def resetBuildingShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetBuildingShadingConstruction(self)

    def setSiteShadingConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.DefaultConstructionSet_setSiteShadingConstruction(self, construction)

    def resetSiteShadingConstruction(self) -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_resetSiteShadingConstruction(self)

    def getDefaultConstruction(self, planarSurface: 'PlanarSurface') -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.DefaultConstructionSet_getDefaultConstruction(self, planarSurface)

    def merge(self, other: 'DefaultConstructionSet') -> "void":
        return _openstudiomodelgeometry.DefaultConstructionSet_merge(self, other)
DefaultConstructionSet_swigregister = _openstudiomodelgeometry.DefaultConstructionSet_swigregister
DefaultConstructionSet_swigregister(DefaultConstructionSet)

def DefaultConstructionSet_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DefaultConstructionSet_iddObjectType()
DefaultConstructionSet_iddObjectType = _openstudiomodelgeometry.DefaultConstructionSet_iddObjectType


def toDefaultConstructionSet(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.toDefaultConstructionSet(idfObject)
toDefaultConstructionSet = _openstudiomodelgeometry.toDefaultConstructionSet

def getDefaultConstructionSet(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.getDefaultConstructionSet(t_model, t_handle)
getDefaultConstructionSet = _openstudiomodelgeometry.getDefaultConstructionSet

def getDefaultConstructionSets(t_model: 'Model') -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > >":
    return _openstudiomodelgeometry.getDefaultConstructionSets(t_model)
getDefaultConstructionSets = _openstudiomodelgeometry.getDefaultConstructionSets

def getDefaultConstructionSetByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::DefaultConstructionSet >":
    return _openstudiomodelgeometry.getDefaultConstructionSetByName(t_model, t_name)
getDefaultConstructionSetByName = _openstudiomodelgeometry.getDefaultConstructionSetByName

def getDefaultConstructionSetsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::DefaultConstructionSet,std::allocator< openstudio::model::DefaultConstructionSet > >":
    return _openstudiomodelgeometry.getDefaultConstructionSetsByName(t_model, t_name, t_exactMatch)
getDefaultConstructionSetsByName = _openstudiomodelgeometry.getDefaultConstructionSetsByName
class Surface(PlanarSurface):
    __swig_setmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Surface, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Surface, name)
    __repr__ = _swig_repr

    def __init__(self, vertices: 'Point3dVector', model: 'Model'):
        this = _openstudiomodelgeometry.new_Surface(vertices, model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_Surface
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Surface_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Surface_iddObjectType)
    __swig_getmethods__["validSurfaceTypeValues"] = lambda x: _openstudiomodelgeometry.Surface_validSurfaceTypeValues
    if _newclass:
        validSurfaceTypeValues = staticmethod(_openstudiomodelgeometry.Surface_validSurfaceTypeValues)
    __swig_getmethods__["validOutsideBoundaryConditionValues"] = lambda x: _openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues
    if _newclass:
        validOutsideBoundaryConditionValues = staticmethod(_openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues)
    __swig_getmethods__["validSunExposureValues"] = lambda x: _openstudiomodelgeometry.Surface_validSunExposureValues
    if _newclass:
        validSunExposureValues = staticmethod(_openstudiomodelgeometry.Surface_validSunExposureValues)
    __swig_getmethods__["validWindExposureValues"] = lambda x: _openstudiomodelgeometry.Surface_validWindExposureValues
    if _newclass:
        validWindExposureValues = staticmethod(_openstudiomodelgeometry.Surface_validWindExposureValues)

    def surfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_surfaceType(self)

    def outsideBoundaryCondition(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_outsideBoundaryCondition(self)

    def isGroundSurface(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isGroundSurface(self)

    def sunExposure(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_sunExposure(self)

    def isSunExposureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isSunExposureDefaulted(self)

    def windExposure(self) -> "std::string":
        return _openstudiomodelgeometry.Surface_windExposure(self)

    def isWindExposureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isWindExposureDefaulted(self)

    def viewFactortoGround(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Surface_viewFactortoGround(self)

    def isViewFactortoGroundDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isViewFactortoGroundDefaulted(self)

    def isViewFactortoGroundAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isViewFactortoGroundAutocalculated(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.Surface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isNumberofVerticesAutocalculated(self)

    def setSurfaceType(self, surfaceType: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfaceType(self, surfaceType)

    def setOutsideBoundaryCondition(self, outsideBoundaryCondition: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Surface_setOutsideBoundaryCondition(self, outsideBoundaryCondition)

    def setSunExposure(self, sunExposure: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Surface_setSunExposure(self, sunExposure)

    def resetSunExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSunExposure(self)

    def setWindExposure(self, windExposure: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Surface_setWindExposure(self, windExposure)

    def resetWindExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetWindExposure(self)

    def setViewFactortoGround(self, *args) -> "bool":
        return _openstudiomodelgeometry.Surface_setViewFactortoGround(self, *args)

    def resetViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetViewFactortoGround(self)

    def autocalculateViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.Surface_autocalculateViewFactortoGround(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.Surface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.Surface_autocalculateNumberofVertices(self)

    def subSurfaces(self) -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_subSurfaces(self)

    def setSpace(self, space: 'Space') -> "bool":
        return _openstudiomodelgeometry.Surface_setSpace(self, space)

    def adjacentSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.Surface_adjacentSurface(self)

    def setAdjacentSurface(self, surface: 'Surface') -> "bool":
        return _openstudiomodelgeometry.Surface_setAdjacentSurface(self, surface)

    def resetAdjacentSurface(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetAdjacentSurface(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.Surface_surfacePropertyConvectionCoefficients(self)

    def surfacePropertyOtherSideCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
        return _openstudiomodelgeometry.Surface_surfacePropertyOtherSideCoefficients(self)

    def setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients: 'SurfacePropertyOtherSideCoefficients') -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients)

    def resetSurfacePropertyOtherSideCoefficients(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyOtherSideCoefficients(self)

    def surfacePropertyOtherSideConditionsModel(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
        return _openstudiomodelgeometry.Surface_surfacePropertyOtherSideConditionsModel(self)

    def setSurfacePropertyOtherSideConditionsModel(self, otherSideModel: 'SurfacePropertyOtherSideConditionsModel') -> "bool":
        return _openstudiomodelgeometry.Surface_setSurfacePropertyOtherSideConditionsModel(self, otherSideModel)

    def resetSurfacePropertyOtherSideConditionsModel(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyOtherSideConditionsModel(self)

    def intersect(self, otherSurface: 'Surface') -> "bool":
        return _openstudiomodelgeometry.Surface_intersect(self, otherSurface)

    def computeIntersection(self, otherSurface: 'Surface') -> "boost::optional< openstudio::model::SurfaceIntersection >":
        return _openstudiomodelgeometry.Surface_computeIntersection(self, otherSurface)

    def createAdjacentSurface(self, otherSpace: 'Space') -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.Surface_createAdjacentSurface(self, otherSpace)

    def isPartOfEnvelope(self) -> "bool":
        return _openstudiomodelgeometry.Surface_isPartOfEnvelope(self)

    def assignDefaultSurfaceType(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultSurfaceType(self)

    def assignDefaultBoundaryCondition(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultBoundaryCondition(self)

    def assignDefaultSunExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultSunExposure(self)

    def assignDefaultWindExposure(self) -> "void":
        return _openstudiomodelgeometry.Surface_assignDefaultWindExposure(self)

    def filmResistance(self) -> "double":
        return _openstudiomodelgeometry.Surface_filmResistance(self)

    def windowToWallRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_windowToWallRatio(self)

    def skylightToRoofRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_skylightToRoofRatio(self)

    def skylightToProjectedFloorRatio(self) -> "double":
        return _openstudiomodelgeometry.Surface_skylightToProjectedFloorRatio(self)

    def setWindowToWallRatio(self, *args) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.Surface_setWindowToWallRatio(self, *args)

    def applyViewAndDaylightingGlassRatios(self, viewGlassToWallRatio: 'double', daylightingGlassToWallRatio: 'double', desiredViewGlassSillHeight: 'double', desiredDaylightingGlassHeaderHeight: 'double', exteriorShadingProjectionFactor: 'double', interiorShelfProjectionFactor: 'double', viewGlassConstruction: 'OptionalConstructionBase', daylightingGlassConstruction: 'OptionalConstructionBase') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_applyViewAndDaylightingGlassRatios(self, viewGlassToWallRatio, daylightingGlassToWallRatio, desiredViewGlassSillHeight, desiredDaylightingGlassHeaderHeight, exteriorShadingProjectionFactor, interiorShelfProjectionFactor, viewGlassConstruction, daylightingGlassConstruction)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.Surface_shadingSurfaceGroups(self)

    def splitSurfaceForSubSurfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.Surface_splitSurfaceForSubSurfaces(self)

    def createSubSurfaces(self, faces: 'Point3dVectorVector', inset: 'double', construction: 'OptionalConstructionBase') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
        return _openstudiomodelgeometry.Surface_createSubSurfaces(self, faces, inset, construction)

    def getAirflowNetworkSurface(self, *args) -> "openstudio::model::AirflowNetworkSurface":
        return _openstudiomodelgeometry.Surface_getAirflowNetworkSurface(self, *args)

    def airflowNetworkSurface(self) -> "boost::optional< openstudio::model::AirflowNetworkSurface >":
        return _openstudiomodelgeometry.Surface_airflowNetworkSurface(self)

    def setAdjacentFoundation(self, kiva: 'FoundationKiva') -> "bool":
        return _openstudiomodelgeometry.Surface_setAdjacentFoundation(self, kiva)

    def adjacentFoundation(self) -> "boost::optional< openstudio::model::FoundationKiva >":
        return _openstudiomodelgeometry.Surface_adjacentFoundation(self)

    def resetAdjacentFoundation(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetAdjacentFoundation(self)

    def createSurfacePropertyExposedFoundationPerimeter(self, exposedPerimeterCalculationMethod: 'std::string', exposedPerimeter: 'double') -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
        return _openstudiomodelgeometry.Surface_createSurfacePropertyExposedFoundationPerimeter(self, exposedPerimeterCalculationMethod, exposedPerimeter)

    def surfacePropertyExposedFoundationPerimeter(self) -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
        return _openstudiomodelgeometry.Surface_surfacePropertyExposedFoundationPerimeter(self)

    def resetSurfacePropertyExposedFoundationPerimeter(self) -> "void":
        return _openstudiomodelgeometry.Surface_resetSurfacePropertyExposedFoundationPerimeter(self)
Surface_swigregister = _openstudiomodelgeometry.Surface_swigregister
Surface_swigregister(Surface)

def Surface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Surface_iddObjectType()
Surface_iddObjectType = _openstudiomodelgeometry.Surface_iddObjectType

def Surface_validSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validSurfaceTypeValues()
Surface_validSurfaceTypeValues = _openstudiomodelgeometry.Surface_validSurfaceTypeValues

def Surface_validOutsideBoundaryConditionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues()
Surface_validOutsideBoundaryConditionValues = _openstudiomodelgeometry.Surface_validOutsideBoundaryConditionValues

def Surface_validSunExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validSunExposureValues()
Surface_validSunExposureValues = _openstudiomodelgeometry.Surface_validSunExposureValues

def Surface_validWindExposureValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.Surface_validWindExposureValues()
Surface_validWindExposureValues = _openstudiomodelgeometry.Surface_validWindExposureValues

class SurfaceIntersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfaceIntersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SurfaceIntersection, name)
    __repr__ = _swig_repr

    def __init__(self, surface1: 'Surface', surface2: 'Surface', newSurfaces1: 'SurfaceVector', newSurfaces2: 'SurfaceVector'):
        this = _openstudiomodelgeometry.new_SurfaceIntersection(surface1, surface2, newSurfaces1, newSurfaces2)
        try:
            self.this.append(this)
        except:
            self.this = this

    def surface1(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.SurfaceIntersection_surface1(self)

    def surface2(self) -> "openstudio::model::Surface":
        return _openstudiomodelgeometry.SurfaceIntersection_surface2(self)

    def newSurfaces1(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.SurfaceIntersection_newSurfaces1(self)

    def newSurfaces2(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.SurfaceIntersection_newSurfaces2(self)
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfaceIntersection
    __del__ = lambda self: None
SurfaceIntersection_swigregister = _openstudiomodelgeometry.SurfaceIntersection_swigregister
SurfaceIntersection_swigregister(SurfaceIntersection)


def __lshift__(*args) -> "std::ostream &":
    return _openstudiomodelgeometry.__lshift__(*args)
__lshift__ = _openstudiomodelgeometry.__lshift__

def toSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.toSurface(idfObject)
toSurface = _openstudiomodelgeometry.toSurface

def getSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.getSurface(t_model, t_handle)
getSurface = _openstudiomodelgeometry.getSurface

def getSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
    return _openstudiomodelgeometry.getSurfaces(t_model)
getSurfaces = _openstudiomodelgeometry.getSurfaces

def getSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::Surface >":
    return _openstudiomodelgeometry.getSurfaceByName(t_model, t_name)
getSurfaceByName = _openstudiomodelgeometry.getSurfaceByName

def getSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
    return _openstudiomodelgeometry.getSurfacesByName(t_model, t_name, t_exactMatch)
getSurfacesByName = _openstudiomodelgeometry.getSurfacesByName
class SubSurface(PlanarSurface):
    __swig_setmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SubSurface, name)
    __repr__ = _swig_repr

    def __init__(self, vertices: 'Point3dVector', model: 'Model'):
        this = _openstudiomodelgeometry.new_SubSurface(vertices, model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SubSurface
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SubSurface_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SubSurface_iddObjectType)
    __swig_getmethods__["validSubSurfaceTypeValues"] = lambda x: _openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues
    if _newclass:
        validSubSurfaceTypeValues = staticmethod(_openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues)

    def subSurfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.SubSurface_subSurfaceType(self)

    def viewFactortoGround(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SubSurface_viewFactortoGround(self)

    def isViewFactortoGroundDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isViewFactortoGroundDefaulted(self)

    def isViewFactortoGroundAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isViewFactortoGroundAutocalculated(self)

    def allowShadingControl(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowShadingControl(self)

    def shadingControl(self) -> "boost::optional< openstudio::model::ShadingControl >":
        return _openstudiomodelgeometry.SubSurface_shadingControl(self)

    def allowWindowPropertyFrameAndDivider(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowWindowPropertyFrameAndDivider(self)

    def windowPropertyFrameAndDivider(self) -> "boost::optional< openstudio::model::WindowPropertyFrameAndDivider >":
        return _openstudiomodelgeometry.SubSurface_windowPropertyFrameAndDivider(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.SubSurface_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isMultiplierDefaulted(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SubSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_isNumberofVerticesAutocalculated(self)

    def setSubSurfaceType(self, subSurfaceType: 'std::string') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSubSurfaceType(self, subSurfaceType)

    def setViewFactortoGround(self, *args) -> "bool":
        return _openstudiomodelgeometry.SubSurface_setViewFactortoGround(self, *args)

    def resetViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetViewFactortoGround(self)

    def autocalculateViewFactortoGround(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_autocalculateViewFactortoGround(self)

    def setShadingControl(self, shadingControl: 'ShadingControl') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setShadingControl(self, shadingControl)

    def resetShadingControl(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetShadingControl(self)

    def setWindowPropertyFrameAndDivider(self, windowPropertyFrameAndDivider: 'WindowPropertyFrameAndDivider') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setWindowPropertyFrameAndDivider(self, windowPropertyFrameAndDivider)

    def resetWindowPropertyFrameAndDivider(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetWindowPropertyFrameAndDivider(self)

    def setMultiplier(self, multiplShadingControlier: 'double') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setMultiplier(self, multiplShadingControlier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetMultiplier(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.SubSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_autocalculateNumberofVertices(self)

    def surface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.SubSurface_surface(self)

    def setSurface(self, surface: 'Surface') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurface(self, surface)

    def adjacentSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.SubSurface_adjacentSubSurface(self)

    def setAdjacentSubSurface(self, subSurface: 'SubSurface') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setAdjacentSubSurface(self, subSurface)

    def resetAdjacentSubSurface(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetAdjacentSubSurface(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyConvectionCoefficients(self)

    def surfacePropertyOtherSideCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyOtherSideCoefficients(self)

    def setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients: 'SurfacePropertyOtherSideCoefficients') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurfacePropertyOtherSideCoefficients(self, otherSideCoefficients)

    def resetSurfacePropertyOtherSideCoefficients(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetSurfacePropertyOtherSideCoefficients(self)

    def surfacePropertyOtherSideConditionsModel(self) -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
        return _openstudiomodelgeometry.SubSurface_surfacePropertyOtherSideConditionsModel(self)

    def setSurfacePropertyOtherSideConditionsModel(self, otherSideModel: 'SurfacePropertyOtherSideConditionsModel') -> "bool":
        return _openstudiomodelgeometry.SubSurface_setSurfacePropertyOtherSideConditionsModel(self, otherSideModel)

    def resetSurfacePropertyOtherSideConditionsModel(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_resetSurfacePropertyOtherSideConditionsModel(self)

    def assignDefaultSubSurfaceType(self) -> "void":
        return _openstudiomodelgeometry.SubSurface_assignDefaultSubSurfaceType(self)

    def outsideBoundaryCondition(self) -> "std::string":
        return _openstudiomodelgeometry.SubSurface_outsideBoundaryCondition(self)

    def addOverhang(self, depth: 'double', offset: 'double') -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.SubSurface_addOverhang(self, depth, offset)

    def addOverhangByProjectionFactor(self, projectionFactor: 'double', offsetFraction: 'double') -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.SubSurface_addOverhangByProjectionFactor(self, projectionFactor, offsetFraction)

    def shadingSurfaceGroups(self) -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
        return _openstudiomodelgeometry.SubSurface_shadingSurfaceGroups(self)

    def allowDaylightingDeviceShelf(self) -> "bool":
        return _openstudiomodelgeometry.SubSurface_allowDaylightingDeviceShelf(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.SubSurface_daylightingDeviceShelf(self)

    def addDaylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.SubSurface_addDaylightingDeviceShelf(self)

    def getAirflowNetworkSurface(self, *args) -> "openstudio::model::AirflowNetworkSurface":
        return _openstudiomodelgeometry.SubSurface_getAirflowNetworkSurface(self, *args)

    def airflowNetworkSurface(self) -> "boost::optional< openstudio::model::AirflowNetworkSurface >":
        return _openstudiomodelgeometry.SubSurface_airflowNetworkSurface(self)
SubSurface_swigregister = _openstudiomodelgeometry.SubSurface_swigregister
SubSurface_swigregister(SubSurface)

def SubSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SubSurface_iddObjectType()
SubSurface_iddObjectType = _openstudiomodelgeometry.SubSurface_iddObjectType

def SubSurface_validSubSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues()
SubSurface_validSubSurfaceTypeValues = _openstudiomodelgeometry.SubSurface_validSubSurfaceTypeValues


def applySkylightPattern(pattern: 'Point3dVectorVector', spaces: 'SpaceVector', construction: 'OptionalConstructionBase') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.applySkylightPattern(pattern, spaces, construction)
applySkylightPattern = _openstudiomodelgeometry.applySkylightPattern

def toSubSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.toSubSurface(idfObject)
toSubSurface = _openstudiomodelgeometry.toSubSurface

def getSubSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.getSubSurface(t_model, t_handle)
getSubSurface = _openstudiomodelgeometry.getSubSurface

def getSubSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.getSubSurfaces(t_model)
getSubSurfaces = _openstudiomodelgeometry.getSubSurfaces

def getSubSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SubSurface >":
    return _openstudiomodelgeometry.getSubSurfaceByName(t_model, t_name)
getSubSurfaceByName = _openstudiomodelgeometry.getSubSurfaceByName

def getSubSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SubSurface,std::allocator< openstudio::model::SubSurface > >":
    return _openstudiomodelgeometry.getSubSurfacesByName(t_model, t_name, t_exactMatch)
getSubSurfacesByName = _openstudiomodelgeometry.getSubSurfacesByName
class ShadingSurfaceGroup(PlanarSurfaceGroup):
    __swig_setmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShadingSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShadingSurfaceGroup, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_ShadingSurfaceGroup(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurfaceGroup
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType)
    __swig_getmethods__["validShadingSurfaceTypeValues"] = lambda x: _openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues
    if _newclass:
        validShadingSurfaceTypeValues = staticmethod(_openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues)

    def shadingSurfaceType(self) -> "std::string":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadingSurfaceType(self)

    def setShadingSurfaceType(self, shadingSurfaceType: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadingSurfaceType(self, shadingSurfaceType)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_space(self)

    def setSpace(self, space: 'Space') -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_resetSpace(self)

    def shadingSurfaces(self) -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadingSurfaces(self)

    def shadedSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadedSubSurface(self)

    def shadedSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_shadedSurface(self)

    def setShadedSubSurface(self, subSurface: 'SubSurface') -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadedSubSurface(self, subSurface)

    def setShadedSurface(self, surface: 'Surface') -> "bool":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_setShadedSurface(self, surface)

    def resetShadedObject(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurfaceGroup_resetShadedObject(self)
ShadingSurfaceGroup_swigregister = _openstudiomodelgeometry.ShadingSurfaceGroup_swigregister
ShadingSurfaceGroup_swigregister(ShadingSurfaceGroup)

def ShadingSurfaceGroup_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType()
ShadingSurfaceGroup_iddObjectType = _openstudiomodelgeometry.ShadingSurfaceGroup_iddObjectType

def ShadingSurfaceGroup_validShadingSurfaceTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues()
ShadingSurfaceGroup_validShadingSurfaceTypeValues = _openstudiomodelgeometry.ShadingSurfaceGroup_validShadingSurfaceTypeValues


def toShadingSurfaceGroup(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.toShadingSurfaceGroup(idfObject)
toShadingSurfaceGroup = _openstudiomodelgeometry.toShadingSurfaceGroup

def getShadingSurfaceGroup(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.getShadingSurfaceGroup(t_model, t_handle)
getShadingSurfaceGroup = _openstudiomodelgeometry.getShadingSurfaceGroup

def getShadingSurfaceGroups(t_model: 'Model') -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
    return _openstudiomodelgeometry.getShadingSurfaceGroups(t_model)
getShadingSurfaceGroups = _openstudiomodelgeometry.getShadingSurfaceGroups

def getShadingSurfaceGroupByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
    return _openstudiomodelgeometry.getShadingSurfaceGroupByName(t_model, t_name)
getShadingSurfaceGroupByName = _openstudiomodelgeometry.getShadingSurfaceGroupByName

def getShadingSurfaceGroupsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ShadingSurfaceGroup,std::allocator< openstudio::model::ShadingSurfaceGroup > >":
    return _openstudiomodelgeometry.getShadingSurfaceGroupsByName(t_model, t_name, t_exactMatch)
getShadingSurfaceGroupsByName = _openstudiomodelgeometry.getShadingSurfaceGroupsByName
class ShadingSurface(PlanarSurface):
    __swig_setmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShadingSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShadingSurface, name)
    __repr__ = _swig_repr

    def __init__(self, vertices: 'Point3dVector', model: 'Model'):
        this = _openstudiomodelgeometry.new_ShadingSurface(vertices, model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ShadingSurface
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ShadingSurface_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ShadingSurface_iddObjectType)

    def shadingSurfaceGroup(self) -> "boost::optional< openstudio::model::ShadingSurfaceGroup >":
        return _openstudiomodelgeometry.ShadingSurface_shadingSurfaceGroup(self)

    def transmittanceSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ShadingSurface_transmittanceSchedule(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ShadingSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_isNumberofVerticesAutocalculated(self)

    def setShadingSurfaceGroup(self, shadingSurfaceGroup: 'ShadingSurfaceGroup') -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setShadingSurfaceGroup(self, shadingSurfaceGroup)

    def resetShadingSurfaceGroup(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetShadingSurfaceGroup(self)

    def setTransmittanceSchedule(self, transmittanceSchedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setTransmittanceSchedule(self, transmittanceSchedule)

    def resetTransmittanceSchedule(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetTransmittanceSchedule(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.ShadingSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.ShadingSurface_autocalculateNumberofVertices(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.ShadingSurface_daylightingDeviceShelf(self)
ShadingSurface_swigregister = _openstudiomodelgeometry.ShadingSurface_swigregister
ShadingSurface_swigregister(ShadingSurface)

def ShadingSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ShadingSurface_iddObjectType()
ShadingSurface_iddObjectType = _openstudiomodelgeometry.ShadingSurface_iddObjectType


def toShadingSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.toShadingSurface(idfObject)
toShadingSurface = _openstudiomodelgeometry.toShadingSurface

def getShadingSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.getShadingSurface(t_model, t_handle)
getShadingSurface = _openstudiomodelgeometry.getShadingSurface

def getShadingSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
    return _openstudiomodelgeometry.getShadingSurfaces(t_model)
getShadingSurfaces = _openstudiomodelgeometry.getShadingSurfaces

def getShadingSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ShadingSurface >":
    return _openstudiomodelgeometry.getShadingSurfaceByName(t_model, t_name)
getShadingSurfaceByName = _openstudiomodelgeometry.getShadingSurfaceByName

def getShadingSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ShadingSurface,std::allocator< openstudio::model::ShadingSurface > >":
    return _openstudiomodelgeometry.getShadingSurfacesByName(t_model, t_name, t_exactMatch)
getShadingSurfacesByName = _openstudiomodelgeometry.getShadingSurfacesByName
class InteriorPartitionSurfaceGroup(PlanarSurfaceGroup):
    __swig_setmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteriorPartitionSurfaceGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurfaceGroup]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InteriorPartitionSurfaceGroup, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_InteriorPartitionSurfaceGroup(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurfaceGroup
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType)

    def multiplier(self) -> "int":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_isMultiplierDefaulted(self)

    def setMultiplier(self, multiplier: 'int') -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_resetMultiplier(self)

    def space(self) -> "boost::optional< openstudio::model::Space >":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_space(self)

    def setSpace(self, space: 'Space') -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_setSpace(self, space)

    def resetSpace(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_resetSpace(self)

    def interiorPartitionSurfaces(self) -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
        return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_interiorPartitionSurfaces(self)
InteriorPartitionSurfaceGroup_swigregister = _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_swigregister
InteriorPartitionSurfaceGroup_swigregister(InteriorPartitionSurfaceGroup)

def InteriorPartitionSurfaceGroup_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType()
InteriorPartitionSurfaceGroup_iddObjectType = _openstudiomodelgeometry.InteriorPartitionSurfaceGroup_iddObjectType


def toInteriorPartitionSurfaceGroup(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.toInteriorPartitionSurfaceGroup(idfObject)
toInteriorPartitionSurfaceGroup = _openstudiomodelgeometry.toInteriorPartitionSurfaceGroup

def getInteriorPartitionSurfaceGroup(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroup(t_model, t_handle)
getInteriorPartitionSurfaceGroup = _openstudiomodelgeometry.getInteriorPartitionSurfaceGroup

def getInteriorPartitionSurfaceGroups(t_model: 'Model') -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroups(t_model)
getInteriorPartitionSurfaceGroups = _openstudiomodelgeometry.getInteriorPartitionSurfaceGroups

def getInteriorPartitionSurfaceGroupByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupByName(t_model, t_name)
getInteriorPartitionSurfaceGroupByName = _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupByName

def getInteriorPartitionSurfaceGroupsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::InteriorPartitionSurfaceGroup,std::allocator< openstudio::model::InteriorPartitionSurfaceGroup > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupsByName(t_model, t_name, t_exactMatch)
getInteriorPartitionSurfaceGroupsByName = _openstudiomodelgeometry.getInteriorPartitionSurfaceGroupsByName
class InteriorPartitionSurface(PlanarSurface):
    __swig_setmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InteriorPartitionSurface, name, value)
    __swig_getmethods__ = {}
    for _s in [PlanarSurface]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InteriorPartitionSurface, name)
    __repr__ = _swig_repr

    def __init__(self, vertices: 'Point3dVector', model: 'Model'):
        this = _openstudiomodelgeometry.new_InteriorPartitionSurface(vertices, model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_InteriorPartitionSurface
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType)

    def converttoInternalMass(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_converttoInternalMass(self)

    def isConverttoInternalMassDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isConverttoInternalMassDefaulted(self)

    def surfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_surfaceArea(self)

    def numberofVertices(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_numberofVertices(self)

    def isNumberofVerticesDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isNumberofVerticesDefaulted(self)

    def isNumberofVerticesAutocalculated(self) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_isNumberofVerticesAutocalculated(self)

    def setConverttoInternalMass(self, converttoInternalMass: 'bool') -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setConverttoInternalMass(self, converttoInternalMass)

    def resetConverttoInternalMass(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetConverttoInternalMass(self)

    def setSurfaceArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setSurfaceArea(self, *args)

    def resetSurfaceArea(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetSurfaceArea(self)

    def setNumberofVertices(self, *args) -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setNumberofVertices(self, *args)

    def resetNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetNumberofVertices(self)

    def autocalculateNumberofVertices(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_autocalculateNumberofVertices(self)

    def interiorPartitionSurfaceGroup(self) -> "boost::optional< openstudio::model::InteriorPartitionSurfaceGroup >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_interiorPartitionSurfaceGroup(self)

    def setInteriorPartitionSurfaceGroup(self, interiorPartitionSurfaceGroup: 'InteriorPartitionSurfaceGroup') -> "bool":
        return _openstudiomodelgeometry.InteriorPartitionSurface_setInteriorPartitionSurfaceGroup(self, interiorPartitionSurfaceGroup)

    def resetInteriorPartitionSurfaceGroup(self) -> "void":
        return _openstudiomodelgeometry.InteriorPartitionSurface_resetInteriorPartitionSurfaceGroup(self)

    def daylightingDeviceShelf(self) -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
        return _openstudiomodelgeometry.InteriorPartitionSurface_daylightingDeviceShelf(self)
InteriorPartitionSurface_swigregister = _openstudiomodelgeometry.InteriorPartitionSurface_swigregister
InteriorPartitionSurface_swigregister(InteriorPartitionSurface)

def InteriorPartitionSurface_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType()
InteriorPartitionSurface_iddObjectType = _openstudiomodelgeometry.InteriorPartitionSurface_iddObjectType


def toInteriorPartitionSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.toInteriorPartitionSurface(idfObject)
toInteriorPartitionSurface = _openstudiomodelgeometry.toInteriorPartitionSurface

def getInteriorPartitionSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.getInteriorPartitionSurface(t_model, t_handle)
getInteriorPartitionSurface = _openstudiomodelgeometry.getInteriorPartitionSurface

def getInteriorPartitionSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaces(t_model)
getInteriorPartitionSurfaces = _openstudiomodelgeometry.getInteriorPartitionSurfaces

def getInteriorPartitionSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfaceByName(t_model, t_name)
getInteriorPartitionSurfaceByName = _openstudiomodelgeometry.getInteriorPartitionSurfaceByName

def getInteriorPartitionSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::InteriorPartitionSurface,std::allocator< openstudio::model::InteriorPartitionSurface > >":
    return _openstudiomodelgeometry.getInteriorPartitionSurfacesByName(t_model, t_name, t_exactMatch)
getInteriorPartitionSurfacesByName = _openstudiomodelgeometry.getInteriorPartitionSurfacesByName
class SurfacePropertyOtherSideCoefficients(openstudiomodelcore.ResourceObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyOtherSideCoefficients, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyOtherSideCoefficients, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_SurfacePropertyOtherSideCoefficients(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideCoefficients
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType)

    def combinedConvectiveRadiativeFilmCoefficient(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_combinedConvectiveRadiativeFilmCoefficient(self)

    def constantTemperature(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperature(self)

    def isConstantTemperatureDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isConstantTemperatureDefaulted(self)

    def constantTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperatureCoefficient(self)

    def isConstantTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isConstantTemperatureCoefficientDefaulted(self)

    def externalDryBulbTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_externalDryBulbTemperatureCoefficient(self)

    def isExternalDryBulbTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isExternalDryBulbTemperatureCoefficientDefaulted(self)

    def groundTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_groundTemperatureCoefficient(self)

    def isGroundTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isGroundTemperatureCoefficientDefaulted(self)

    def windSpeedCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_windSpeedCoefficient(self)

    def isWindSpeedCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isWindSpeedCoefficientDefaulted(self)

    def zoneAirTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_zoneAirTemperatureCoefficient(self)

    def isZoneAirTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isZoneAirTemperatureCoefficientDefaulted(self)

    def constantTemperatureSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_constantTemperatureSchedule(self)

    def sinusoidalVariationofConstantTemperatureCoefficient(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_sinusoidalVariationofConstantTemperatureCoefficient(self)

    def isSinusoidalVariationofConstantTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isSinusoidalVariationofConstantTemperatureCoefficientDefaulted(self)

    def periodofSinusoidalVariation(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_periodofSinusoidalVariation(self)

    def isPeriodofSinusoidalVariationDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isPeriodofSinusoidalVariationDefaulted(self)

    def previousOtherSideTemperatureCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_previousOtherSideTemperatureCoefficient(self)

    def isPreviousOtherSideTemperatureCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_isPreviousOtherSideTemperatureCoefficientDefaulted(self)

    def minimumOtherSideTemperatureLimit(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_minimumOtherSideTemperatureLimit(self)

    def maximumOtherSideTemperatureLimit(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_maximumOtherSideTemperatureLimit(self)

    def setCombinedConvectiveRadiativeFilmCoefficient(self, combinedConvectiveRadiativeFilmCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setCombinedConvectiveRadiativeFilmCoefficient(self, combinedConvectiveRadiativeFilmCoefficient)

    def resetCombinedConvectiveRadiativeFilmCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetCombinedConvectiveRadiativeFilmCoefficient(self)

    def setConstantTemperature(self, constantTemperature: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperature(self, constantTemperature)

    def resetConstantTemperature(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperature(self)

    def setConstantTemperatureCoefficient(self, constantTemperatureCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperatureCoefficient(self, constantTemperatureCoefficient)

    def resetConstantTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperatureCoefficient(self)

    def setExternalDryBulbTemperatureCoefficient(self, externalDryBulbTemperatureCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setExternalDryBulbTemperatureCoefficient(self, externalDryBulbTemperatureCoefficient)

    def resetExternalDryBulbTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetExternalDryBulbTemperatureCoefficient(self)

    def setGroundTemperatureCoefficient(self, groundTemperatureCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setGroundTemperatureCoefficient(self, groundTemperatureCoefficient)

    def resetGroundTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetGroundTemperatureCoefficient(self)

    def setWindSpeedCoefficient(self, windSpeedCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setWindSpeedCoefficient(self, windSpeedCoefficient)

    def resetWindSpeedCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetWindSpeedCoefficient(self)

    def setZoneAirTemperatureCoefficient(self, zoneAirTemperatureCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setZoneAirTemperatureCoefficient(self, zoneAirTemperatureCoefficient)

    def resetZoneAirTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetZoneAirTemperatureCoefficient(self)

    def setConstantTemperatureSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setConstantTemperatureSchedule(self, schedule)

    def resetConstantTemperatureSchedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetConstantTemperatureSchedule(self)

    def setSinusoidalVariationofConstantTemperatureCoefficient(self, sinusoidalVariationofConstantTemperatureCoefficient: 'bool') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setSinusoidalVariationofConstantTemperatureCoefficient(self, sinusoidalVariationofConstantTemperatureCoefficient)

    def resetSinusoidalVariationofConstantTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetSinusoidalVariationofConstantTemperatureCoefficient(self)

    def setPeriodofSinusoidalVariation(self, periodofSinusoidalVariation: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setPeriodofSinusoidalVariation(self, periodofSinusoidalVariation)

    def resetPeriodofSinusoidalVariation(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetPeriodofSinusoidalVariation(self)

    def setPreviousOtherSideTemperatureCoefficient(self, previousOtherSideTemperatureCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setPreviousOtherSideTemperatureCoefficient(self, previousOtherSideTemperatureCoefficient)

    def resetPreviousOtherSideTemperatureCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetPreviousOtherSideTemperatureCoefficient(self)

    def setMinimumOtherSideTemperatureLimit(self, minimumOtherSideTemperatureLimit: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setMinimumOtherSideTemperatureLimit(self, minimumOtherSideTemperatureLimit)

    def resetMinimumOtherSideTemperatureLimit(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetMinimumOtherSideTemperatureLimit(self)

    def setMaximumOtherSideTemperatureLimit(self, maximumOtherSideTemperatureLimit: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_setMaximumOtherSideTemperatureLimit(self, maximumOtherSideTemperatureLimit)

    def resetMaximumOtherSideTemperatureLimit(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_resetMaximumOtherSideTemperatureLimit(self)
SurfacePropertyOtherSideCoefficients_swigregister = _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_swigregister
SurfacePropertyOtherSideCoefficients_swigregister(SurfacePropertyOtherSideCoefficients)

def SurfacePropertyOtherSideCoefficients_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType()
SurfacePropertyOtherSideCoefficients_iddObjectType = _openstudiomodelgeometry.SurfacePropertyOtherSideCoefficients_iddObjectType


def toSurfacePropertyOtherSideCoefficients(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.toSurfacePropertyOtherSideCoefficients(idfObject)
toSurfacePropertyOtherSideCoefficients = _openstudiomodelgeometry.toSurfacePropertyOtherSideCoefficients

def getSurfacePropertyOtherSideCoefficients(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficients(t_model, t_handle)
getSurfacePropertyOtherSideCoefficients = _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficients

def getSurfacePropertyOtherSideCoefficientss(t_model: 'Model') -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientss(t_model)
getSurfacePropertyOtherSideCoefficientss = _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientss

def getSurfacePropertyOtherSideCoefficientsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientsByName(t_model, t_name)
getSurfacePropertyOtherSideCoefficientsByName = _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientsByName

def getSurfacePropertyOtherSideCoefficientssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SurfacePropertyOtherSideCoefficients,std::allocator< openstudio::model::SurfacePropertyOtherSideCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientssByName(t_model, t_name, t_exactMatch)
getSurfacePropertyOtherSideCoefficientssByName = _openstudiomodelgeometry.getSurfacePropertyOtherSideCoefficientssByName
class SurfacePropertyOtherSideConditionsModel(openstudiomodelcore.ResourceObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyOtherSideConditionsModel, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyOtherSideConditionsModel, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_SurfacePropertyOtherSideConditionsModel(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyOtherSideConditionsModel
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType)
    __swig_getmethods__["typeOfModelingValues"] = lambda x: _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues
    if _newclass:
        typeOfModelingValues = staticmethod(_openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues)

    def typeOfModeling(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModeling(self)

    def isTypeOfModelingDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_isTypeOfModelingDefaulted(self)

    def setTypeOfModeling(self, typeOfModeling: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_setTypeOfModeling(self, typeOfModeling)

    def resetTypeOfModeling(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_resetTypeOfModeling(self)
SurfacePropertyOtherSideConditionsModel_swigregister = _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_swigregister
SurfacePropertyOtherSideConditionsModel_swigregister(SurfacePropertyOtherSideConditionsModel)

def SurfacePropertyOtherSideConditionsModel_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType()
SurfacePropertyOtherSideConditionsModel_iddObjectType = _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_iddObjectType

def SurfacePropertyOtherSideConditionsModel_typeOfModelingValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues()
SurfacePropertyOtherSideConditionsModel_typeOfModelingValues = _openstudiomodelgeometry.SurfacePropertyOtherSideConditionsModel_typeOfModelingValues


def toSurfacePropertyOtherSideConditionsModel(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.toSurfacePropertyOtherSideConditionsModel(idfObject)
toSurfacePropertyOtherSideConditionsModel = _openstudiomodelgeometry.toSurfacePropertyOtherSideConditionsModel

def getSurfacePropertyOtherSideConditionsModel(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModel(t_model, t_handle)
getSurfacePropertyOtherSideConditionsModel = _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModel

def getSurfacePropertyOtherSideConditionsModels(t_model: 'Model') -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModels(t_model)
getSurfacePropertyOtherSideConditionsModels = _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModels

def getSurfacePropertyOtherSideConditionsModelByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SurfacePropertyOtherSideConditionsModel >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelByName(t_model, t_name)
getSurfacePropertyOtherSideConditionsModelByName = _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelByName

def getSurfacePropertyOtherSideConditionsModelsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SurfacePropertyOtherSideConditionsModel,std::allocator< openstudio::model::SurfacePropertyOtherSideConditionsModel > >":
    return _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelsByName(t_model, t_name, t_exactMatch)
getSurfacePropertyOtherSideConditionsModelsByName = _openstudiomodelgeometry.getSurfacePropertyOtherSideConditionsModelsByName
class SurfacePropertyConvectionCoefficients(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyConvectionCoefficients, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyConvectionCoefficients, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_SurfacePropertyConvectionCoefficients(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyConvectionCoefficients
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType)
    __swig_getmethods__["convectionCoefficient1LocationValues"] = lambda x: _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues
    if _newclass:
        convectionCoefficient1LocationValues = staticmethod(_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues)
    __swig_getmethods__["convectionCoefficient1TypeValues"] = lambda x: _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues
    if _newclass:
        convectionCoefficient1TypeValues = staticmethod(_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues)
    __swig_getmethods__["convectionCoefficient2LocationValues"] = lambda x: _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues
    if _newclass:
        convectionCoefficient2LocationValues = staticmethod(_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues)
    __swig_getmethods__["convectionCoefficient2TypeValues"] = lambda x: _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues
    if _newclass:
        convectionCoefficient2TypeValues = staticmethod(_openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues)

    def surfaceAsModelObject(self) -> "openstudio::model::ModelObject":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsModelObject(self)

    def surfaceAsSurface(self) -> "boost::optional< openstudio::model::Surface >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsSurface(self)

    def surfaceAsSubSurface(self) -> "boost::optional< openstudio::model::SubSurface >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsSubSurface(self)

    def surfaceAsInternalMass(self) -> "boost::optional< openstudio::model::InternalMass >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_surfaceAsInternalMass(self)

    def convectionCoefficient1Location(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Location(self)

    def convectionCoefficient1Type(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Type(self)

    def convectionCoefficient1(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1(self)

    def convectionCoefficient1Schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1Schedule(self)

    def convectionCoefficient2Location(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Location(self)

    def convectionCoefficient2Type(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Type(self)

    def convectionCoefficient2(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2(self)

    def convectionCoefficient2Schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2Schedule(self)

    def setSurface(self, surface: 'ModelObject') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setSurface(self, surface)

    def setConvectionCoefficient1Location(self, convectionCoefficient1Location: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Location(self, convectionCoefficient1Location)

    def resetConvectionCoefficient1Location(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Location(self)

    def setConvectionCoefficient1Type(self, convectionCoefficient1Type: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Type(self, convectionCoefficient1Type)

    def resetConvectionCoefficient1Type(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Type(self)

    def setConvectionCoefficient1(self, convectionCoefficient1: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1(self, convectionCoefficient1)

    def resetConvectionCoefficient1(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1(self)

    def setConvectionCoefficient1Schedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient1Schedule(self, schedule)

    def resetConvectionCoefficient1Schedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient1Schedule(self)

    def setConvectionCoefficient2Location(self, convectionCoefficient2Location: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Location(self, convectionCoefficient2Location)

    def resetConvectionCoefficient2Location(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Location(self)

    def setConvectionCoefficient2Type(self, convectionCoefficient2Type: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Type(self, convectionCoefficient2Type)

    def resetConvectionCoefficient2Type(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Type(self)

    def setConvectionCoefficient2(self, convectionCoefficient2: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2(self, convectionCoefficient2)

    def resetConvectionCoefficient2(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2(self)

    def setConvectionCoefficient2Schedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_setConvectionCoefficient2Schedule(self, schedule)

    def resetConvectionCoefficient2Schedule(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_resetConvectionCoefficient2Schedule(self)
SurfacePropertyConvectionCoefficients_swigregister = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_swigregister
SurfacePropertyConvectionCoefficients_swigregister(SurfacePropertyConvectionCoefficients)

def SurfacePropertyConvectionCoefficients_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType()
SurfacePropertyConvectionCoefficients_iddObjectType = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_iddObjectType

def SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues()
SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1LocationValues

def SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues()
SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient1TypeValues

def SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues()
SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2LocationValues

def SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues()
SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues = _openstudiomodelgeometry.SurfacePropertyConvectionCoefficients_convectionCoefficient2TypeValues


def toSurfacePropertyConvectionCoefficients(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.toSurfacePropertyConvectionCoefficients(idfObject)
toSurfacePropertyConvectionCoefficients = _openstudiomodelgeometry.toSurfacePropertyConvectionCoefficients

def getSurfacePropertyConvectionCoefficients(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficients(t_model, t_handle)
getSurfacePropertyConvectionCoefficients = _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficients

def getSurfacePropertyConvectionCoefficientss(t_model: 'Model') -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientss(t_model)
getSurfacePropertyConvectionCoefficientss = _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientss

def getSurfacePropertyConvectionCoefficientsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientsByName(t_model, t_name)
getSurfacePropertyConvectionCoefficientsByName = _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientsByName

def getSurfacePropertyConvectionCoefficientssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SurfacePropertyConvectionCoefficients,std::allocator< openstudio::model::SurfacePropertyConvectionCoefficients > >":
    return _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientssByName(t_model, t_name, t_exactMatch)
getSurfacePropertyConvectionCoefficientssByName = _openstudiomodelgeometry.getSurfacePropertyConvectionCoefficientssByName
class People(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, People, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, People, name)
    __repr__ = _swig_repr

    def __init__(self, peopleDefinition: 'PeopleDefinition'):
        this = _openstudiomodelgeometry.new_People(peopleDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_People
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.People_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.People_iddObjectType)

    def peopleDefinition(self) -> "openstudio::model::PeopleDefinition":
        return _openstudiomodelgeometry.People_peopleDefinition(self)

    def numberofPeopleSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_numberofPeopleSchedule(self)

    def isNumberofPeopleScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.People_isNumberofPeopleScheduleDefaulted(self)

    def activityLevelSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_activityLevelSchedule(self)

    def isActivityLevelScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.People_isActivityLevelScheduleDefaulted(self)

    def workEfficiencySchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_workEfficiencySchedule(self)

    def clothingInsulationSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_clothingInsulationSchedule(self)

    def airVelocitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.People_airVelocitySchedule(self)

    def setPeopleDefinition(self, definition: 'PeopleDefinition') -> "bool":
        return _openstudiomodelgeometry.People_setPeopleDefinition(self, definition)

    def setNumberofPeopleSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.People_setNumberofPeopleSchedule(self, schedule)

    def resetNumberofPeopleSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetNumberofPeopleSchedule(self)

    def setActivityLevelSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.People_setActivityLevelSchedule(self, schedule)

    def resetActivityLevelSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetActivityLevelSchedule(self)

    def setWorkEfficiencySchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.People_setWorkEfficiencySchedule(self, schedule)

    def resetWorkEfficiencySchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetWorkEfficiencySchedule(self)

    def setClothingInsulationSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.People_setClothingInsulationSchedule(self, schedule)

    def resetClothingInsulationSchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetClothingInsulationSchedule(self)

    def setAirVelocitySchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.People_setAirVelocitySchedule(self, schedule)

    def resetAirVelocitySchedule(self) -> "void":
        return _openstudiomodelgeometry.People_resetAirVelocitySchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.People_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.People_resetMultiplier(self)

    def numberOfPeople(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_numberOfPeople(self)

    def peoplePerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_peoplePerFloorArea(self)

    def spaceFloorAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.People_spaceFloorAreaPerPerson(self)

    def getNumberOfPeople(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.People_getNumberOfPeople(self, floorArea)

    def getPeoplePerFloorArea(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.People_getPeoplePerFloorArea(self, floorArea)

    def getFloorAreaPerPerson(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.People_getFloorAreaPerPerson(self, floorArea)
People_swigregister = _openstudiomodelgeometry.People_swigregister
People_swigregister(People)

def People_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.People_iddObjectType()
People_iddObjectType = _openstudiomodelgeometry.People_iddObjectType


def toPeople(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.toPeople(idfObject)
toPeople = _openstudiomodelgeometry.toPeople

def getPeople(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.getPeople(t_model, t_handle)
getPeople = _openstudiomodelgeometry.getPeople

def getPeoples(t_model: 'Model') -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
    return _openstudiomodelgeometry.getPeoples(t_model)
getPeoples = _openstudiomodelgeometry.getPeoples

def getPeopleByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::People >":
    return _openstudiomodelgeometry.getPeopleByName(t_model, t_name)
getPeopleByName = _openstudiomodelgeometry.getPeopleByName

def getPeoplesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
    return _openstudiomodelgeometry.getPeoplesByName(t_model, t_name, t_exactMatch)
getPeoplesByName = _openstudiomodelgeometry.getPeoplesByName
class Luminaire(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Luminaire, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Luminaire, name)
    __repr__ = _swig_repr

    def __init__(self, luminaireDefinition: 'LuminaireDefinition'):
        this = _openstudiomodelgeometry.new_Luminaire(luminaireDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_Luminaire
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.Luminaire_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.Luminaire_iddObjectType)

    def luminaireDefinition(self) -> "openstudio::model::LuminaireDefinition":
        return _openstudiomodelgeometry.Luminaire_luminaireDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.Luminaire_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isScheduleDefaulted(self)

    def positionXcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionXcoordinate(self)

    def getPositionXcoordinate(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getPositionXcoordinate(self, returnIP)

    def positionYcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionYcoordinate(self)

    def getPositionYcoordinate(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getPositionYcoordinate(self, returnIP)

    def positionZcoordinate(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_positionZcoordinate(self)

    def getPositionZcoordinate(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getPositionZcoordinate(self, returnIP)

    def psiRotationAroundXaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_psiRotationAroundXaxis(self)

    def getPsiRotationAroundXaxis(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getPsiRotationAroundXaxis(self, returnIP)

    def isPsiRotationAroundXaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isPsiRotationAroundXaxisDefaulted(self)

    def thetaRotationAroundYaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_thetaRotationAroundYaxis(self)

    def getThetaRotationAroundYaxis(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getThetaRotationAroundYaxis(self, returnIP)

    def isThetaRotationAroundYaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isThetaRotationAroundYaxisDefaulted(self)

    def phiRotationAroundZaxis(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_phiRotationAroundZaxis(self)

    def getPhiRotationAroundZaxis(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getPhiRotationAroundZaxis(self, returnIP)

    def isPhiRotationAroundZaxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isPhiRotationAroundZaxisDefaulted(self)

    def fractionReplaceable(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_fractionReplaceable(self)

    def getFractionReplaceable(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.Luminaire_getFractionReplaceable(self, returnIP)

    def isFractionReplaceableDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isFractionReplaceableDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.Luminaire_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.Luminaire_isEndUseSubcategoryDefaulted(self)

    def setLuminaireDefinition(self, definition: 'LuminaireDefinition') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setLuminaireDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetSchedule(self)

    def setPositionXcoordinate(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionXcoordinate(self, *args)

    def setPositionYcoordinate(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionYcoordinate(self, *args)

    def setPositionZcoordinate(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPositionZcoordinate(self, *args)

    def setPsiRotationAroundXaxis(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPsiRotationAroundXaxis(self, *args)

    def resetPsiRotationAroundXaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetPsiRotationAroundXaxis(self)

    def setThetaRotationAroundYaxis(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setThetaRotationAroundYaxis(self, *args)

    def resetThetaRotationAroundYaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetThetaRotationAroundYaxis(self)

    def setPhiRotationAroundZaxis(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPhiRotationAroundZaxis(self, *args)

    def resetPhiRotationAroundZaxis(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetPhiRotationAroundZaxis(self)

    def setFractionReplaceable(self, *args) -> "bool":
        return _openstudiomodelgeometry.Luminaire_setFractionReplaceable(self, *args)

    def resetFractionReplaceable(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetFractionReplaceable(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.Luminaire_resetEndUseSubcategory(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.Luminaire_position(self)

    def setPosition(self, position: 'Point3d') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.Luminaire_transformation(self)

    def setTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.Luminaire_setTransformation(self, transformation)

    def lightingPower(self) -> "double":
        return _openstudiomodelgeometry.Luminaire_lightingPower(self)

    def getPowerPerFloorArea(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.Luminaire_getPowerPerFloorArea(self, floorArea)

    def getPowerPerPerson(self, numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.Luminaire_getPowerPerPerson(self, numPeople)
Luminaire_swigregister = _openstudiomodelgeometry.Luminaire_swigregister
Luminaire_swigregister(Luminaire)

def Luminaire_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.Luminaire_iddObjectType()
Luminaire_iddObjectType = _openstudiomodelgeometry.Luminaire_iddObjectType


def toLuminaire(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.toLuminaire(idfObject)
toLuminaire = _openstudiomodelgeometry.toLuminaire

def getLuminaire(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.getLuminaire(t_model, t_handle)
getLuminaire = _openstudiomodelgeometry.getLuminaire

def getLuminaires(t_model: 'Model') -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
    return _openstudiomodelgeometry.getLuminaires(t_model)
getLuminaires = _openstudiomodelgeometry.getLuminaires

def getLuminaireByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::Luminaire >":
    return _openstudiomodelgeometry.getLuminaireByName(t_model, t_name)
getLuminaireByName = _openstudiomodelgeometry.getLuminaireByName

def getLuminairesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
    return _openstudiomodelgeometry.getLuminairesByName(t_model, t_name, t_exactMatch)
getLuminairesByName = _openstudiomodelgeometry.getLuminairesByName
class ElectricEquipment(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElectricEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElectricEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, electricEquipmentDefinition: 'ElectricEquipmentDefinition'):
        this = _openstudiomodelgeometry.new_ElectricEquipment(electricEquipmentDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ElectricEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ElectricEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ElectricEquipment_iddObjectType)

    def electricEquipmentDefinition(self) -> "openstudio::model::ElectricEquipmentDefinition":
        return _openstudiomodelgeometry.ElectricEquipment_electricEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ElectricEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ElectricEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_isEndUseSubcategoryDefaulted(self)

    def setElectricEquipmentDefinition(self, definition: 'ElectricEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setElectricEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ElectricEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ElectricEquipment_resetEndUseSubcategory(self)

    def designLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_designLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.ElectricEquipment_powerPerPerson(self)

    def getDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.ElectricEquipment_getPowerPerPerson(self, floorArea, numPeople)
ElectricEquipment_swigregister = _openstudiomodelgeometry.ElectricEquipment_swigregister
ElectricEquipment_swigregister(ElectricEquipment)

def ElectricEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ElectricEquipment_iddObjectType()
ElectricEquipment_iddObjectType = _openstudiomodelgeometry.ElectricEquipment_iddObjectType


def toElectricEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.toElectricEquipment(idfObject)
toElectricEquipment = _openstudiomodelgeometry.toElectricEquipment

def getElectricEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.getElectricEquipment(t_model, t_handle)
getElectricEquipment = _openstudiomodelgeometry.getElectricEquipment

def getElectricEquipments(t_model: 'Model') -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
    return _openstudiomodelgeometry.getElectricEquipments(t_model)
getElectricEquipments = _openstudiomodelgeometry.getElectricEquipments

def getElectricEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ElectricEquipment >":
    return _openstudiomodelgeometry.getElectricEquipmentByName(t_model, t_name)
getElectricEquipmentByName = _openstudiomodelgeometry.getElectricEquipmentByName

def getElectricEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
    return _openstudiomodelgeometry.getElectricEquipmentsByName(t_model, t_name, t_exactMatch)
getElectricEquipmentsByName = _openstudiomodelgeometry.getElectricEquipmentsByName
class GasEquipment(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GasEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GasEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, gasEquipmentDefinition: 'GasEquipmentDefinition'):
        this = _openstudiomodelgeometry.new_GasEquipment(gasEquipmentDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_GasEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.GasEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.GasEquipment_iddObjectType)

    def gasEquipmentDefinition(self) -> "openstudio::model::GasEquipmentDefinition":
        return _openstudiomodelgeometry.GasEquipment_gasEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.GasEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.GasEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GasEquipment_isEndUseSubcategoryDefaulted(self)

    def setGasEquipmentDefinition(self, definition: 'GasEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setGasEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.GasEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.GasEquipment_resetEndUseSubcategory(self)

    def designLevel(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_designLevel(self)

    def powerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_powerPerFloorArea(self)

    def powerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GasEquipment_powerPerPerson(self)

    def getDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.GasEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.GasEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.GasEquipment_getPowerPerPerson(self, floorArea, numPeople)
GasEquipment_swigregister = _openstudiomodelgeometry.GasEquipment_swigregister
GasEquipment_swigregister(GasEquipment)

def GasEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.GasEquipment_iddObjectType()
GasEquipment_iddObjectType = _openstudiomodelgeometry.GasEquipment_iddObjectType


def toGasEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.toGasEquipment(idfObject)
toGasEquipment = _openstudiomodelgeometry.toGasEquipment

def getGasEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.getGasEquipment(t_model, t_handle)
getGasEquipment = _openstudiomodelgeometry.getGasEquipment

def getGasEquipments(t_model: 'Model') -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
    return _openstudiomodelgeometry.getGasEquipments(t_model)
getGasEquipments = _openstudiomodelgeometry.getGasEquipments

def getGasEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::GasEquipment >":
    return _openstudiomodelgeometry.getGasEquipmentByName(t_model, t_name)
getGasEquipmentByName = _openstudiomodelgeometry.getGasEquipmentByName

def getGasEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
    return _openstudiomodelgeometry.getGasEquipmentsByName(t_model, t_name, t_exactMatch)
getGasEquipmentsByName = _openstudiomodelgeometry.getGasEquipmentsByName
class HotWaterEquipment(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotWaterEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HotWaterEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, hotWaterEquipmentDefinition: 'HotWaterEquipmentDefinition'):
        this = _openstudiomodelgeometry.new_HotWaterEquipment(hotWaterEquipmentDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_HotWaterEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.HotWaterEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.HotWaterEquipment_iddObjectType)

    def hotWaterEquipmentDefinition(self) -> "openstudio::model::HotWaterEquipmentDefinition":
        return _openstudiomodelgeometry.HotWaterEquipment_hotWaterEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.HotWaterEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.HotWaterEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_isEndUseSubcategoryDefaulted(self)

    def setHotWaterEquipmentDefinition(self, definition: 'HotWaterEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setHotWaterEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.HotWaterEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.HotWaterEquipment_resetEndUseSubcategory(self)

    def getDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.HotWaterEquipment_getPowerPerPerson(self, floorArea, numPeople)
HotWaterEquipment_swigregister = _openstudiomodelgeometry.HotWaterEquipment_swigregister
HotWaterEquipment_swigregister(HotWaterEquipment)

def HotWaterEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.HotWaterEquipment_iddObjectType()
HotWaterEquipment_iddObjectType = _openstudiomodelgeometry.HotWaterEquipment_iddObjectType


def toHotWaterEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.toHotWaterEquipment(idfObject)
toHotWaterEquipment = _openstudiomodelgeometry.toHotWaterEquipment

def getHotWaterEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.getHotWaterEquipment(t_model, t_handle)
getHotWaterEquipment = _openstudiomodelgeometry.getHotWaterEquipment

def getHotWaterEquipments(t_model: 'Model') -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
    return _openstudiomodelgeometry.getHotWaterEquipments(t_model)
getHotWaterEquipments = _openstudiomodelgeometry.getHotWaterEquipments

def getHotWaterEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::HotWaterEquipment >":
    return _openstudiomodelgeometry.getHotWaterEquipmentByName(t_model, t_name)
getHotWaterEquipmentByName = _openstudiomodelgeometry.getHotWaterEquipmentByName

def getHotWaterEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
    return _openstudiomodelgeometry.getHotWaterEquipmentsByName(t_model, t_name, t_exactMatch)
getHotWaterEquipmentsByName = _openstudiomodelgeometry.getHotWaterEquipmentsByName
class SteamEquipment(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SteamEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SteamEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, definition: 'SteamEquipmentDefinition'):
        this = _openstudiomodelgeometry.new_SteamEquipment(definition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SteamEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SteamEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SteamEquipment_iddObjectType)

    def steamEquipmentDefinition(self) -> "openstudio::model::SteamEquipmentDefinition":
        return _openstudiomodelgeometry.SteamEquipment_steamEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SteamEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_isScheduleDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.SteamEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_isEndUseSubcategoryDefaulted(self)

    def setSteamEquipmentDefinition(self, definition: 'SteamEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setSteamEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.SteamEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.SteamEquipment_resetEndUseSubcategory(self)

    def getDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SteamEquipment_getPowerPerPerson(self, floorArea, numPeople)
SteamEquipment_swigregister = _openstudiomodelgeometry.SteamEquipment_swigregister
SteamEquipment_swigregister(SteamEquipment)

def SteamEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SteamEquipment_iddObjectType()
SteamEquipment_iddObjectType = _openstudiomodelgeometry.SteamEquipment_iddObjectType


def toSteamEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.toSteamEquipment(idfObject)
toSteamEquipment = _openstudiomodelgeometry.toSteamEquipment

def getSteamEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.getSteamEquipment(t_model, t_handle)
getSteamEquipment = _openstudiomodelgeometry.getSteamEquipment

def getSteamEquipments(t_model: 'Model') -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
    return _openstudiomodelgeometry.getSteamEquipments(t_model)
getSteamEquipments = _openstudiomodelgeometry.getSteamEquipments

def getSteamEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SteamEquipment >":
    return _openstudiomodelgeometry.getSteamEquipmentByName(t_model, t_name)
getSteamEquipmentByName = _openstudiomodelgeometry.getSteamEquipmentByName

def getSteamEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
    return _openstudiomodelgeometry.getSteamEquipmentsByName(t_model, t_name, t_exactMatch)
getSteamEquipmentsByName = _openstudiomodelgeometry.getSteamEquipmentsByName
class OtherEquipment(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OtherEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OtherEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, definition: 'OtherEquipmentDefinition'):
        this = _openstudiomodelgeometry.new_OtherEquipment(definition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_OtherEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.OtherEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.OtherEquipment_iddObjectType)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.OtherEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isEndUseSubcategoryDefaulted(self)
    __swig_getmethods__["validFuelTypeValues"] = lambda x: _openstudiomodelgeometry.OtherEquipment_validFuelTypeValues
    if _newclass:
        validFuelTypeValues = staticmethod(_openstudiomodelgeometry.OtherEquipment_validFuelTypeValues)

    def fuelType(self) -> "std::string":
        return _openstudiomodelgeometry.OtherEquipment_fuelType(self)

    def isFuelTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isFuelTypeDefaulted(self)

    def otherEquipmentDefinition(self) -> "openstudio::model::OtherEquipmentDefinition":
        return _openstudiomodelgeometry.OtherEquipment_otherEquipmentDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.OtherEquipment_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_isScheduleDefaulted(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetEndUseSubcategory(self)

    def setFuelType(self, fuelType: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setFuelType(self, fuelType)

    def resetFuelType(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetFuelType(self)

    def setOtherEquipmentDefinition(self, definition: 'OtherEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setOtherEquipmentDefinition(self, definition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.OtherEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.OtherEquipment_resetMultiplier(self)

    def getDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getDesignLevel(self, floorArea, numPeople)

    def getPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getPowerPerFloorArea(self, floorArea, numPeople)

    def getPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.OtherEquipment_getPowerPerPerson(self, floorArea, numPeople)
OtherEquipment_swigregister = _openstudiomodelgeometry.OtherEquipment_swigregister
OtherEquipment_swigregister(OtherEquipment)

def OtherEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.OtherEquipment_iddObjectType()
OtherEquipment_iddObjectType = _openstudiomodelgeometry.OtherEquipment_iddObjectType

def OtherEquipment_validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.OtherEquipment_validFuelTypeValues()
OtherEquipment_validFuelTypeValues = _openstudiomodelgeometry.OtherEquipment_validFuelTypeValues


def toOtherEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.toOtherEquipment(idfObject)
toOtherEquipment = _openstudiomodelgeometry.toOtherEquipment

def getOtherEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.getOtherEquipment(t_model, t_handle)
getOtherEquipment = _openstudiomodelgeometry.getOtherEquipment

def getOtherEquipments(t_model: 'Model') -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
    return _openstudiomodelgeometry.getOtherEquipments(t_model)
getOtherEquipments = _openstudiomodelgeometry.getOtherEquipments

def getOtherEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::OtherEquipment >":
    return _openstudiomodelgeometry.getOtherEquipmentByName(t_model, t_name)
getOtherEquipmentByName = _openstudiomodelgeometry.getOtherEquipmentByName

def getOtherEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
    return _openstudiomodelgeometry.getOtherEquipmentsByName(t_model, t_name, t_exactMatch)
getOtherEquipmentsByName = _openstudiomodelgeometry.getOtherEquipmentsByName
class InternalMass(SpaceLoadInstance):
    __swig_setmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InternalMass, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InternalMass, name)
    __repr__ = _swig_repr

    def __init__(self, internalMassDefinition: 'InternalMassDefinition'):
        this = _openstudiomodelgeometry.new_InternalMass(internalMassDefinition)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_InternalMass
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.InternalMass_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.InternalMass_iddObjectType)

    def internalMassDefinition(self) -> "openstudio::model::InternalMassDefinition":
        return _openstudiomodelgeometry.InternalMass_internalMassDefinition(self)

    def surfacePropertyConvectionCoefficients(self) -> "boost::optional< openstudio::model::SurfacePropertyConvectionCoefficients >":
        return _openstudiomodelgeometry.InternalMass_surfacePropertyConvectionCoefficients(self)

    def setInternalMassDefinition(self, definition: 'InternalMassDefinition') -> "bool":
        return _openstudiomodelgeometry.InternalMass_setInternalMassDefinition(self, definition)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.InternalMass_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.InternalMass_resetMultiplier(self)

    def surfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceArea(self)

    def surfaceAreaPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceAreaPerFloorArea(self)

    def surfaceAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.InternalMass_surfaceAreaPerPerson(self)

    def getSurfaceArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceArea(self, floorArea, numPeople)

    def getSurfaceAreaPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceAreaPerFloorArea(self, floorArea, numPeople)

    def getSurfaceAreaPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.InternalMass_getSurfaceAreaPerPerson(self, floorArea, numPeople)
InternalMass_swigregister = _openstudiomodelgeometry.InternalMass_swigregister
InternalMass_swigregister(InternalMass)

def InternalMass_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.InternalMass_iddObjectType()
InternalMass_iddObjectType = _openstudiomodelgeometry.InternalMass_iddObjectType


def toInternalMass(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.toInternalMass(idfObject)
toInternalMass = _openstudiomodelgeometry.toInternalMass

def getInternalMass(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.getInternalMass(t_model, t_handle)
getInternalMass = _openstudiomodelgeometry.getInternalMass

def getInternalMasss(t_model: 'Model') -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
    return _openstudiomodelgeometry.getInternalMasss(t_model)
getInternalMasss = _openstudiomodelgeometry.getInternalMasss

def getInternalMassByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::InternalMass >":
    return _openstudiomodelgeometry.getInternalMassByName(t_model, t_name)
getInternalMassByName = _openstudiomodelgeometry.getInternalMassByName

def getInternalMasssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
    return _openstudiomodelgeometry.getInternalMasssByName(t_model, t_name, t_exactMatch)
getInternalMasssByName = _openstudiomodelgeometry.getInternalMasssByName
class SpaceInfiltrationDesignFlowRate(SpaceLoad):
    __swig_setmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceInfiltrationDesignFlowRate, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceInfiltrationDesignFlowRate, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_SpaceInfiltrationDesignFlowRate(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationDesignFlowRate
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType)
    __swig_getmethods__["validDesignFlowRateCalculationMethodValues"] = lambda x: _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues
    if _newclass:
        validDesignFlowRateCalculationMethodValues = staticmethod(_openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues)
    __swig_getmethods__["designFlowRateCalculationMethodValues"] = lambda x: _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues
    if _newclass:
        designFlowRateCalculationMethodValues = staticmethod(_openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isScheduleDefaulted(self)

    def designFlowRateCalculationMethod(self) -> "std::string":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethod(self)

    def designFlowRate(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRate(self)

    def flowperSpaceFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperSpaceFloorArea(self)

    def flowperExteriorSurfaceArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperExteriorSurfaceArea(self)

    def flowperExteriorWallArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_flowperExteriorWallArea(self)

    def airChangesperHour(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_airChangesperHour(self)

    def constantTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_constantTermCoefficient(self)

    def isConstantTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isConstantTermCoefficientDefaulted(self)

    def temperatureTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_temperatureTermCoefficient(self)

    def isTemperatureTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isTemperatureTermCoefficientDefaulted(self)

    def velocityTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_velocityTermCoefficient(self)

    def isVelocityTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isVelocityTermCoefficientDefaulted(self)

    def velocitySquaredTermCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_velocitySquaredTermCoefficient(self)

    def isVelocitySquaredTermCoefficientDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_isVelocitySquaredTermCoefficientDefaulted(self)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetSchedule(self)

    def setDesignFlowRate(self, designFlowRate: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setDesignFlowRate(self, designFlowRate)

    def setFlowperSpaceFloorArea(self, flowperSpaceFloorArea: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperSpaceFloorArea(self, flowperSpaceFloorArea)

    def setFlowperExteriorSurfaceArea(self, flowperExteriorSurfaceArea: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperExteriorSurfaceArea(self, flowperExteriorSurfaceArea)

    def setFlowperExteriorWallArea(self, flowperExteriorWallArea: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setFlowperExteriorWallArea(self, flowperExteriorWallArea)

    def setAirChangesperHour(self, airChangesperHour: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setAirChangesperHour(self, airChangesperHour)

    def setConstantTermCoefficient(self, constantTermCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setConstantTermCoefficient(self, constantTermCoefficient)

    def resetConstantTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetConstantTermCoefficient(self)

    def setTemperatureTermCoefficient(self, temperatureTermCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setTemperatureTermCoefficient(self, temperatureTermCoefficient)

    def resetTemperatureTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetTemperatureTermCoefficient(self)

    def setVelocityTermCoefficient(self, velocityTermCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setVelocityTermCoefficient(self, velocityTermCoefficient)

    def resetVelocityTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetVelocityTermCoefficient(self)

    def setVelocitySquaredTermCoefficient(self, velocitySquaredTermCoefficient: 'double') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_setVelocitySquaredTermCoefficient(self, velocitySquaredTermCoefficient)

    def resetVelocitySquaredTermCoefficient(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_resetVelocitySquaredTermCoefficient(self)

    def getDesignFlowRate(self, floorArea: 'double', exteriorSurfaceArea: 'double', exteriorWallArea: 'double', airVolume: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getDesignFlowRate(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerSpaceFloorArea(self, floorArea: 'double', exteriorSurfaceArea: 'double', exteriorWallArea: 'double', airVolume: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerSpaceFloorArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerExteriorSurfaceArea(self, floorArea: 'double', exteriorSurfaceArea: 'double', exteriorWallArea: 'double', airVolume: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerExteriorSurfaceArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getFlowPerExteriorWallArea(self, floorArea: 'double', exteriorSurfaceArea: 'double', exteriorWallArea: 'double', airVolume: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getFlowPerExteriorWallArea(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)

    def getAirChangesPerHour(self, floorArea: 'double', exteriorSurfaceArea: 'double', exteriorWallArea: 'double', airVolume: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_getAirChangesPerHour(self, floorArea, exteriorSurfaceArea, exteriorWallArea, airVolume)
SpaceInfiltrationDesignFlowRate_swigregister = _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_swigregister
SpaceInfiltrationDesignFlowRate_swigregister(SpaceInfiltrationDesignFlowRate)

def SpaceInfiltrationDesignFlowRate_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType()
SpaceInfiltrationDesignFlowRate_iddObjectType = _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_iddObjectType

def SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues()
SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues = _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_validDesignFlowRateCalculationMethodValues

def SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues()
SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues = _openstudiomodelgeometry.SpaceInfiltrationDesignFlowRate_designFlowRateCalculationMethodValues


def toSpaceInfiltrationDesignFlowRate(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.toSpaceInfiltrationDesignFlowRate(idfObject)
toSpaceInfiltrationDesignFlowRate = _openstudiomodelgeometry.toSpaceInfiltrationDesignFlowRate

def getSpaceInfiltrationDesignFlowRate(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRate(t_model, t_handle)
getSpaceInfiltrationDesignFlowRate = _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRate

def getSpaceInfiltrationDesignFlowRates(t_model: 'Model') -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRates(t_model)
getSpaceInfiltrationDesignFlowRates = _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRates

def getSpaceInfiltrationDesignFlowRateByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceInfiltrationDesignFlowRate >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRateByName(t_model, t_name)
getSpaceInfiltrationDesignFlowRateByName = _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRateByName

def getSpaceInfiltrationDesignFlowRatesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRatesByName(t_model, t_name, t_exactMatch)
getSpaceInfiltrationDesignFlowRatesByName = _openstudiomodelgeometry.getSpaceInfiltrationDesignFlowRatesByName
class SpaceInfiltrationEffectiveLeakageArea(SpaceLoad):
    __swig_setmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceInfiltrationEffectiveLeakageArea, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceLoad]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceInfiltrationEffectiveLeakageArea, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_SpaceInfiltrationEffectiveLeakageArea(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceInfiltrationEffectiveLeakageArea
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_schedule(self)

    def isScheduleDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_isScheduleDefaulted(self)

    def effectiveAirLeakageArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_effectiveAirLeakageArea(self)

    def getEffectiveAirLeakageArea(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_getEffectiveAirLeakageArea(self, returnIP)

    def stackCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_stackCoefficient(self)

    def getStackCoefficient(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_getStackCoefficient(self, returnIP)

    def windCoefficient(self) -> "double":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_windCoefficient(self)

    def getWindCoefficient(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_getWindCoefficient(self, returnIP)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_resetSchedule(self)

    def setEffectiveAirLeakageArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setEffectiveAirLeakageArea(self, *args)

    def setStackCoefficient(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setStackCoefficient(self, *args)

    def setWindCoefficient(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_setWindCoefficient(self, *args)
SpaceInfiltrationEffectiveLeakageArea_swigregister = _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_swigregister
SpaceInfiltrationEffectiveLeakageArea_swigregister(SpaceInfiltrationEffectiveLeakageArea)

def SpaceInfiltrationEffectiveLeakageArea_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType()
SpaceInfiltrationEffectiveLeakageArea_iddObjectType = _openstudiomodelgeometry.SpaceInfiltrationEffectiveLeakageArea_iddObjectType


def toSpaceInfiltrationEffectiveLeakageArea(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.toSpaceInfiltrationEffectiveLeakageArea(idfObject)
toSpaceInfiltrationEffectiveLeakageArea = _openstudiomodelgeometry.toSpaceInfiltrationEffectiveLeakageArea

def getSpaceInfiltrationEffectiveLeakageArea(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageArea(t_model, t_handle)
getSpaceInfiltrationEffectiveLeakageArea = _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageArea

def getSpaceInfiltrationEffectiveLeakageAreas(t_model: 'Model') -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreas(t_model)
getSpaceInfiltrationEffectiveLeakageAreas = _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreas

def getSpaceInfiltrationEffectiveLeakageAreaByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceInfiltrationEffectiveLeakageArea >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreaByName(t_model, t_name)
getSpaceInfiltrationEffectiveLeakageAreaByName = _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreaByName

def getSpaceInfiltrationEffectiveLeakageAreasByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
    return _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreasByName(t_model, t_name, t_exactMatch)
getSpaceInfiltrationEffectiveLeakageAreasByName = _openstudiomodelgeometry.getSpaceInfiltrationEffectiveLeakageAreasByName
class DaylightingControl(SpaceItem):
    __swig_setmethods__ = {}
    for _s in [SpaceItem]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaylightingControl, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceItem]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DaylightingControl, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_DaylightingControl(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingControl
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.DaylightingControl_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.DaylightingControl_iddObjectType)
    __swig_getmethods__["validLightingControlTypeValues"] = lambda x: _openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues
    if _newclass:
        validLightingControlTypeValues = staticmethod(_openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues)

    def positionXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionXCoordinate(self)

    def positionYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionYCoordinate(self)

    def positionZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_positionZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPhiRotationAroundZAxisDefaulted(self)

    def illuminanceSetpoint(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_illuminanceSetpoint(self)

    def isIlluminanceSetpointDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isIlluminanceSetpointDefaulted(self)

    def lightingControlType(self) -> "std::string":
        return _openstudiomodelgeometry.DaylightingControl_lightingControlType(self)

    def isLightingControlTypeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isLightingControlTypeDefaulted(self)

    def minimumInputPowerFractionforContinuousDimmingControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_minimumInputPowerFractionforContinuousDimmingControl(self)

    def isMinimumInputPowerFractionforContinuousDimmingControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isMinimumInputPowerFractionforContinuousDimmingControlDefaulted(self)

    def minimumLightOutputFractionforContinuousDimmingControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_minimumLightOutputFractionforContinuousDimmingControl(self)

    def isMinimumLightOutputFractionforContinuousDimmingControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isMinimumLightOutputFractionforContinuousDimmingControlDefaulted(self)

    def numberofSteppedControlSteps(self) -> "int":
        return _openstudiomodelgeometry.DaylightingControl_numberofSteppedControlSteps(self)

    def isNumberofSteppedControlStepsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isNumberofSteppedControlStepsDefaulted(self)

    def probabilityLightingwillbeResetWhenNeededinManualSteppedControl(self) -> "double":
        return _openstudiomodelgeometry.DaylightingControl_probabilityLightingwillbeResetWhenNeededinManualSteppedControl(self)

    def isProbabilityLightingwillbeResetWhenNeededinManualSteppedControlDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isProbabilityLightingwillbeResetWhenNeededinManualSteppedControlDefaulted(self)

    def numberofDaylightingViews(self) -> "int":
        return _openstudiomodelgeometry.DaylightingControl_numberofDaylightingViews(self)

    def isNumberofDaylightingViewsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isNumberofDaylightingViewsDefaulted(self)

    def maximumAllowableDiscomfortGlareIndex(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.DaylightingControl_maximumAllowableDiscomfortGlareIndex(self)

    def setPositionXCoordinate(self, positionXCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionXCoordinate(self, positionXCoordinate)

    def setPositionYCoordinate(self, positionYCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionYCoordinate(self, positionYCoordinate)

    def setPositionZCoordinate(self, positionZCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPositionZCoordinate(self, positionZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetPhiRotationAroundZAxis(self)

    def setIlluminanceSetpoint(self, illuminanceSetpoint: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setIlluminanceSetpoint(self, illuminanceSetpoint)

    def resetIlluminanceSetpoint(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetIlluminanceSetpoint(self)

    def setLightingControlType(self, lightingControlType: 'std::string') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setLightingControlType(self, lightingControlType)

    def resetLightingControlType(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetLightingControlType(self)

    def setMinimumInputPowerFractionforContinuousDimmingControl(self, minimumInputPowerFractionforContinuousDimmingControl: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMinimumInputPowerFractionforContinuousDimmingControl(self, minimumInputPowerFractionforContinuousDimmingControl)

    def resetMinimumInputPowerFractionforContinuousDimmingControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMinimumInputPowerFractionforContinuousDimmingControl(self)

    def setMinimumLightOutputFractionforContinuousDimmingControl(self, minimumLightOutputFractionforContinuousDimmingControl: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMinimumLightOutputFractionforContinuousDimmingControl(self, minimumLightOutputFractionforContinuousDimmingControl)

    def resetMinimumLightOutputFractionforContinuousDimmingControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMinimumLightOutputFractionforContinuousDimmingControl(self)

    def setNumberofSteppedControlSteps(self, numberofSteppedControlSteps: 'int') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setNumberofSteppedControlSteps(self, numberofSteppedControlSteps)

    def resetNumberofSteppedControlSteps(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetNumberofSteppedControlSteps(self)

    def setProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self, probabilityLightingwillbeResetWhenNeededinManualSteppedControl: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self, probabilityLightingwillbeResetWhenNeededinManualSteppedControl)

    def resetProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetProbabilityLightingwillbeResetWhenNeededinManualSteppedControl(self)

    def setNumberofDaylightingViews(self, numberofDaylightingViews: 'int') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setNumberofDaylightingViews(self, numberofDaylightingViews)

    def resetNumberofDaylightingViews(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetNumberofDaylightingViews(self)

    def setMaximumAllowableDiscomfortGlareIndex(self, maximumAllowableDiscomfortGlareIndex: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setMaximumAllowableDiscomfortGlareIndex(self, maximumAllowableDiscomfortGlareIndex)

    def resetMaximumAllowableDiscomfortGlareIndex(self) -> "void":
        return _openstudiomodelgeometry.DaylightingControl_resetMaximumAllowableDiscomfortGlareIndex(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.DaylightingControl_position(self)

    def setPosition(self, position: 'Point3d') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.DaylightingControl_transformation(self)

    def setTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_setTransformation(self, transformation)

    def isPrimaryDaylightingControl(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isPrimaryDaylightingControl(self)

    def isSecondaryDaylightingControl(self) -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_isSecondaryDaylightingControl(self)

    def aimAt(self, target: 'Point3d') -> "bool":
        return _openstudiomodelgeometry.DaylightingControl_aimAt(self, target)
DaylightingControl_swigregister = _openstudiomodelgeometry.DaylightingControl_swigregister
DaylightingControl_swigregister(DaylightingControl)

def DaylightingControl_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DaylightingControl_iddObjectType()
DaylightingControl_iddObjectType = _openstudiomodelgeometry.DaylightingControl_iddObjectType

def DaylightingControl_validLightingControlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues()
DaylightingControl_validLightingControlTypeValues = _openstudiomodelgeometry.DaylightingControl_validLightingControlTypeValues


def toDaylightingControl(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.toDaylightingControl(idfObject)
toDaylightingControl = _openstudiomodelgeometry.toDaylightingControl

def getDaylightingControl(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.getDaylightingControl(t_model, t_handle)
getDaylightingControl = _openstudiomodelgeometry.getDaylightingControl

def getDaylightingControls(t_model: 'Model') -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
    return _openstudiomodelgeometry.getDaylightingControls(t_model)
getDaylightingControls = _openstudiomodelgeometry.getDaylightingControls

def getDaylightingControlByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::DaylightingControl >":
    return _openstudiomodelgeometry.getDaylightingControlByName(t_model, t_name)
getDaylightingControlByName = _openstudiomodelgeometry.getDaylightingControlByName

def getDaylightingControlsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::DaylightingControl,std::allocator< openstudio::model::DaylightingControl > >":
    return _openstudiomodelgeometry.getDaylightingControlsByName(t_model, t_name, t_exactMatch)
getDaylightingControlsByName = _openstudiomodelgeometry.getDaylightingControlsByName
class GlareSensor(SpaceItem):
    __swig_setmethods__ = {}
    for _s in [SpaceItem]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GlareSensor, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceItem]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GlareSensor, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_GlareSensor(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_GlareSensor
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.GlareSensor_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.GlareSensor_iddObjectType)

    def positionXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionXCoordinate(self)

    def positionYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionYCoordinate(self)

    def positionZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_positionZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.GlareSensor_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.GlareSensor_isPhiRotationAroundZAxisDefaulted(self)

    def numberofGlareViewVectors(self) -> "int":
        return _openstudiomodelgeometry.GlareSensor_numberofGlareViewVectors(self)

    def maximumAllowableDaylightGlareProbability(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.GlareSensor_maximumAllowableDaylightGlareProbability(self)

    def setPositionXCoordinate(self, positionXCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionXCoordinate(self, positionXCoordinate)

    def setPositionYCoordinate(self, positionYCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionYCoordinate(self, positionYCoordinate)

    def setPositionZCoordinate(self, positionZCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPositionZCoordinate(self, positionZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetPhiRotationAroundZAxis(self)

    def setNumberofGlareViewVectors(self, numberofGlareViewVectors: 'int') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setNumberofGlareViewVectors(self, numberofGlareViewVectors)

    def resetNumberofGlareViewVectors(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetNumberofGlareViewVectors(self)

    def setMaximumAllowableDaylightGlareProbability(self, maximumAllowableDaylightGlareProbability: 'double') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setMaximumAllowableDaylightGlareProbability(self, maximumAllowableDaylightGlareProbability)

    def resetMaximumAllowableDaylightGlareProbability(self) -> "void":
        return _openstudiomodelgeometry.GlareSensor_resetMaximumAllowableDaylightGlareProbability(self)

    def position(self) -> "openstudio::Point3d":
        return _openstudiomodelgeometry.GlareSensor_position(self)

    def setPosition(self, position: 'Point3d') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setPosition(self, position)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.GlareSensor_transformation(self)

    def setTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_setTransformation(self, transformation)

    def aimAt(self, target: 'Point3d') -> "bool":
        return _openstudiomodelgeometry.GlareSensor_aimAt(self, target)
GlareSensor_swigregister = _openstudiomodelgeometry.GlareSensor_swigregister
GlareSensor_swigregister(GlareSensor)

def GlareSensor_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.GlareSensor_iddObjectType()
GlareSensor_iddObjectType = _openstudiomodelgeometry.GlareSensor_iddObjectType


def toGlareSensor(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.toGlareSensor(idfObject)
toGlareSensor = _openstudiomodelgeometry.toGlareSensor

def getGlareSensor(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.getGlareSensor(t_model, t_handle)
getGlareSensor = _openstudiomodelgeometry.getGlareSensor

def getGlareSensors(t_model: 'Model') -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
    return _openstudiomodelgeometry.getGlareSensors(t_model)
getGlareSensors = _openstudiomodelgeometry.getGlareSensors

def getGlareSensorByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::GlareSensor >":
    return _openstudiomodelgeometry.getGlareSensorByName(t_model, t_name)
getGlareSensorByName = _openstudiomodelgeometry.getGlareSensorByName

def getGlareSensorsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::GlareSensor,std::allocator< openstudio::model::GlareSensor > >":
    return _openstudiomodelgeometry.getGlareSensorsByName(t_model, t_name, t_exactMatch)
getGlareSensorsByName = _openstudiomodelgeometry.getGlareSensorsByName
class IlluminanceMap(SpaceItem):
    __swig_setmethods__ = {}
    for _s in [SpaceItem]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IlluminanceMap, name, value)
    __swig_getmethods__ = {}
    for _s in [SpaceItem]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IlluminanceMap, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_IlluminanceMap(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_IlluminanceMap
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.IlluminanceMap_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.IlluminanceMap_iddObjectType)

    def originXCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originXCoordinate(self)

    def originYCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originYCoordinate(self)

    def originZCoordinate(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_originZCoordinate(self)

    def psiRotationAroundXAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_psiRotationAroundXAxis(self)

    def isPsiRotationAroundXAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isPsiRotationAroundXAxisDefaulted(self)

    def thetaRotationAroundYAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_thetaRotationAroundYAxis(self)

    def isThetaRotationAroundYAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isThetaRotationAroundYAxisDefaulted(self)

    def phiRotationAroundZAxis(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_phiRotationAroundZAxis(self)

    def isPhiRotationAroundZAxisDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isPhiRotationAroundZAxisDefaulted(self)

    def xLength(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_xLength(self)

    def isXLengthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isXLengthDefaulted(self)

    def numberofXGridPoints(self) -> "int":
        return _openstudiomodelgeometry.IlluminanceMap_numberofXGridPoints(self)

    def isNumberofXGridPointsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isNumberofXGridPointsDefaulted(self)

    def yLength(self) -> "double":
        return _openstudiomodelgeometry.IlluminanceMap_yLength(self)

    def isYLengthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isYLengthDefaulted(self)

    def numberofYGridPoints(self) -> "int":
        return _openstudiomodelgeometry.IlluminanceMap_numberofYGridPoints(self)

    def isNumberofYGridPointsDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_isNumberofYGridPointsDefaulted(self)

    def setOriginXCoordinate(self, originXCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginXCoordinate(self, originXCoordinate)

    def setOriginYCoordinate(self, originYCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginYCoordinate(self, originYCoordinate)

    def setOriginZCoordinate(self, originZCoordinate: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setOriginZCoordinate(self, originZCoordinate)

    def setPsiRotationAroundXAxis(self, psiRotationAroundXAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setPsiRotationAroundXAxis(self, psiRotationAroundXAxis)

    def resetPsiRotationAroundXAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetPsiRotationAroundXAxis(self)

    def setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setThetaRotationAroundYAxis(self, thetaRotationAroundYAxis)

    def resetThetaRotationAroundYAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetThetaRotationAroundYAxis(self)

    def setPhiRotationAroundZAxis(self, phiRotationAroundZAxis: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setPhiRotationAroundZAxis(self, phiRotationAroundZAxis)

    def resetPhiRotationAroundZAxis(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetPhiRotationAroundZAxis(self)

    def setXLength(self, xLength: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setXLength(self, xLength)

    def resetXLength(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetXLength(self)

    def setNumberofXGridPoints(self, numberofXGridPoints: 'int') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setNumberofXGridPoints(self, numberofXGridPoints)

    def resetNumberofXGridPoints(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetNumberofXGridPoints(self)

    def setYLength(self, yLength: 'double') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setYLength(self, yLength)

    def resetYLength(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetYLength(self)

    def setNumberofYGridPoints(self, numberofYGridPoints: 'int') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setNumberofYGridPoints(self, numberofYGridPoints)

    def resetNumberofYGridPoints(self) -> "void":
        return _openstudiomodelgeometry.IlluminanceMap_resetNumberofYGridPoints(self)

    def transformation(self) -> "openstudio::Transformation":
        return _openstudiomodelgeometry.IlluminanceMap_transformation(self)

    def setTransformation(self, transformation: 'Transformation') -> "bool":
        return _openstudiomodelgeometry.IlluminanceMap_setTransformation(self, transformation)

    def referencePoints(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.IlluminanceMap_referencePoints(self)

    def corners(self) -> "std::vector< openstudio::Point3d,std::allocator< openstudio::Point3d > >":
        return _openstudiomodelgeometry.IlluminanceMap_corners(self)
IlluminanceMap_swigregister = _openstudiomodelgeometry.IlluminanceMap_swigregister
IlluminanceMap_swigregister(IlluminanceMap)

def IlluminanceMap_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.IlluminanceMap_iddObjectType()
IlluminanceMap_iddObjectType = _openstudiomodelgeometry.IlluminanceMap_iddObjectType


def toIlluminanceMap(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.toIlluminanceMap(idfObject)
toIlluminanceMap = _openstudiomodelgeometry.toIlluminanceMap

def getIlluminanceMap(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.getIlluminanceMap(t_model, t_handle)
getIlluminanceMap = _openstudiomodelgeometry.getIlluminanceMap

def getIlluminanceMaps(t_model: 'Model') -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
    return _openstudiomodelgeometry.getIlluminanceMaps(t_model)
getIlluminanceMaps = _openstudiomodelgeometry.getIlluminanceMaps

def getIlluminanceMapByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::IlluminanceMap >":
    return _openstudiomodelgeometry.getIlluminanceMapByName(t_model, t_name)
getIlluminanceMapByName = _openstudiomodelgeometry.getIlluminanceMapByName

def getIlluminanceMapsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::IlluminanceMap,std::allocator< openstudio::model::IlluminanceMap > >":
    return _openstudiomodelgeometry.getIlluminanceMapsByName(t_model, t_name, t_exactMatch)
getIlluminanceMapsByName = _openstudiomodelgeometry.getIlluminanceMapsByName
class DaylightingDeviceShelf(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaylightingDeviceShelf, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DaylightingDeviceShelf, name)
    __repr__ = _swig_repr

    def __init__(self, subSurface: 'SubSurface'):
        this = _openstudiomodelgeometry.new_DaylightingDeviceShelf(subSurface)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_DaylightingDeviceShelf
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType)

    def insideShelf(self) -> "boost::optional< openstudio::model::InteriorPartitionSurface >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_insideShelf(self)

    def outsideShelf(self) -> "boost::optional< openstudio::model::ShadingSurface >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_outsideShelf(self)

    def viewFactortoOutsideShelf(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_viewFactortoOutsideShelf(self)

    def setInsideShelf(self, insideShelf: 'InteriorPartitionSurface') -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setInsideShelf(self, insideShelf)

    def setOutsideShelf(self, outsideShelf: 'ShadingSurface') -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setOutsideShelf(self, outsideShelf)

    def setViewFactortoOutsideShelf(self, viewFactortoOutsideShelf: 'double') -> "bool":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_setViewFactortoOutsideShelf(self, viewFactortoOutsideShelf)

    def resetViewFactortoOutsideShelf(self) -> "void":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_resetViewFactortoOutsideShelf(self)

    def subSurface(self) -> "openstudio::model::SubSurface":
        return _openstudiomodelgeometry.DaylightingDeviceShelf_subSurface(self)
DaylightingDeviceShelf_swigregister = _openstudiomodelgeometry.DaylightingDeviceShelf_swigregister
DaylightingDeviceShelf_swigregister(DaylightingDeviceShelf)

def DaylightingDeviceShelf_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType()
DaylightingDeviceShelf_iddObjectType = _openstudiomodelgeometry.DaylightingDeviceShelf_iddObjectType


def toDaylightingDeviceShelf(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.toDaylightingDeviceShelf(idfObject)
toDaylightingDeviceShelf = _openstudiomodelgeometry.toDaylightingDeviceShelf

def getDaylightingDeviceShelf(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelf(t_model, t_handle)
getDaylightingDeviceShelf = _openstudiomodelgeometry.getDaylightingDeviceShelf

def getDaylightingDeviceShelfs(t_model: 'Model') -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfs(t_model)
getDaylightingDeviceShelfs = _openstudiomodelgeometry.getDaylightingDeviceShelfs

def getDaylightingDeviceShelfByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::DaylightingDeviceShelf >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfByName(t_model, t_name)
getDaylightingDeviceShelfByName = _openstudiomodelgeometry.getDaylightingDeviceShelfByName

def getDaylightingDeviceShelfsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::DaylightingDeviceShelf,std::allocator< openstudio::model::DaylightingDeviceShelf > >":
    return _openstudiomodelgeometry.getDaylightingDeviceShelfsByName(t_model, t_name, t_exactMatch)
getDaylightingDeviceShelfsByName = _openstudiomodelgeometry.getDaylightingDeviceShelfsByName
class SpaceType(openstudiomodelcore.ResourceObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpaceType, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ResourceObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpaceType, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_SpaceType(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SpaceType
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SpaceType_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SpaceType_iddObjectType)

    def defaultConstructionSet(self) -> "boost::optional< openstudio::model::DefaultConstructionSet >":
        return _openstudiomodelgeometry.SpaceType_defaultConstructionSet(self)

    def defaultScheduleSet(self) -> "boost::optional< openstudio::model::DefaultScheduleSet >":
        return _openstudiomodelgeometry.SpaceType_defaultScheduleSet(self)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.SpaceType_renderingColor(self)

    def standardsTemplate(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsTemplate(self)

    def suggestedStandardsTemplates(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsTemplates(self)

    def standardsBuildingType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsBuildingType(self)

    def suggestedStandardsBuildingTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsBuildingTypes(self)

    def standardsSpaceType(self) -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_standardsSpaceType(self)

    def suggestedStandardsSpaceTypes(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudiomodelgeometry.SpaceType_suggestedStandardsSpaceTypes(self)

    def setDefaultConstructionSet(self, defaultConstructionSet: 'DefaultConstructionSet') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDefaultConstructionSet(self, defaultConstructionSet)

    def resetDefaultConstructionSet(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDefaultConstructionSet(self)

    def setDefaultScheduleSet(self, defaultScheduleSet: 'DefaultScheduleSet') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDefaultScheduleSet(self, defaultScheduleSet)

    def resetDefaultScheduleSet(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDefaultScheduleSet(self)

    def setRenderingColor(self, renderingColor: 'RenderingColor') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetRenderingColor(self)

    def setStandardsTemplate(self, standardsTemplate: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsTemplate(self, standardsTemplate)

    def resetStandardsTemplate(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsTemplate(self)

    def setStandardsBuildingType(self, standardsBuildingType: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsBuildingType(self, standardsBuildingType)

    def resetStandardsBuildingType(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsBuildingType(self)

    def setStandardsSpaceType(self, standardsSpaceType: 'std::string const &') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setStandardsSpaceType(self, standardsSpaceType)

    def resetStandardsSpaceType(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetStandardsSpaceType(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.SpaceType_spaces(self)

    def getDefaultSchedule(self, defaultScheduleType: 'DefaultScheduleType') -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.SpaceType_getDefaultSchedule(self, defaultScheduleType)

    def internalMass(self) -> "std::vector< openstudio::model::InternalMass,std::allocator< openstudio::model::InternalMass > >":
        return _openstudiomodelgeometry.SpaceType_internalMass(self)

    def people(self) -> "std::vector< openstudio::model::People,std::allocator< openstudio::model::People > >":
        return _openstudiomodelgeometry.SpaceType_people(self)

    def lights(self) -> "std::vector< openstudio::model::Lights,std::allocator< openstudio::model::Lights > >":
        return _openstudiomodelgeometry.SpaceType_lights(self)

    def luminaires(self) -> "std::vector< openstudio::model::Luminaire,std::allocator< openstudio::model::Luminaire > >":
        return _openstudiomodelgeometry.SpaceType_luminaires(self)

    def electricEquipment(self) -> "std::vector< openstudio::model::ElectricEquipment,std::allocator< openstudio::model::ElectricEquipment > >":
        return _openstudiomodelgeometry.SpaceType_electricEquipment(self)

    def gasEquipment(self) -> "std::vector< openstudio::model::GasEquipment,std::allocator< openstudio::model::GasEquipment > >":
        return _openstudiomodelgeometry.SpaceType_gasEquipment(self)

    def hotWaterEquipment(self) -> "std::vector< openstudio::model::HotWaterEquipment,std::allocator< openstudio::model::HotWaterEquipment > >":
        return _openstudiomodelgeometry.SpaceType_hotWaterEquipment(self)

    def steamEquipment(self) -> "std::vector< openstudio::model::SteamEquipment,std::allocator< openstudio::model::SteamEquipment > >":
        return _openstudiomodelgeometry.SpaceType_steamEquipment(self)

    def otherEquipment(self) -> "std::vector< openstudio::model::OtherEquipment,std::allocator< openstudio::model::OtherEquipment > >":
        return _openstudiomodelgeometry.SpaceType_otherEquipment(self)

    def spaceInfiltrationDesignFlowRates(self) -> "std::vector< openstudio::model::SpaceInfiltrationDesignFlowRate,std::allocator< openstudio::model::SpaceInfiltrationDesignFlowRate > >":
        return _openstudiomodelgeometry.SpaceType_spaceInfiltrationDesignFlowRates(self)

    def spaceInfiltrationEffectiveLeakageAreas(self) -> "std::vector< openstudio::model::SpaceInfiltrationEffectiveLeakageArea,std::allocator< openstudio::model::SpaceInfiltrationEffectiveLeakageArea > >":
        return _openstudiomodelgeometry.SpaceType_spaceInfiltrationEffectiveLeakageAreas(self)

    def designSpecificationOutdoorAir(self) -> "boost::optional< openstudio::model::DesignSpecificationOutdoorAir >":
        return _openstudiomodelgeometry.SpaceType_designSpecificationOutdoorAir(self)

    def isDesignSpecificationOutdoorAirDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SpaceType_isDesignSpecificationOutdoorAirDefaulted(self)

    def setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir: 'DesignSpecificationOutdoorAir') -> "bool":
        return _openstudiomodelgeometry.SpaceType_setDesignSpecificationOutdoorAir(self, designSpecificationOutdoorAir)

    def resetDesignSpecificationOutdoorAir(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_resetDesignSpecificationOutdoorAir(self)

    def hardApplySpaceLoadSchedules(self) -> "void":
        return _openstudiomodelgeometry.SpaceType_hardApplySpaceLoadSchedules(self)

    def peoplePerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_peoplePerFloorArea(self)

    def setPeoplePerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setPeoplePerFloorArea(self, *args)

    def spaceFloorAreaPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_spaceFloorAreaPerPerson(self)

    def setSpaceFloorAreaPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setSpaceFloorAreaPerPerson(self, *args)

    def getNumberOfPeople(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getNumberOfPeople(self, floorArea)

    def getPeoplePerFloorArea(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getPeoplePerFloorArea(self, floorArea)

    def getFloorAreaPerPerson(self, floorArea: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getFloorAreaPerPerson(self, floorArea)

    def lightingPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_lightingPowerPerFloorArea(self)

    def setLightingPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setLightingPowerPerFloorArea(self, *args)

    def lightingPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_lightingPowerPerPerson(self)

    def setLightingPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setLightingPowerPerPerson(self, *args)

    def getLightingPower(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPower(self, floorArea, numPeople)

    def getLightingPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPowerPerFloorArea(self, floorArea, numPeople)

    def getLightingPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getLightingPowerPerPerson(self, floorArea, numPeople)

    def electricEquipmentPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentPowerPerFloorArea(self)

    def setElectricEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setElectricEquipmentPowerPerFloorArea(self, *args)

    def electricEquipmentPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_electricEquipmentPowerPerPerson(self)

    def setElectricEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setElectricEquipmentPowerPerPerson(self, *args)

    def getElectricEquipmentDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentDesignLevel(self, floorArea, numPeople)

    def getElectricEquipmentPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentPowerPerFloorArea(self, floorArea, numPeople)

    def getElectricEquipmentPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getElectricEquipmentPowerPerPerson(self, floorArea, numPeople)

    def gasEquipmentPowerPerFloorArea(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_gasEquipmentPowerPerFloorArea(self)

    def setGasEquipmentPowerPerFloorArea(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setGasEquipmentPowerPerFloorArea(self, *args)

    def gasEquipmentPowerPerPerson(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SpaceType_gasEquipmentPowerPerPerson(self)

    def setGasEquipmentPowerPerPerson(self, *args) -> "bool":
        return _openstudiomodelgeometry.SpaceType_setGasEquipmentPowerPerPerson(self, *args)

    def getGasEquipmentDesignLevel(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentDesignLevel(self, floorArea, numPeople)

    def getGasEquipmentPowerPerFloorArea(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentPowerPerFloorArea(self, floorArea, numPeople)

    def getGasEquipmentPowerPerPerson(self, floorArea: 'double', numPeople: 'double') -> "double":
        return _openstudiomodelgeometry.SpaceType_getGasEquipmentPowerPerPerson(self, floorArea, numPeople)

    def floorArea(self) -> "double":
        return _openstudiomodelgeometry.SpaceType_floorArea(self)

    def setNameProtected(self, newName: 'std::string const &') -> "boost::optional< std::string >":
        return _openstudiomodelgeometry.SpaceType_setNameProtected(self, newName)
SpaceType_swigregister = _openstudiomodelgeometry.SpaceType_swigregister
SpaceType_swigregister(SpaceType)

def SpaceType_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SpaceType_iddObjectType()
SpaceType_iddObjectType = _openstudiomodelgeometry.SpaceType_iddObjectType


def toSpaceType(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.toSpaceType(idfObject)
toSpaceType = _openstudiomodelgeometry.toSpaceType

def getSpaceType(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.getSpaceType(t_model, t_handle)
getSpaceType = _openstudiomodelgeometry.getSpaceType

def getSpaceTypes(t_model: 'Model') -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > >":
    return _openstudiomodelgeometry.getSpaceTypes(t_model)
getSpaceTypes = _openstudiomodelgeometry.getSpaceTypes

def getSpaceTypeByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SpaceType >":
    return _openstudiomodelgeometry.getSpaceTypeByName(t_model, t_name)
getSpaceTypeByName = _openstudiomodelgeometry.getSpaceTypeByName

def getSpaceTypesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SpaceType,std::allocator< openstudio::model::SpaceType > >":
    return _openstudiomodelgeometry.getSpaceTypesByName(t_model, t_name, t_exactMatch)
getSpaceTypesByName = _openstudiomodelgeometry.getSpaceTypesByName
class LightingSimulationZone(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LightingSimulationZone, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LightingSimulationZone, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_LightingSimulationZone(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_LightingSimulationZone
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.LightingSimulationZone_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.LightingSimulationZone_iddObjectType)

    def renderingColor(self) -> "boost::optional< openstudio::model::RenderingColor >":
        return _openstudiomodelgeometry.LightingSimulationZone_renderingColor(self)

    def setRenderingColor(self, renderingColor: 'RenderingColor') -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZone_setRenderingColor(self, renderingColor)

    def resetRenderingColor(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZone_resetRenderingColor(self)

    def spaces(self) -> "std::vector< openstudio::model::Space,std::allocator< openstudio::model::Space > >":
        return _openstudiomodelgeometry.LightingSimulationZone_spaces(self)

    def addSpace(self, space: 'Space') -> "bool":
        return _openstudiomodelgeometry.LightingSimulationZone_addSpace(self, space)

    def resetSpaces(self) -> "void":
        return _openstudiomodelgeometry.LightingSimulationZone_resetSpaces(self)
LightingSimulationZone_swigregister = _openstudiomodelgeometry.LightingSimulationZone_swigregister
LightingSimulationZone_swigregister(LightingSimulationZone)

def LightingSimulationZone_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.LightingSimulationZone_iddObjectType()
LightingSimulationZone_iddObjectType = _openstudiomodelgeometry.LightingSimulationZone_iddObjectType


def toLightingSimulationZone(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.toLightingSimulationZone(idfObject)
toLightingSimulationZone = _openstudiomodelgeometry.toLightingSimulationZone

def getLightingSimulationZone(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.getLightingSimulationZone(t_model, t_handle)
getLightingSimulationZone = _openstudiomodelgeometry.getLightingSimulationZone

def getLightingSimulationZones(t_model: 'Model') -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > >":
    return _openstudiomodelgeometry.getLightingSimulationZones(t_model)
getLightingSimulationZones = _openstudiomodelgeometry.getLightingSimulationZones

def getLightingSimulationZoneByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::LightingSimulationZone >":
    return _openstudiomodelgeometry.getLightingSimulationZoneByName(t_model, t_name)
getLightingSimulationZoneByName = _openstudiomodelgeometry.getLightingSimulationZoneByName

def getLightingSimulationZonesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::LightingSimulationZone,std::allocator< openstudio::model::LightingSimulationZone > >":
    return _openstudiomodelgeometry.getLightingSimulationZonesByName(t_model, t_name, t_exactMatch)
getLightingSimulationZonesByName = _openstudiomodelgeometry.getLightingSimulationZonesByName
class FoundationKiva(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FoundationKiva, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FoundationKiva, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelgeometry.new_FoundationKiva(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_FoundationKiva
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.FoundationKiva_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.FoundationKiva_iddObjectType)

    def interiorHorizontalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationMaterial(self)

    def interiorHorizontalInsulationDepth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationDepth(self)

    def isInteriorHorizontalInsulationDepthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isInteriorHorizontalInsulationDepthDefaulted(self)

    def interiorHorizontalInsulationWidth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_interiorHorizontalInsulationWidth(self)

    def interiorVerticalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_interiorVerticalInsulationMaterial(self)

    def interiorVerticalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_interiorVerticalInsulationDepth(self)

    def exteriorHorizontalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationMaterial(self)

    def exteriorHorizontalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationDepth(self)

    def exteriorHorizontalInsulationWidth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_exteriorHorizontalInsulationWidth(self)

    def isExteriorHorizontalInsulationWidthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isExteriorHorizontalInsulationWidthDefaulted(self)

    def exteriorVerticalInsulationMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorVerticalInsulationMaterial(self)

    def exteriorVerticalInsulationDepth(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.FoundationKiva_exteriorVerticalInsulationDepth(self)

    def wallHeightAboveGrade(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_wallHeightAboveGrade(self)

    def isWallHeightAboveGradeDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isWallHeightAboveGradeDefaulted(self)

    def wallDepthBelowSlab(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_wallDepthBelowSlab(self)

    def isWallDepthBelowSlabDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isWallDepthBelowSlabDefaulted(self)

    def footingWallConstruction(self) -> "boost::optional< openstudio::model::ConstructionBase >":
        return _openstudiomodelgeometry.FoundationKiva_footingWallConstruction(self)

    def footingMaterial(self) -> "boost::optional< openstudio::model::Material >":
        return _openstudiomodelgeometry.FoundationKiva_footingMaterial(self)

    def footingDepth(self) -> "double":
        return _openstudiomodelgeometry.FoundationKiva_footingDepth(self)

    def isFootingDepthDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_isFootingDepthDefaulted(self)

    def surfaces(self) -> "std::vector< openstudio::model::Surface,std::allocator< openstudio::model::Surface > >":
        return _openstudiomodelgeometry.FoundationKiva_surfaces(self)

    def setInteriorHorizontalInsulationMaterial(self, material: 'Material') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationMaterial(self, material)

    def resetInteriorHorizontalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorHorizontalInsulationMaterial(self)

    def setInteriorHorizontalInsulationDepth(self, interiorHorizontalInsulationDepth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationDepth(self, interiorHorizontalInsulationDepth)

    def resetInteriorHorizontalInsulationDepth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorHorizontalInsulationDepth(self)

    def setInteriorHorizontalInsulationWidth(self, interiorHorizontalInsulationWidth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorHorizontalInsulationWidth(self, interiorHorizontalInsulationWidth)

    def setInteriorVerticalInsulationMaterial(self, material: 'Material') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorVerticalInsulationMaterial(self, material)

    def resetInteriorVerticalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetInteriorVerticalInsulationMaterial(self)

    def setInteriorVerticalInsulationDepth(self, interiorVerticalInsulationDepth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setInteriorVerticalInsulationDepth(self, interiorVerticalInsulationDepth)

    def setExteriorHorizontalInsulationMaterial(self, material: 'Material') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationMaterial(self, material)

    def resetExteriorHorizontalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorHorizontalInsulationMaterial(self)

    def setExteriorHorizontalInsulationDepth(self, exteriorHorizontalInsulationDepth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationDepth(self, exteriorHorizontalInsulationDepth)

    def setExteriorHorizontalInsulationWidth(self, exteriorHorizontalInsulationWidth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorHorizontalInsulationWidth(self, exteriorHorizontalInsulationWidth)

    def resetExteriorHorizontalInsulationWidth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorHorizontalInsulationWidth(self)

    def setExteriorVerticalInsulationMaterial(self, material: 'Material') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorVerticalInsulationMaterial(self, material)

    def resetExteriorVerticalInsulationMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetExteriorVerticalInsulationMaterial(self)

    def setExteriorVerticalInsulationDepth(self, exteriorVerticalInsulationDepth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setExteriorVerticalInsulationDepth(self, exteriorVerticalInsulationDepth)

    def setWallHeightAboveGrade(self, wallHeightAboveGrade: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setWallHeightAboveGrade(self, wallHeightAboveGrade)

    def resetWallHeightAboveGrade(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetWallHeightAboveGrade(self)

    def setWallDepthBelowSlab(self, wallDepthBelowSlab: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setWallDepthBelowSlab(self, wallDepthBelowSlab)

    def resetWallDepthBelowSlab(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetWallDepthBelowSlab(self)

    def setFootingWallConstruction(self, construction: 'ConstructionBase') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingWallConstruction(self, construction)

    def resetFootingWallConstruction(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingWallConstruction(self)

    def setFootingMaterial(self, material: 'Material') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingMaterial(self, material)

    def resetFootingMaterial(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingMaterial(self)

    def setFootingDepth(self, footingDepth: 'double') -> "bool":
        return _openstudiomodelgeometry.FoundationKiva_setFootingDepth(self, footingDepth)

    def resetFootingDepth(self) -> "void":
        return _openstudiomodelgeometry.FoundationKiva_resetFootingDepth(self)
FoundationKiva_swigregister = _openstudiomodelgeometry.FoundationKiva_swigregister
FoundationKiva_swigregister(FoundationKiva)

def FoundationKiva_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.FoundationKiva_iddObjectType()
FoundationKiva_iddObjectType = _openstudiomodelgeometry.FoundationKiva_iddObjectType


def toFoundationKiva(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.toFoundationKiva(idfObject)
toFoundationKiva = _openstudiomodelgeometry.toFoundationKiva

def getFoundationKiva(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.getFoundationKiva(t_model, t_handle)
getFoundationKiva = _openstudiomodelgeometry.getFoundationKiva

def getFoundationKivas(t_model: 'Model') -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > >":
    return _openstudiomodelgeometry.getFoundationKivas(t_model)
getFoundationKivas = _openstudiomodelgeometry.getFoundationKivas

def getFoundationKivaByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::FoundationKiva >":
    return _openstudiomodelgeometry.getFoundationKivaByName(t_model, t_name)
getFoundationKivaByName = _openstudiomodelgeometry.getFoundationKivaByName

def getFoundationKivasByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::FoundationKiva,std::allocator< openstudio::model::FoundationKiva > >":
    return _openstudiomodelgeometry.getFoundationKivasByName(t_model, t_name, t_exactMatch)
getFoundationKivasByName = _openstudiomodelgeometry.getFoundationKivasByName
class SurfacePropertyExposedFoundationPerimeter(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SurfacePropertyExposedFoundationPerimeter, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SurfacePropertyExposedFoundationPerimeter, name)
    __repr__ = _swig_repr

    def __init__(self, surface: 'Surface', exposedPerimeterCalculationMethod: 'std::string', exposedPerimeter: 'double'):
        this = _openstudiomodelgeometry.new_SurfacePropertyExposedFoundationPerimeter(surface, exposedPerimeterCalculationMethod, exposedPerimeter)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_SurfacePropertyExposedFoundationPerimeter
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType)

    def surfaceName(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_surfaceName(self)

    def exposedPerimeterCalculationMethod(self) -> "std::string":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_exposedPerimeterCalculationMethod(self)

    def totalExposedPerimeter(self) -> "boost::optional< double >":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_totalExposedPerimeter(self)

    def exposedPerimeterFraction(self) -> "double":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_exposedPerimeterFraction(self)

    def isExposedPerimeterFractionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_isExposedPerimeterFractionDefaulted(self)

    def setExposedPerimeterCalculationMethod(self, exposedPerimeterCalculationMethod: 'std::string') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setExposedPerimeterCalculationMethod(self, exposedPerimeterCalculationMethod)

    def setTotalExposedPerimeter(self, totalExposedPerimeter: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setTotalExposedPerimeter(self, totalExposedPerimeter)

    def setExposedPerimeterFraction(self, exposedPerimeterFraction: 'double') -> "bool":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_setExposedPerimeterFraction(self, exposedPerimeterFraction)

    def resetExposedPerimeterFraction(self) -> "void":
        return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_resetExposedPerimeterFraction(self)
SurfacePropertyExposedFoundationPerimeter_swigregister = _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_swigregister
SurfacePropertyExposedFoundationPerimeter_swigregister(SurfacePropertyExposedFoundationPerimeter)

def SurfacePropertyExposedFoundationPerimeter_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType()
SurfacePropertyExposedFoundationPerimeter_iddObjectType = _openstudiomodelgeometry.SurfacePropertyExposedFoundationPerimeter_iddObjectType


def toSurfacePropertyExposedFoundationPerimeter(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.toSurfacePropertyExposedFoundationPerimeter(idfObject)
toSurfacePropertyExposedFoundationPerimeter = _openstudiomodelgeometry.toSurfacePropertyExposedFoundationPerimeter

def getSurfacePropertyExposedFoundationPerimeter(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeter(t_model, t_handle)
getSurfacePropertyExposedFoundationPerimeter = _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeter

def getSurfacePropertyExposedFoundationPerimeters(t_model: 'Model') -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeters(t_model)
getSurfacePropertyExposedFoundationPerimeters = _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeters

def getSurfacePropertyExposedFoundationPerimeterByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::SurfacePropertyExposedFoundationPerimeter >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeterByName(t_model, t_name)
getSurfacePropertyExposedFoundationPerimeterByName = _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimeterByName

def getSurfacePropertyExposedFoundationPerimetersByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::SurfacePropertyExposedFoundationPerimeter,std::allocator< openstudio::model::SurfacePropertyExposedFoundationPerimeter > >":
    return _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimetersByName(t_model, t_name, t_exactMatch)
getSurfacePropertyExposedFoundationPerimetersByName = _openstudiomodelgeometry.getSurfacePropertyExposedFoundationPerimetersByName
class ExteriorLoadInstance(openstudiomodelcore.ModelObject):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorLoadInstance, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelcore.ModelObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorLoadInstance, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLoadInstance
    __del__ = lambda self: None

    def definition(self) -> "openstudio::model::ExteriorLoadDefinition":
        return _openstudiomodelgeometry.ExteriorLoadInstance_definition(self)

    def setDefinition(self, definition: 'ExteriorLoadDefinition') -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstance_setDefinition(self, definition)

    def makeUnique(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLoadInstance_makeUnique(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorLoadInstance_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLoadInstance_isMultiplierDefaulted(self)

    def quantity(self) -> "int":
        return _openstudiomodelgeometry.ExteriorLoadInstance_quantity(self)
ExteriorLoadInstance_swigregister = _openstudiomodelgeometry.ExteriorLoadInstance_swigregister
ExteriorLoadInstance_swigregister(ExteriorLoadInstance)


def toExteriorLoadInstance(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.toExteriorLoadInstance(idfObject)
toExteriorLoadInstance = _openstudiomodelgeometry.toExteriorLoadInstance

def getExteriorLoadInstance(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.getExteriorLoadInstance(t_model, t_handle)
getExteriorLoadInstance = _openstudiomodelgeometry.getExteriorLoadInstance

def getExteriorLoadInstances(t_model: 'Model') -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > >":
    return _openstudiomodelgeometry.getExteriorLoadInstances(t_model)
getExteriorLoadInstances = _openstudiomodelgeometry.getExteriorLoadInstances

def getExteriorLoadInstanceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ExteriorLoadInstance >":
    return _openstudiomodelgeometry.getExteriorLoadInstanceByName(t_model, t_name)
getExteriorLoadInstanceByName = _openstudiomodelgeometry.getExteriorLoadInstanceByName

def getExteriorLoadInstancesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ExteriorLoadInstance,std::allocator< openstudio::model::ExteriorLoadInstance > >":
    return _openstudiomodelgeometry.getExteriorLoadInstancesByName(t_model, t_name, t_exactMatch)
getExteriorLoadInstancesByName = _openstudiomodelgeometry.getExteriorLoadInstancesByName
class ExteriorLights(ExteriorLoadInstance):
    __swig_setmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorLights, name, value)
    __swig_getmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorLights, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorLights(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorLights
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ExteriorLights_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ExteriorLights_iddObjectType)
    __swig_getmethods__["controlOptionValues"] = lambda x: _openstudiomodelgeometry.ExteriorLights_controlOptionValues
    if _newclass:
        controlOptionValues = staticmethod(_openstudiomodelgeometry.ExteriorLights_controlOptionValues)
    __swig_getmethods__["validControlOptionValues"] = lambda x: _openstudiomodelgeometry.ExteriorLights_validControlOptionValues
    if _newclass:
        validControlOptionValues = staticmethod(_openstudiomodelgeometry.ExteriorLights_validControlOptionValues)

    def exteriorLightsDefinition(self) -> "openstudio::model::ExteriorLightsDefinition":
        return _openstudiomodelgeometry.ExteriorLights_exteriorLightsDefinition(self)

    def schedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelgeometry.ExteriorLights_schedule(self)

    def controlOption(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorLights_controlOption(self)

    def isControlOptionDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isControlOptionDefaulted(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorLights_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorLights_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_isEndUseSubcategoryDefaulted(self)

    def setExteriorLightsDefinition(self, exteriorLightsDefinition: 'ExteriorLightsDefinition') -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setExteriorLightsDefinition(self, exteriorLightsDefinition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetSchedule(self)

    def setControlOption(self, controlOption: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setControlOption(self, controlOption)

    def resetControlOption(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetControlOption(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ExteriorLights_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorLights_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorLights_facility(self)
ExteriorLights_swigregister = _openstudiomodelgeometry.ExteriorLights_swigregister
ExteriorLights_swigregister(ExteriorLights)

def ExteriorLights_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorLights_iddObjectType()
ExteriorLights_iddObjectType = _openstudiomodelgeometry.ExteriorLights_iddObjectType

def ExteriorLights_controlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorLights_controlOptionValues()
ExteriorLights_controlOptionValues = _openstudiomodelgeometry.ExteriorLights_controlOptionValues

def ExteriorLights_validControlOptionValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorLights_validControlOptionValues()
ExteriorLights_validControlOptionValues = _openstudiomodelgeometry.ExteriorLights_validControlOptionValues


def toExteriorLights(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.toExteriorLights(idfObject)
toExteriorLights = _openstudiomodelgeometry.toExteriorLights

def getExteriorLights(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.getExteriorLights(t_model, t_handle)
getExteriorLights = _openstudiomodelgeometry.getExteriorLights

def getExteriorLightss(t_model: 'Model') -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
    return _openstudiomodelgeometry.getExteriorLightss(t_model)
getExteriorLightss = _openstudiomodelgeometry.getExteriorLightss

def getExteriorLightsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ExteriorLights >":
    return _openstudiomodelgeometry.getExteriorLightsByName(t_model, t_name)
getExteriorLightsByName = _openstudiomodelgeometry.getExteriorLightsByName

def getExteriorLightssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ExteriorLights,std::allocator< openstudio::model::ExteriorLights > >":
    return _openstudiomodelgeometry.getExteriorLightssByName(t_model, t_name, t_exactMatch)
getExteriorLightssByName = _openstudiomodelgeometry.getExteriorLightssByName
class ExteriorFuelEquipment(ExteriorLoadInstance):
    __swig_setmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorFuelEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorFuelEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorFuelEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorFuelEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType)
    __swig_getmethods__["fuelTypeValues"] = lambda x: _openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues
    if _newclass:
        fuelTypeValues = staticmethod(_openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues)
    __swig_getmethods__["validFuelTypeValues"] = lambda x: _openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues
    if _newclass:
        validFuelTypeValues = staticmethod(_openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues)

    def exteriorFuelEquipmentDefinition(self) -> "openstudio::model::ExteriorFuelEquipmentDefinition":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_exteriorFuelEquipmentDefinition(self)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_schedule(self)

    def fuelType(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_fuelType(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_isEndUseSubcategoryDefaulted(self)

    def setExteriorFuelEquipmentDefinition(self, exteriorFuelEquipmentDefinition: 'ExteriorFuelEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setExteriorFuelEquipmentDefinition(self, exteriorFuelEquipmentDefinition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetSchedule(self)

    def setFuelType(self, fuelType: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setFuelType(self, fuelType)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorFuelEquipment_facility(self)
ExteriorFuelEquipment_swigregister = _openstudiomodelgeometry.ExteriorFuelEquipment_swigregister
ExteriorFuelEquipment_swigregister(ExteriorFuelEquipment)

def ExteriorFuelEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType()
ExteriorFuelEquipment_iddObjectType = _openstudiomodelgeometry.ExteriorFuelEquipment_iddObjectType

def ExteriorFuelEquipment_fuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues()
ExteriorFuelEquipment_fuelTypeValues = _openstudiomodelgeometry.ExteriorFuelEquipment_fuelTypeValues

def ExteriorFuelEquipment_validFuelTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues()
ExteriorFuelEquipment_validFuelTypeValues = _openstudiomodelgeometry.ExteriorFuelEquipment_validFuelTypeValues


def toExteriorFuelEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.toExteriorFuelEquipment(idfObject)
toExteriorFuelEquipment = _openstudiomodelgeometry.toExteriorFuelEquipment

def getExteriorFuelEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.getExteriorFuelEquipment(t_model, t_handle)
getExteriorFuelEquipment = _openstudiomodelgeometry.getExteriorFuelEquipment

def getExteriorFuelEquipments(t_model: 'Model') -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
    return _openstudiomodelgeometry.getExteriorFuelEquipments(t_model)
getExteriorFuelEquipments = _openstudiomodelgeometry.getExteriorFuelEquipments

def getExteriorFuelEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ExteriorFuelEquipment >":
    return _openstudiomodelgeometry.getExteriorFuelEquipmentByName(t_model, t_name)
getExteriorFuelEquipmentByName = _openstudiomodelgeometry.getExteriorFuelEquipmentByName

def getExteriorFuelEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ExteriorFuelEquipment,std::allocator< openstudio::model::ExteriorFuelEquipment > >":
    return _openstudiomodelgeometry.getExteriorFuelEquipmentsByName(t_model, t_name, t_exactMatch)
getExteriorFuelEquipmentsByName = _openstudiomodelgeometry.getExteriorFuelEquipmentsByName
class ExteriorWaterEquipment(ExteriorLoadInstance):
    __swig_setmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExteriorWaterEquipment, name, value)
    __swig_getmethods__ = {}
    for _s in [ExteriorLoadInstance]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExteriorWaterEquipment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelgeometry.new_ExteriorWaterEquipment(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelgeometry.delete_ExteriorWaterEquipment
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType)

    def exteriorWaterEquipmentDefinition(self) -> "openstudio::model::ExteriorWaterEquipmentDefinition":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_exteriorWaterEquipmentDefinition(self)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_schedule(self)

    def multiplier(self) -> "double":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_multiplier(self)

    def isMultiplierDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_isMultiplierDefaulted(self)

    def endUseSubcategory(self) -> "std::string":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_endUseSubcategory(self)

    def isEndUseSubcategoryDefaulted(self) -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_isEndUseSubcategoryDefaulted(self)

    def setExteriorWaterEquipmentDefinition(self, exteriorWaterEquipmentDefinition: 'ExteriorWaterEquipmentDefinition') -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setExteriorWaterEquipmentDefinition(self, exteriorWaterEquipmentDefinition)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setSchedule(self, schedule)

    def resetSchedule(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetSchedule(self)

    def setMultiplier(self, multiplier: 'double') -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setMultiplier(self, multiplier)

    def resetMultiplier(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetMultiplier(self)

    def setEndUseSubcategory(self, endUseSubcategory: 'std::string') -> "bool":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_setEndUseSubcategory(self, endUseSubcategory)

    def resetEndUseSubcategory(self) -> "void":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_resetEndUseSubcategory(self)

    def facility(self) -> "openstudio::model::Facility":
        return _openstudiomodelgeometry.ExteriorWaterEquipment_facility(self)
ExteriorWaterEquipment_swigregister = _openstudiomodelgeometry.ExteriorWaterEquipment_swigregister
ExteriorWaterEquipment_swigregister(ExteriorWaterEquipment)

def ExteriorWaterEquipment_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType()
ExteriorWaterEquipment_iddObjectType = _openstudiomodelgeometry.ExteriorWaterEquipment_iddObjectType


def toExteriorWaterEquipment(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.toExteriorWaterEquipment(idfObject)
toExteriorWaterEquipment = _openstudiomodelgeometry.toExteriorWaterEquipment

def getExteriorWaterEquipment(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.getExteriorWaterEquipment(t_model, t_handle)
getExteriorWaterEquipment = _openstudiomodelgeometry.getExteriorWaterEquipment

def getExteriorWaterEquipments(t_model: 'Model') -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
    return _openstudiomodelgeometry.getExteriorWaterEquipments(t_model)
getExteriorWaterEquipments = _openstudiomodelgeometry.getExteriorWaterEquipments

def getExteriorWaterEquipmentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::ExteriorWaterEquipment >":
    return _openstudiomodelgeometry.getExteriorWaterEquipmentByName(t_model, t_name)
getExteriorWaterEquipmentByName = _openstudiomodelgeometry.getExteriorWaterEquipmentByName

def getExteriorWaterEquipmentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::ExteriorWaterEquipment,std::allocator< openstudio::model::ExteriorWaterEquipment > >":
    return _openstudiomodelgeometry.getExteriorWaterEquipmentsByName(t_model, t_name, t_exactMatch)
getExteriorWaterEquipmentsByName = _openstudiomodelgeometry.getExteriorWaterEquipmentsByName
# This file is compatible with both classic and new-style classes.


