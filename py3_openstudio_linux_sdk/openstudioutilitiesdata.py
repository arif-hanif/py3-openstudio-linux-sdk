# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openstudioutilitiesdata', [dirname(__file__)])
        except ImportError:
            import _openstudioutilitiesdata
            return _openstudioutilitiesdata
        if fp is not None:
            try:
                _mod = imp.load_module('_openstudioutilitiesdata', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openstudioutilitiesdata = swig_import_helper()
    del swig_import_helper
else:
    import _openstudioutilitiesdata
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudioutilitiesdata.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _openstudioutilitiesdata.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudioutilitiesdata.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudioutilitiesdata.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudioutilitiesdata.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudioutilitiesdata.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudioutilitiesdata.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openstudioutilitiesdata.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_openstudioutilitiesdata.SHARED_PTR_DISOWN_swigconstant(_openstudioutilitiesdata)
SHARED_PTR_DISOWN = _openstudioutilitiesdata.SHARED_PTR_DISOWN
from .import openstudioutilitiestime
from .import openstudioutilitiescore
from .import openstudioutilitiesunits
class InstallLocationTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InstallLocationTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InstallLocationTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.InstallLocationTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::InstallLocationType >::value_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::InstallLocationType >::difference_type', j: 'std::vector< openstudio::InstallLocationType >::difference_type') -> "std::vector< openstudio::InstallLocationType,std::allocator< openstudio::InstallLocationType > > *":
        return _openstudioutilitiesdata.InstallLocationTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::InstallLocationType >::difference_type', j: 'std::vector< openstudio::InstallLocationType >::difference_type') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector___setitem__(self, *args)

    def append(self, x: 'InstallLocationType') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.InstallLocationTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_clear(self)

    def swap(self, v: 'InstallLocationTypeVector') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::InstallLocationType >::allocator_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::InstallLocationType >::reverse_iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::InstallLocationType >::reverse_iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::InstallLocationType >::iterator":
        return _openstudioutilitiesdata.InstallLocationTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_InstallLocationTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'InstallLocationType') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::InstallLocationType >::value_type const &":
        return _openstudioutilitiesdata.InstallLocationTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::InstallLocationType >::size_type', x: 'InstallLocationType') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::InstallLocationType >::size_type') -> "void":
        return _openstudioutilitiesdata.InstallLocationTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::InstallLocationType >::size_type":
        return _openstudioutilitiesdata.InstallLocationTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_InstallLocationTypeVector
    __del__ = lambda self: None
InstallLocationTypeVector_swigregister = _openstudioutilitiesdata.InstallLocationTypeVector_swigregister
InstallLocationTypeVector_swigregister(InstallLocationTypeVector)

class OptionalInstallLocationType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalInstallLocationType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalInstallLocationType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalInstallLocationType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalInstallLocationType_reset(self)

    def __ref__(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.OptionalInstallLocationType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalInstallLocationType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalInstallLocationType_isNull(self)

    def get(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.OptionalInstallLocationType_get(self)

    def set(self, t: 'InstallLocationType') -> "void":
        return _openstudioutilitiesdata.OptionalInstallLocationType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalInstallLocationType
    __del__ = lambda self: None
OptionalInstallLocationType_swigregister = _openstudioutilitiesdata.OptionalInstallLocationType_swigregister
OptionalInstallLocationType_swigregister(OptionalInstallLocationType)

class FuelTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FuelTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FuelTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.FuelTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::FuelType >::value_type":
        return _openstudioutilitiesdata.FuelTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::FuelType >::difference_type', j: 'std::vector< openstudio::FuelType >::difference_type') -> "std::vector< openstudio::FuelType,std::allocator< openstudio::FuelType > > *":
        return _openstudioutilitiesdata.FuelTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::FuelType >::difference_type', j: 'std::vector< openstudio::FuelType >::difference_type') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector___setitem__(self, *args)

    def append(self, x: 'FuelType') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.FuelTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_clear(self)

    def swap(self, v: 'FuelTypeVector') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::FuelType >::allocator_type":
        return _openstudioutilitiesdata.FuelTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::FuelType >::reverse_iterator":
        return _openstudioutilitiesdata.FuelTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::FuelType >::reverse_iterator":
        return _openstudioutilitiesdata.FuelTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::FuelType >::iterator":
        return _openstudioutilitiesdata.FuelTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_FuelTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'FuelType') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::FuelType >::value_type const &":
        return _openstudioutilitiesdata.FuelTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::FuelType >::size_type', x: 'FuelType') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::FuelType >::size_type') -> "void":
        return _openstudioutilitiesdata.FuelTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::FuelType >::size_type":
        return _openstudioutilitiesdata.FuelTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_FuelTypeVector
    __del__ = lambda self: None
FuelTypeVector_swigregister = _openstudioutilitiesdata.FuelTypeVector_swigregister
FuelTypeVector_swigregister(FuelTypeVector)

class OptionalFuelType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalFuelType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalFuelType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalFuelType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalFuelType_reset(self)

    def __ref__(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.OptionalFuelType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalFuelType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalFuelType_isNull(self)

    def get(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.OptionalFuelType_get(self)

    def set(self, t: 'FuelType') -> "void":
        return _openstudioutilitiesdata.OptionalFuelType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalFuelType
    __del__ = lambda self: None
OptionalFuelType_swigregister = _openstudioutilitiesdata.OptionalFuelType_swigregister
OptionalFuelType_swigregister(OptionalFuelType)

class EndUseFuelTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseFuelTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseFuelTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::EndUseFuelType >::value_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::EndUseFuelType >::difference_type', j: 'std::vector< openstudio::EndUseFuelType >::difference_type') -> "std::vector< openstudio::EndUseFuelType,std::allocator< openstudio::EndUseFuelType > > *":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::EndUseFuelType >::difference_type', j: 'std::vector< openstudio::EndUseFuelType >::difference_type') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector___setitem__(self, *args)

    def append(self, x: 'EndUseFuelType') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_clear(self)

    def swap(self, v: 'EndUseFuelTypeVector') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::EndUseFuelType >::allocator_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseFuelType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseFuelType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseFuelType >::iterator":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseFuelTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'EndUseFuelType') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseFuelType >::value_type const &":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::EndUseFuelType >::size_type', x: 'EndUseFuelType') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::EndUseFuelType >::size_type') -> "void":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseFuelType >::size_type":
        return _openstudioutilitiesdata.EndUseFuelTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseFuelTypeVector
    __del__ = lambda self: None
EndUseFuelTypeVector_swigregister = _openstudioutilitiesdata.EndUseFuelTypeVector_swigregister
EndUseFuelTypeVector_swigregister(EndUseFuelTypeVector)

class OptionalEndUseFuelType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalEndUseFuelType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalEndUseFuelType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalEndUseFuelType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_reset(self)

    def __ref__(self) -> "openstudio::EndUseFuelType":
        return _openstudioutilitiesdata.OptionalEndUseFuelType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_isNull(self)

    def get(self) -> "openstudio::EndUseFuelType":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_get(self)

    def set(self, t: 'EndUseFuelType') -> "void":
        return _openstudioutilitiesdata.OptionalEndUseFuelType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseFuelType
    __del__ = lambda self: None
OptionalEndUseFuelType_swigregister = _openstudioutilitiesdata.OptionalEndUseFuelType_swigregister
OptionalEndUseFuelType_swigregister(OptionalEndUseFuelType)

class EndUseCategoryTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseCategoryTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseCategoryTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::EndUseCategoryType >::difference_type', j: 'std::vector< openstudio::EndUseCategoryType >::difference_type') -> "std::vector< openstudio::EndUseCategoryType,std::allocator< openstudio::EndUseCategoryType > > *":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::EndUseCategoryType >::difference_type', j: 'std::vector< openstudio::EndUseCategoryType >::difference_type') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector___setitem__(self, *args)

    def append(self, x: 'EndUseCategoryType') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_clear(self)

    def swap(self, v: 'EndUseCategoryTypeVector') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::EndUseCategoryType >::allocator_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseCategoryType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseCategoryType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseCategoryType >::iterator":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseCategoryTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'EndUseCategoryType') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseCategoryType >::value_type const &":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::EndUseCategoryType >::size_type', x: 'EndUseCategoryType') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::EndUseCategoryType >::size_type') -> "void":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseCategoryType >::size_type":
        return _openstudioutilitiesdata.EndUseCategoryTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseCategoryTypeVector
    __del__ = lambda self: None
EndUseCategoryTypeVector_swigregister = _openstudioutilitiesdata.EndUseCategoryTypeVector_swigregister
EndUseCategoryTypeVector_swigregister(EndUseCategoryTypeVector)

class OptionalEndUseCategoryType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalEndUseCategoryType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalEndUseCategoryType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalEndUseCategoryType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_reset(self)

    def __ref__(self) -> "openstudio::EndUseCategoryType":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_isNull(self)

    def get(self) -> "openstudio::EndUseCategoryType":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_get(self)

    def set(self, t: 'EndUseCategoryType') -> "void":
        return _openstudioutilitiesdata.OptionalEndUseCategoryType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseCategoryType
    __del__ = lambda self: None
OptionalEndUseCategoryType_swigregister = _openstudioutilitiesdata.OptionalEndUseCategoryType_swigregister
OptionalEndUseCategoryType_swigregister(OptionalEndUseCategoryType)

class EndUseTypeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseTypeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseTypeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUseTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::EndUseType >::value_type":
        return _openstudioutilitiesdata.EndUseTypeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::EndUseType >::difference_type', j: 'std::vector< openstudio::EndUseType >::difference_type') -> "std::vector< openstudio::EndUseType,std::allocator< openstudio::EndUseType > > *":
        return _openstudioutilitiesdata.EndUseTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::EndUseType >::difference_type', j: 'std::vector< openstudio::EndUseType >::difference_type') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector___setitem__(self, *args)

    def append(self, x: 'EndUseType') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUseTypeVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_clear(self)

    def swap(self, v: 'EndUseTypeVector') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::EndUseType >::allocator_type":
        return _openstudioutilitiesdata.EndUseTypeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUseType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUseType >::reverse_iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUseType >::iterator":
        return _openstudioutilitiesdata.EndUseTypeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseTypeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'EndUseType') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUseType >::value_type const &":
        return _openstudioutilitiesdata.EndUseTypeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::EndUseType >::size_type', x: 'EndUseType') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::EndUseType >::size_type') -> "void":
        return _openstudioutilitiesdata.EndUseTypeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUseType >::size_type":
        return _openstudioutilitiesdata.EndUseTypeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseTypeVector
    __del__ = lambda self: None
EndUseTypeVector_swigregister = _openstudioutilitiesdata.EndUseTypeVector_swigregister
EndUseTypeVector_swigregister(EndUseTypeVector)

class OptionalEndUseType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalEndUseType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalEndUseType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalEndUseType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUseType_reset(self)

    def __ref__(self) -> "openstudio::EndUseType":
        return _openstudioutilitiesdata.OptionalEndUseType___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseType_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUseType_isNull(self)

    def get(self) -> "openstudio::EndUseType":
        return _openstudioutilitiesdata.OptionalEndUseType_get(self)

    def set(self, t: 'EndUseType') -> "void":
        return _openstudioutilitiesdata.OptionalEndUseType_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUseType
    __del__ = lambda self: None
OptionalEndUseType_swigregister = _openstudioutilitiesdata.OptionalEndUseType_swigregister
OptionalEndUseType_swigregister(OptionalEndUseType)

class BuildingSectorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingSectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingSectorVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.BuildingSectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector___len__(self)

    def pop(self) -> "std::vector< openstudio::BuildingSector >::value_type":
        return _openstudioutilitiesdata.BuildingSectorVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::BuildingSector >::difference_type', j: 'std::vector< openstudio::BuildingSector >::difference_type') -> "std::vector< openstudio::BuildingSector,std::allocator< openstudio::BuildingSector > > *":
        return _openstudioutilitiesdata.BuildingSectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::BuildingSector >::difference_type', j: 'std::vector< openstudio::BuildingSector >::difference_type') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector___setitem__(self, *args)

    def append(self, x: 'BuildingSector') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.BuildingSectorVector_empty(self)

    def size(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_clear(self)

    def swap(self, v: 'BuildingSectorVector') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::BuildingSector >::allocator_type":
        return _openstudioutilitiesdata.BuildingSectorVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_begin(self)

    def end(self) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::BuildingSector >::reverse_iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::BuildingSector >::reverse_iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::BuildingSector >::iterator":
        return _openstudioutilitiesdata.BuildingSectorVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_BuildingSectorVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'BuildingSector') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector_front(self)

    def back(self) -> "std::vector< openstudio::BuildingSector >::value_type const &":
        return _openstudioutilitiesdata.BuildingSectorVector_back(self)

    def assign(self, n: 'std::vector< openstudio::BuildingSector >::size_type', x: 'BuildingSector') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::BuildingSector >::size_type') -> "void":
        return _openstudioutilitiesdata.BuildingSectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::BuildingSector >::size_type":
        return _openstudioutilitiesdata.BuildingSectorVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_BuildingSectorVector
    __del__ = lambda self: None
BuildingSectorVector_swigregister = _openstudioutilitiesdata.BuildingSectorVector_swigregister
BuildingSectorVector_swigregister(BuildingSectorVector)

class OptionalBuildingSector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalBuildingSector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalBuildingSector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalBuildingSector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalBuildingSector_reset(self)

    def __ref__(self) -> "openstudio::BuildingSector":
        return _openstudioutilitiesdata.OptionalBuildingSector___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalBuildingSector_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalBuildingSector_isNull(self)

    def get(self) -> "openstudio::BuildingSector":
        return _openstudioutilitiesdata.OptionalBuildingSector_get(self)

    def set(self, t: 'BuildingSector') -> "void":
        return _openstudioutilitiesdata.OptionalBuildingSector_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalBuildingSector
    __del__ = lambda self: None
OptionalBuildingSector_swigregister = _openstudioutilitiesdata.OptionalBuildingSector_swigregister
OptionalBuildingSector_swigregister(OptionalBuildingSector)

class OptionalTag(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalTag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalTag, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalTag(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalTag_reset(self)

    def __ref__(self) -> "openstudio::Tag":
        return _openstudioutilitiesdata.OptionalTag___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTag_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTag_isNull(self)

    def get(self) -> "openstudio::Tag":
        return _openstudioutilitiesdata.OptionalTag_get(self)

    def set(self, t: 'Tag') -> "void":
        return _openstudioutilitiesdata.OptionalTag_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalTag
    __del__ = lambda self: None
OptionalTag_swigregister = _openstudioutilitiesdata.OptionalTag_swigregister
OptionalTag_swigregister(OptionalTag)

class TagVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TagVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.TagVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.TagVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.TagVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Tag >::size_type":
        return _openstudioutilitiesdata.TagVector___len__(self)

    def pop(self) -> "std::vector< openstudio::Tag >::value_type":
        return _openstudioutilitiesdata.TagVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::Tag >::difference_type', j: 'std::vector< openstudio::Tag >::difference_type') -> "std::vector< openstudio::Tag,std::allocator< openstudio::Tag > > *":
        return _openstudioutilitiesdata.TagVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.TagVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::Tag >::difference_type', j: 'std::vector< openstudio::Tag >::difference_type') -> "void":
        return _openstudioutilitiesdata.TagVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TagVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Tag >::value_type const &":
        return _openstudioutilitiesdata.TagVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TagVector___setitem__(self, *args)

    def append(self, x: 'Tag') -> "void":
        return _openstudioutilitiesdata.TagVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.TagVector_empty(self)

    def size(self) -> "std::vector< openstudio::Tag >::size_type":
        return _openstudioutilitiesdata.TagVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.TagVector_clear(self)

    def swap(self, v: 'TagVector') -> "void":
        return _openstudioutilitiesdata.TagVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::Tag >::allocator_type":
        return _openstudioutilitiesdata.TagVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::Tag >::iterator":
        return _openstudioutilitiesdata.TagVector_begin(self)

    def end(self) -> "std::vector< openstudio::Tag >::iterator":
        return _openstudioutilitiesdata.TagVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Tag >::reverse_iterator":
        return _openstudioutilitiesdata.TagVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Tag >::reverse_iterator":
        return _openstudioutilitiesdata.TagVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.TagVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Tag >::iterator":
        return _openstudioutilitiesdata.TagVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_TagVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Tag') -> "void":
        return _openstudioutilitiesdata.TagVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Tag >::value_type const &":
        return _openstudioutilitiesdata.TagVector_front(self)

    def back(self) -> "std::vector< openstudio::Tag >::value_type const &":
        return _openstudioutilitiesdata.TagVector_back(self)

    def assign(self, n: 'std::vector< openstudio::Tag >::size_type', x: 'Tag') -> "void":
        return _openstudioutilitiesdata.TagVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::Tag >::size_type', x: 'Tag') -> "void":
        return _openstudioutilitiesdata.TagVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.TagVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::Tag >::size_type') -> "void":
        return _openstudioutilitiesdata.TagVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Tag >::size_type":
        return _openstudioutilitiesdata.TagVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_TagVector
    __del__ = lambda self: None
TagVector_swigregister = _openstudioutilitiesdata.TagVector_swigregister
TagVector_swigregister(TagVector)

class InstallLocationType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InstallLocationType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InstallLocationType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_InstallLocationType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.InstallLocationType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.InstallLocationType_valueDescription(self)

    def __eq__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___eq__(self, other)

    def __ne__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___ne__(self, other)

    def __gt__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___gt__(self, other)

    def __ge__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___ge__(self, other)

    def __lt__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___lt__(self, other)

    def __le__(self, other: 'InstallLocationType') -> "bool":
        return _openstudioutilitiesdata.InstallLocationType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.InstallLocationType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.InstallLocationType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.InstallLocationType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.InstallLocationType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_InstallLocationType
    __del__ = lambda self: None
InstallLocationType_swigregister = _openstudioutilitiesdata.InstallLocationType_swigregister
InstallLocationType_swigregister(InstallLocationType)

def InstallLocationType_enumName() -> "std::string":
    return _openstudioutilitiesdata.InstallLocationType_enumName()
InstallLocationType_enumName = _openstudioutilitiesdata.InstallLocationType_enumName

def InstallLocationType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.InstallLocationType_getValues()
InstallLocationType_getValues = _openstudioutilitiesdata.InstallLocationType_getValues

class FuelType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FuelType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FuelType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_FuelType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.FuelType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.FuelType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.FuelType_valueDescription(self)

    def __eq__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___eq__(self, other)

    def __ne__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___ne__(self, other)

    def __gt__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___gt__(self, other)

    def __ge__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___ge__(self, other)

    def __lt__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___lt__(self, other)

    def __le__(self, other: 'FuelType') -> "bool":
        return _openstudioutilitiesdata.FuelType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.FuelType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.FuelType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.FuelType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.FuelType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_FuelType
    __del__ = lambda self: None
FuelType_swigregister = _openstudioutilitiesdata.FuelType_swigregister
FuelType_swigregister(FuelType)

def FuelType_enumName() -> "std::string":
    return _openstudioutilitiesdata.FuelType_enumName()
FuelType_enumName = _openstudioutilitiesdata.FuelType_enumName

def FuelType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.FuelType_getValues()
FuelType_getValues = _openstudioutilitiesdata.FuelType_getValues

class EndUseFuelType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseFuelType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseFuelType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseFuelType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseFuelType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseFuelType_valueDescription(self)

    def __eq__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___eq__(self, other)

    def __ne__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___ne__(self, other)

    def __gt__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___gt__(self, other)

    def __ge__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___ge__(self, other)

    def __lt__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___lt__(self, other)

    def __le__(self, other: 'EndUseFuelType') -> "bool":
        return _openstudioutilitiesdata.EndUseFuelType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.EndUseFuelType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.EndUseFuelType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.EndUseFuelType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.EndUseFuelType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseFuelType
    __del__ = lambda self: None
EndUseFuelType_swigregister = _openstudioutilitiesdata.EndUseFuelType_swigregister
EndUseFuelType_swigregister(EndUseFuelType)

def EndUseFuelType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseFuelType_enumName()
EndUseFuelType_enumName = _openstudioutilitiesdata.EndUseFuelType_enumName

def EndUseFuelType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseFuelType_getValues()
EndUseFuelType_getValues = _openstudioutilitiesdata.EndUseFuelType_getValues

class EndUseCategoryType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseCategoryType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseCategoryType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseCategoryType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseCategoryType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseCategoryType_valueDescription(self)

    def __eq__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___eq__(self, other)

    def __ne__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___ne__(self, other)

    def __gt__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___gt__(self, other)

    def __ge__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___ge__(self, other)

    def __lt__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___lt__(self, other)

    def __le__(self, other: 'EndUseCategoryType') -> "bool":
        return _openstudioutilitiesdata.EndUseCategoryType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.EndUseCategoryType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.EndUseCategoryType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.EndUseCategoryType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.EndUseCategoryType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseCategoryType
    __del__ = lambda self: None
EndUseCategoryType_swigregister = _openstudioutilitiesdata.EndUseCategoryType_swigregister
EndUseCategoryType_swigregister(EndUseCategoryType)

def EndUseCategoryType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseCategoryType_enumName()
EndUseCategoryType_enumName = _openstudioutilitiesdata.EndUseCategoryType_enumName

def EndUseCategoryType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseCategoryType_getValues()
EndUseCategoryType_getValues = _openstudioutilitiesdata.EndUseCategoryType_getValues

class EndUseType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUseType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUseType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUseType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.EndUseType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.EndUseType_valueDescription(self)

    def __eq__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___eq__(self, other)

    def __ne__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___ne__(self, other)

    def __gt__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___gt__(self, other)

    def __ge__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___ge__(self, other)

    def __lt__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___lt__(self, other)

    def __le__(self, other: 'EndUseType') -> "bool":
        return _openstudioutilitiesdata.EndUseType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.EndUseType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.EndUseType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.EndUseType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.EndUseType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUseType
    __del__ = lambda self: None
EndUseType_swigregister = _openstudioutilitiesdata.EndUseType_swigregister
EndUseType_swigregister(EndUseType)

def EndUseType_enumName() -> "std::string":
    return _openstudioutilitiesdata.EndUseType_enumName()
EndUseType_enumName = _openstudioutilitiesdata.EndUseType_enumName

def EndUseType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.EndUseType_getValues()
EndUseType_getValues = _openstudioutilitiesdata.EndUseType_getValues

class BuildingSector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BuildingSector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BuildingSector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_BuildingSector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.BuildingSector_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.BuildingSector_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.BuildingSector_valueDescription(self)

    def __eq__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___eq__(self, other)

    def __ne__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___ne__(self, other)

    def __gt__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___gt__(self, other)

    def __ge__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___ge__(self, other)

    def __lt__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___lt__(self, other)

    def __le__(self, other: 'BuildingSector') -> "bool":
        return _openstudioutilitiesdata.BuildingSector___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.BuildingSector_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.BuildingSector_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.BuildingSector_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.BuildingSector_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_BuildingSector
    __del__ = lambda self: None
BuildingSector_swigregister = _openstudioutilitiesdata.BuildingSector_swigregister
BuildingSector_swigregister(BuildingSector)

def BuildingSector_enumName() -> "std::string":
    return _openstudioutilitiesdata.BuildingSector_enumName()
BuildingSector_enumName = _openstudioutilitiesdata.BuildingSector_enumName

def BuildingSector_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.BuildingSector_getValues()
BuildingSector_getValues = _openstudioutilitiesdata.BuildingSector_getValues

class OptionalAttribute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAttribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAttribute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalAttribute(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalAttribute_reset(self)

    def __ref__(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.OptionalAttribute___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalAttribute_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalAttribute_isNull(self)

    def get(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.OptionalAttribute_get(self)

    def set(self, t: 'Attribute') -> "void":
        return _openstudioutilitiesdata.OptionalAttribute_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalAttribute
    __del__ = lambda self: None
OptionalAttribute_swigregister = _openstudioutilitiesdata.OptionalAttribute_swigregister
OptionalAttribute_swigregister(OptionalAttribute)

class AttributeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributeVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.AttributeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector___len__(self)

    def pop(self) -> "std::vector< openstudio::Attribute >::value_type":
        return _openstudioutilitiesdata.AttributeVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::Attribute >::difference_type', j: 'std::vector< openstudio::Attribute >::difference_type') -> "std::vector< openstudio::Attribute,std::allocator< openstudio::Attribute > > *":
        return _openstudioutilitiesdata.AttributeVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::Attribute >::difference_type', j: 'std::vector< openstudio::Attribute >::difference_type') -> "void":
        return _openstudioutilitiesdata.AttributeVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector___setitem__(self, *args)

    def append(self, x: 'Attribute') -> "void":
        return _openstudioutilitiesdata.AttributeVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.AttributeVector_empty(self)

    def size(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.AttributeVector_clear(self)

    def swap(self, v: 'AttributeVector') -> "void":
        return _openstudioutilitiesdata.AttributeVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::Attribute >::allocator_type":
        return _openstudioutilitiesdata.AttributeVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_begin(self)

    def end(self) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Attribute >::reverse_iterator":
        return _openstudioutilitiesdata.AttributeVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Attribute >::reverse_iterator":
        return _openstudioutilitiesdata.AttributeVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.AttributeVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Attribute >::iterator":
        return _openstudioutilitiesdata.AttributeVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_AttributeVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Attribute') -> "void":
        return _openstudioutilitiesdata.AttributeVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector_front(self)

    def back(self) -> "std::vector< openstudio::Attribute >::value_type const &":
        return _openstudioutilitiesdata.AttributeVector_back(self)

    def assign(self, n: 'std::vector< openstudio::Attribute >::size_type', x: 'Attribute') -> "void":
        return _openstudioutilitiesdata.AttributeVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::Attribute >::size_type', x: 'Attribute') -> "void":
        return _openstudioutilitiesdata.AttributeVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.AttributeVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::Attribute >::size_type') -> "void":
        return _openstudioutilitiesdata.AttributeVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Attribute >::size_type":
        return _openstudioutilitiesdata.AttributeVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeVector
    __del__ = lambda self: None
AttributeVector_swigregister = _openstudioutilitiesdata.AttributeVector_swigregister
AttributeVector_swigregister(AttributeVector)

class AttributeValueType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributeValueType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributeValueType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_AttributeValueType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.AttributeValueType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.AttributeValueType_valueDescription(self)

    def __eq__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___eq__(self, other)

    def __ne__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___ne__(self, other)

    def __gt__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___gt__(self, other)

    def __ge__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___ge__(self, other)

    def __lt__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___lt__(self, other)

    def __le__(self, other: 'AttributeValueType') -> "bool":
        return _openstudioutilitiesdata.AttributeValueType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.AttributeValueType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.AttributeValueType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.AttributeValueType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.AttributeValueType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeValueType
    __del__ = lambda self: None
AttributeValueType_swigregister = _openstudioutilitiesdata.AttributeValueType_swigregister
AttributeValueType_swigregister(AttributeValueType)

def AttributeValueType_enumName() -> "std::string":
    return _openstudioutilitiesdata.AttributeValueType_enumName()
AttributeValueType_enumName = _openstudioutilitiesdata.AttributeValueType_enumName

def AttributeValueType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.AttributeValueType_getValues()
AttributeValueType_getValues = _openstudioutilitiesdata.AttributeValueType_getValues

class AttributeDescription(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AttributeDescription, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AttributeDescription, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _openstudioutilitiesdata.AttributeDescription_name_set
    __swig_getmethods__["name"] = _openstudioutilitiesdata.AttributeDescription_name_get
    if _newclass:
        name = _swig_property(_openstudioutilitiesdata.AttributeDescription_name_get, _openstudioutilitiesdata.AttributeDescription_name_set)
    __swig_setmethods__["displayName"] = _openstudioutilitiesdata.AttributeDescription_displayName_set
    __swig_getmethods__["displayName"] = _openstudioutilitiesdata.AttributeDescription_displayName_get
    if _newclass:
        displayName = _swig_property(_openstudioutilitiesdata.AttributeDescription_displayName_get, _openstudioutilitiesdata.AttributeDescription_displayName_set)
    __swig_setmethods__["description"] = _openstudioutilitiesdata.AttributeDescription_description_set
    __swig_getmethods__["description"] = _openstudioutilitiesdata.AttributeDescription_description_get
    if _newclass:
        description = _swig_property(_openstudioutilitiesdata.AttributeDescription_description_get, _openstudioutilitiesdata.AttributeDescription_description_set)
    __swig_setmethods__["validValueTypes"] = _openstudioutilitiesdata.AttributeDescription_validValueTypes_set
    __swig_getmethods__["validValueTypes"] = _openstudioutilitiesdata.AttributeDescription_validValueTypes_get
    if _newclass:
        validValueTypes = _swig_property(_openstudioutilitiesdata.AttributeDescription_validValueTypes_get, _openstudioutilitiesdata.AttributeDescription_validValueTypes_set)
    __swig_setmethods__["required"] = _openstudioutilitiesdata.AttributeDescription_required_set
    __swig_getmethods__["required"] = _openstudioutilitiesdata.AttributeDescription_required_get
    if _newclass:
        required = _swig_property(_openstudioutilitiesdata.AttributeDescription_required_get, _openstudioutilitiesdata.AttributeDescription_required_set)
    __swig_setmethods__["defaultValue"] = _openstudioutilitiesdata.AttributeDescription_defaultValue_set
    __swig_getmethods__["defaultValue"] = _openstudioutilitiesdata.AttributeDescription_defaultValue_get
    if _newclass:
        defaultValue = _swig_property(_openstudioutilitiesdata.AttributeDescription_defaultValue_get, _openstudioutilitiesdata.AttributeDescription_defaultValue_set)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_AttributeDescription(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_AttributeDescription
    __del__ = lambda self: None
AttributeDescription_swigregister = _openstudioutilitiesdata.AttributeDescription_swigregister
AttributeDescription_swigregister(AttributeDescription)

class Attribute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Attribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Attribute, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudioutilitiesdata.delete_Attribute
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_Attribute(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def clone(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.Attribute_clone(self)
    __swig_getmethods__["fromQVariant"] = lambda x: _openstudioutilitiesdata.Attribute_fromQVariant
    if _newclass:
        fromQVariant = staticmethod(_openstudioutilitiesdata.Attribute_fromQVariant)
    __swig_getmethods__["loadFromXml"] = lambda x: _openstudioutilitiesdata.Attribute_loadFromXml
    if _newclass:
        loadFromXml = staticmethod(_openstudioutilitiesdata.Attribute_loadFromXml)

    def uuid(self) -> "openstudio::UUID":
        return _openstudioutilitiesdata.Attribute_uuid(self)

    def versionUUID(self) -> "openstudio::UUID":
        return _openstudioutilitiesdata.Attribute_versionUUID(self)

    def name(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_name(self)

    def displayName(self, returnName: 'bool'=False) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.Attribute_displayName(self, returnName)

    def setDisplayName(self, displayName: 'std::string const &') -> "bool":
        return _openstudioutilitiesdata.Attribute_setDisplayName(self, displayName)

    def clearDisplayName(self) -> "void":
        return _openstudioutilitiesdata.Attribute_clearDisplayName(self)

    def source(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_source(self)

    def setSource(self, source: 'std::string const &') -> "void":
        return _openstudioutilitiesdata.Attribute_setSource(self, source)

    def clearSource(self) -> "void":
        return _openstudioutilitiesdata.Attribute_clearSource(self)

    def valueType(self) -> "openstudio::AttributeValueType":
        return _openstudioutilitiesdata.Attribute_valueType(self)

    def valueAsBoolean(self) -> "bool":
        return _openstudioutilitiesdata.Attribute_valueAsBoolean(self)

    def valueAsInteger(self) -> "int":
        return _openstudioutilitiesdata.Attribute_valueAsInteger(self)

    def valueAsUnsigned(self) -> "unsigned int":
        return _openstudioutilitiesdata.Attribute_valueAsUnsigned(self)

    def valueAsDouble(self) -> "double":
        return _openstudioutilitiesdata.Attribute_valueAsDouble(self)

    def valueAsQuantity(self) -> "openstudio::Quantity":
        return _openstudioutilitiesdata.Attribute_valueAsQuantity(self)

    def valueAsUnit(self) -> "openstudio::Unit":
        return _openstudioutilitiesdata.Attribute_valueAsUnit(self)

    def valueAsString(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_valueAsString(self)

    def valueAsAttributeVector(self) -> "std::vector< openstudio::Attribute,std::allocator< openstudio::Attribute > >":
        return _openstudioutilitiesdata.Attribute_valueAsAttributeVector(self)

    def valueAsQVariant(self) -> "QVariant":
        return _openstudioutilitiesdata.Attribute_valueAsQVariant(self)

    def setValue(self, *args) -> "void":
        return _openstudioutilitiesdata.Attribute_setValue(self, *args)

    def findChildByName(self, name: 'std::string const &') -> "boost::optional< openstudio::Attribute >":
        return _openstudioutilitiesdata.Attribute_findChildByName(self, name)

    def units(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.Attribute_units(self)

    def setUnits(self, units: 'std::string const &') -> "bool":
        return _openstudioutilitiesdata.Attribute_setUnits(self, units)

    def toString(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute_toString(self)

    def toXml(self) -> "QDomDocument":
        return _openstudioutilitiesdata.Attribute_toXml(self)

    def saveToXml(self, path: 'path') -> "bool":
        return _openstudioutilitiesdata.Attribute_saveToXml(self, path)

    def __eq__(self, other: 'Attribute') -> "bool":
        return _openstudioutilitiesdata.Attribute___eq__(self, other)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Attribute___str__(self)
Attribute_swigregister = _openstudioutilitiesdata.Attribute_swigregister
Attribute_swigregister(Attribute)

def Attribute_fromQVariant(*args) -> "boost::optional< openstudio::Attribute >":
    return _openstudioutilitiesdata.Attribute_fromQVariant(*args)
Attribute_fromQVariant = _openstudioutilitiesdata.Attribute_fromQVariant

def Attribute_loadFromXml(*args) -> "boost::optional< openstudio::Attribute >":
    return _openstudioutilitiesdata.Attribute_loadFromXml(*args)
Attribute_loadFromXml = _openstudioutilitiesdata.Attribute_loadFromXml


def createAttributeFromVector(*args) -> "openstudio::Attribute":
    return _openstudioutilitiesdata.createAttributeFromVector(*args)
createAttributeFromVector = _openstudioutilitiesdata.createAttributeFromVector

def getIntVectorFromAttribute(attribute: 'Attribute') -> "std::vector< int,std::allocator< int > >":
    return _openstudioutilitiesdata.getIntVectorFromAttribute(attribute)
getIntVectorFromAttribute = _openstudioutilitiesdata.getIntVectorFromAttribute

def getDoubleVectorFromAttribute(attribute: 'Attribute') -> "std::vector< double,std::allocator< double > >":
    return _openstudioutilitiesdata.getDoubleVectorFromAttribute(attribute)
getDoubleVectorFromAttribute = _openstudioutilitiesdata.getDoubleVectorFromAttribute

def isConsistent(candidate: 'Attribute', description: 'AttributeDescription') -> "bool":
    return _openstudioutilitiesdata.isConsistent(candidate, description)
isConsistent = _openstudioutilitiesdata.isConsistent

def prepareForDisplay(attribute: 'Attribute', description: 'AttributeDescription') -> "bool":
    return _openstudioutilitiesdata.prepareForDisplay(attribute, description)
prepareForDisplay = _openstudioutilitiesdata.prepareForDisplay

def saveJSON(attributes: 'AttributeVector', p: 'path', overwrite: 'bool'=False) -> "bool":
    return _openstudioutilitiesdata.saveJSON(attributes, p, overwrite)
saveJSON = _openstudioutilitiesdata.saveJSON

def toJSON(*args) -> "std::string":
    return _openstudioutilitiesdata.toJSON(*args)
toJSON = _openstudioutilitiesdata.toJSON

def toJSONWithoutMetadata(attributes: 'AttributeVector') -> "std::string":
    return _openstudioutilitiesdata.toJSONWithoutMetadata(attributes)
toJSONWithoutMetadata = _openstudioutilitiesdata.toJSONWithoutMetadata

def toVectorOfAttribute(*args) -> "std::vector< openstudio::Attribute,std::allocator< openstudio::Attribute > >":
    return _openstudioutilitiesdata.toVectorOfAttribute(*args)
toVectorOfAttribute = _openstudioutilitiesdata.toVectorOfAttribute
class OptionalVariant(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalVariant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalVariant, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalVariant(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalVariant_reset(self)

    def __ref__(self) -> "openstudio::Variant":
        return _openstudioutilitiesdata.OptionalVariant___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalVariant_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalVariant_isNull(self)

    def get(self) -> "openstudio::Variant":
        return _openstudioutilitiesdata.OptionalVariant_get(self)

    def set(self, t: 'Variant') -> "void":
        return _openstudioutilitiesdata.OptionalVariant_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalVariant
    __del__ = lambda self: None
OptionalVariant_swigregister = _openstudioutilitiesdata.OptionalVariant_swigregister
OptionalVariant_swigregister(OptionalVariant)

class VariantVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariantVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VariantVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.VariantVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector___len__(self)

    def pop(self) -> "std::vector< openstudio::Variant >::value_type":
        return _openstudioutilitiesdata.VariantVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::Variant >::difference_type', j: 'std::vector< openstudio::Variant >::difference_type') -> "std::vector< openstudio::Variant,std::allocator< openstudio::Variant > > *":
        return _openstudioutilitiesdata.VariantVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::Variant >::difference_type', j: 'std::vector< openstudio::Variant >::difference_type') -> "void":
        return _openstudioutilitiesdata.VariantVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector___setitem__(self, *args)

    def append(self, x: 'Variant') -> "void":
        return _openstudioutilitiesdata.VariantVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.VariantVector_empty(self)

    def size(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.VariantVector_clear(self)

    def swap(self, v: 'VariantVector') -> "void":
        return _openstudioutilitiesdata.VariantVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::Variant >::allocator_type":
        return _openstudioutilitiesdata.VariantVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_begin(self)

    def end(self) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.VariantVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.VariantVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.VariantVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_VariantVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Variant') -> "void":
        return _openstudioutilitiesdata.VariantVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector_front(self)

    def back(self) -> "std::vector< openstudio::Variant >::value_type const &":
        return _openstudioutilitiesdata.VariantVector_back(self)

    def assign(self, n: 'std::vector< openstudio::Variant >::size_type', x: 'Variant') -> "void":
        return _openstudioutilitiesdata.VariantVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.VariantVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::Variant >::size_type') -> "void":
        return _openstudioutilitiesdata.VariantVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.VariantVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VariantVector
    __del__ = lambda self: None
VariantVector_swigregister = _openstudioutilitiesdata.VariantVector_swigregister
VariantVector_swigregister(VariantVector)

class StringVariantMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVariantMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVariantMap, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___bool__(self)

    def __len__(self) -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "std::map< std::string,openstudio::Variant >::mapped_type const &":
        return _openstudioutilitiesdata.StringVariantMap___getitem__(self, key)

    def __delitem__(self, key: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "void":
        return _openstudioutilitiesdata.StringVariantMap___delitem__(self, key)

    def has_key(self, key: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "bool":
        return _openstudioutilitiesdata.StringVariantMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_keys(self)

    def values(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_values(self)

    def items(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_items(self)

    def __contains__(self, key: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "bool":
        return _openstudioutilitiesdata.StringVariantMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.StringVariantMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.StringVariantMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _openstudioutilitiesdata.StringVariantMap_asdict(self)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_StringVariantMap(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.StringVariantMap_empty(self)

    def size(self) -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.StringVariantMap_clear(self)

    def swap(self, v: 'StringVariantMap') -> "void":
        return _openstudioutilitiesdata.StringVariantMap_swap(self, v)

    def get_allocator(self) -> "std::map< std::string,openstudio::Variant >::allocator_type":
        return _openstudioutilitiesdata.StringVariantMap_get_allocator(self)

    def begin(self) -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_begin(self)

    def end(self) -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_end(self)

    def rbegin(self) -> "std::map< std::string,openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.StringVariantMap_rbegin(self)

    def rend(self) -> "std::map< std::string,openstudio::Variant >::reverse_iterator":
        return _openstudioutilitiesdata.StringVariantMap_rend(self)

    def count(self, x: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "std::map< std::string,openstudio::Variant >::size_type":
        return _openstudioutilitiesdata.StringVariantMap_count(self, x)

    def erase(self, *args) -> "void":
        return _openstudioutilitiesdata.StringVariantMap_erase(self, *args)

    def find(self, x: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_find(self, x)

    def lower_bound(self, x: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_lower_bound(self, x)

    def upper_bound(self, x: 'std::map< std::string,openstudio::Variant >::key_type const &') -> "std::map< std::string,openstudio::Variant >::iterator":
        return _openstudioutilitiesdata.StringVariantMap_upper_bound(self, x)
    __swig_destroy__ = _openstudioutilitiesdata.delete_StringVariantMap
    __del__ = lambda self: None
StringVariantMap_swigregister = _openstudioutilitiesdata.StringVariantMap_swigregister
StringVariantMap_swigregister(StringVariantMap)

class VariantType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VariantType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VariantType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_VariantType(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def valueName(self) -> "std::string":
        return _openstudioutilitiesdata.VariantType_valueName(self)

    def value(self) -> "int":
        return _openstudioutilitiesdata.VariantType_value(self)

    def valueDescription(self) -> "std::string":
        return _openstudioutilitiesdata.VariantType_valueDescription(self)

    def __eq__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___eq__(self, other)

    def __ne__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___ne__(self, other)

    def __gt__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___gt__(self, other)

    def __ge__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___ge__(self, other)

    def __lt__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___lt__(self, other)

    def __le__(self, other: 'VariantType') -> "bool":
        return _openstudioutilitiesdata.VariantType___le__(self, other)
    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiesdata.VariantType_enumName
    if _newclass:
        enumName = staticmethod(_openstudioutilitiesdata.VariantType_enumName)
    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiesdata.VariantType_getValues
    if _newclass:
        getValues = staticmethod(_openstudioutilitiesdata.VariantType_getValues)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VariantType
    __del__ = lambda self: None
VariantType_swigregister = _openstudioutilitiesdata.VariantType_swigregister
VariantType_swigregister(VariantType)

def VariantType_enumName() -> "std::string":
    return _openstudioutilitiesdata.VariantType_enumName()
VariantType_enumName = _openstudioutilitiesdata.VariantType_enumName

def VariantType_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":
    return _openstudioutilitiesdata.VariantType_getValues()
VariantType_getValues = _openstudioutilitiesdata.VariantType_getValues

class Variant(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Variant, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_Variant(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def variantType(self) -> "openstudio::VariantType":
        return _openstudioutilitiesdata.Variant_variantType(self)

    def valueAsBoolean(self) -> "bool":
        return _openstudioutilitiesdata.Variant_valueAsBoolean(self)

    def valueAsInteger(self) -> "int":
        return _openstudioutilitiesdata.Variant_valueAsInteger(self)

    def valueAsDouble(self) -> "double":
        return _openstudioutilitiesdata.Variant_valueAsDouble(self)

    def valueAsString(self) -> "std::string":
        return _openstudioutilitiesdata.Variant_valueAsString(self)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Variant___str__(self)

    def __int__(self) -> "int":
        return _openstudioutilitiesdata.Variant___int__(self)

    def __float__(self) -> "float":
        return _openstudioutilitiesdata.Variant___float__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Variant
    __del__ = lambda self: None
Variant_swigregister = _openstudioutilitiesdata.Variant_swigregister
Variant_swigregister(Variant)


def __lshift__(*args) -> "std::ostream &":
    return _openstudioutilitiesdata.__lshift__(*args)
__lshift__ = _openstudioutilitiesdata.__lshift__
class OptionalCalibrationResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalCalibrationResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalCalibrationResult, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalCalibrationResult(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationResult_reset(self)

    def __ref__(self) -> "openstudio::CalibrationResult":
        return _openstudioutilitiesdata.OptionalCalibrationResult___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationResult_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationResult_isNull(self)

    def get(self) -> "openstudio::CalibrationResult":
        return _openstudioutilitiesdata.OptionalCalibrationResult_get(self)

    def set(self, t: 'CalibrationResult') -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationResult_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationResult
    __del__ = lambda self: None
OptionalCalibrationResult_swigregister = _openstudioutilitiesdata.OptionalCalibrationResult_swigregister
OptionalCalibrationResult_swigregister(OptionalCalibrationResult)

class OptionalCalibrationBillingPeriod(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalCalibrationBillingPeriod, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalCalibrationBillingPeriod, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalCalibrationBillingPeriod(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_reset(self)

    def __ref__(self) -> "openstudio::CalibrationBillingPeriod":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_isNull(self)

    def get(self) -> "openstudio::CalibrationBillingPeriod":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_get(self)

    def set(self, t: 'CalibrationBillingPeriod') -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationBillingPeriod
    __del__ = lambda self: None
OptionalCalibrationBillingPeriod_swigregister = _openstudioutilitiesdata.OptionalCalibrationBillingPeriod_swigregister
OptionalCalibrationBillingPeriod_swigregister(OptionalCalibrationBillingPeriod)

class OptionalCalibrationUtilityBill(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalCalibrationUtilityBill, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalCalibrationUtilityBill, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalCalibrationUtilityBill(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_reset(self)

    def __ref__(self) -> "openstudio::CalibrationUtilityBill":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_isNull(self)

    def get(self) -> "openstudio::CalibrationUtilityBill":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_get(self)

    def set(self, t: 'CalibrationUtilityBill') -> "void":
        return _openstudioutilitiesdata.OptionalCalibrationUtilityBill_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalCalibrationUtilityBill
    __del__ = lambda self: None
OptionalCalibrationUtilityBill_swigregister = _openstudioutilitiesdata.OptionalCalibrationUtilityBill_swigregister
OptionalCalibrationUtilityBill_swigregister(OptionalCalibrationUtilityBill)

class CalibrationResultVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalibrationResultVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalibrationResultVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.CalibrationResultVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector___len__(self)

    def pop(self) -> "std::vector< openstudio::CalibrationResult >::value_type":
        return _openstudioutilitiesdata.CalibrationResultVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::CalibrationResult >::difference_type', j: 'std::vector< openstudio::CalibrationResult >::difference_type') -> "std::vector< openstudio::CalibrationResult,std::allocator< openstudio::CalibrationResult > > *":
        return _openstudioutilitiesdata.CalibrationResultVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::CalibrationResult >::difference_type', j: 'std::vector< openstudio::CalibrationResult >::difference_type') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector___setitem__(self, *args)

    def append(self, x: 'CalibrationResult') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.CalibrationResultVector_empty(self)

    def size(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_clear(self)

    def swap(self, v: 'CalibrationResultVector') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::CalibrationResult >::allocator_type":
        return _openstudioutilitiesdata.CalibrationResultVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_begin(self)

    def end(self) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::CalibrationResult >::reverse_iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::CalibrationResult >::reverse_iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::CalibrationResult >::iterator":
        return _openstudioutilitiesdata.CalibrationResultVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_CalibrationResultVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'CalibrationResult') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector_front(self)

    def back(self) -> "std::vector< openstudio::CalibrationResult >::value_type const &":
        return _openstudioutilitiesdata.CalibrationResultVector_back(self)

    def assign(self, n: 'std::vector< openstudio::CalibrationResult >::size_type', x: 'CalibrationResult') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::CalibrationResult >::size_type') -> "void":
        return _openstudioutilitiesdata.CalibrationResultVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::CalibrationResult >::size_type":
        return _openstudioutilitiesdata.CalibrationResultVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationResultVector
    __del__ = lambda self: None
CalibrationResultVector_swigregister = _openstudioutilitiesdata.CalibrationResultVector_swigregister
CalibrationResultVector_swigregister(CalibrationResultVector)

class CalibrationBillingPeriod(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalibrationBillingPeriod, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalibrationBillingPeriod, name)
    __repr__ = _swig_repr
    __swig_getmethods__["attributeName"] = lambda x: _openstudioutilitiesdata.CalibrationBillingPeriod_attributeName
    if _newclass:
        attributeName = staticmethod(_openstudioutilitiesdata.CalibrationBillingPeriod_attributeName)
    __swig_getmethods__["fromAttribute"] = lambda x: _openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute
    if _newclass:
        fromAttribute = staticmethod(_openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute)

    def __init__(self, startDate: 'Date', numberOfDays: 'unsigned int', consumptionUnit: 'std::string const &', peakDemandUnit: 'OptionalString', consumption: 'OptionalDouble', peakDemand: 'OptionalDouble', totalCost: 'OptionalDouble', modelConsumption: 'OptionalDouble', modelPeakDemand: 'OptionalDouble', modelTotalCost: 'OptionalDouble'):
        this = _openstudioutilitiesdata.new_CalibrationBillingPeriod(startDate, numberOfDays, consumptionUnit, peakDemandUnit, consumption, peakDemand, totalCost, modelConsumption, modelPeakDemand, modelTotalCost)
        try:
            self.this.append(this)
        except:
            self.this = this

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_attribute(self)

    def startDate(self) -> "openstudio::Date":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_startDate(self)

    def endDate(self) -> "openstudio::Date":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_endDate(self)

    def numberOfDays(self) -> "unsigned int":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_numberOfDays(self)

    def consumptionUnit(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_consumptionUnit(self)

    def peakDemandUnit(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_peakDemandUnit(self)

    def consumption(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_consumption(self)

    def peakDemand(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_peakDemand(self)

    def totalCost(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_totalCost(self)

    def modelConsumption(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelConsumption(self)

    def modelPeakDemand(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelPeakDemand(self)

    def modelTotalCost(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationBillingPeriod_modelTotalCost(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationBillingPeriod
    __del__ = lambda self: None
CalibrationBillingPeriod_swigregister = _openstudioutilitiesdata.CalibrationBillingPeriod_swigregister
CalibrationBillingPeriod_swigregister(CalibrationBillingPeriod)

def CalibrationBillingPeriod_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationBillingPeriod_attributeName()
CalibrationBillingPeriod_attributeName = _openstudioutilitiesdata.CalibrationBillingPeriod_attributeName

def CalibrationBillingPeriod_fromAttribute(attribute: 'Attribute') -> "boost::optional< openstudio::CalibrationBillingPeriod >":
    return _openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute(attribute)
CalibrationBillingPeriod_fromAttribute = _openstudioutilitiesdata.CalibrationBillingPeriod_fromAttribute

class CalibrationUtilityBill(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalibrationUtilityBill, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalibrationUtilityBill, name)
    __repr__ = _swig_repr
    __swig_getmethods__["attributeName"] = lambda x: _openstudioutilitiesdata.CalibrationUtilityBill_attributeName
    if _newclass:
        attributeName = staticmethod(_openstudioutilitiesdata.CalibrationUtilityBill_attributeName)
    __swig_getmethods__["fromAttribute"] = lambda x: _openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute
    if _newclass:
        fromAttribute = staticmethod(_openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute)

    def __init__(self, name: 'std::string const &', fuelType: 'FuelType', meterInstallLocation: 'InstallLocationType', meterSpecificInstallLocation: 'OptionalString', meterEndUseCategory: 'OptionalEndUseCategoryType', meterSpecificEndUse: 'OptionalString', consumptionUnit: 'std::string', consumptionUnitConversionFactor: 'double', peakDemandUnit: 'OptionalString', peakDemandUnitConversionFactor: 'OptionalDouble', timestepsInPeakDemandWindow: 'OptionalUnsigned', minutesInPeakDemandWindow: 'OptionalDouble', numberBillingPeriodsInCalculations: 'OptionalUnsigned', CVRMSE: 'OptionalDouble', NMBE: 'OptionalDouble'):
        this = _openstudioutilitiesdata.new_CalibrationUtilityBill(name, fuelType, meterInstallLocation, meterSpecificInstallLocation, meterEndUseCategory, meterSpecificEndUse, consumptionUnit, consumptionUnitConversionFactor, peakDemandUnit, peakDemandUnitConversionFactor, timestepsInPeakDemandWindow, minutesInPeakDemandWindow, numberBillingPeriodsInCalculations, CVRMSE, NMBE)
        try:
            self.this.append(this)
        except:
            self.this = this

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationUtilityBill_attribute(self)

    def name(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationUtilityBill_name(self)

    def fuelType(self) -> "openstudio::FuelType":
        return _openstudioutilitiesdata.CalibrationUtilityBill_fuelType(self)

    def meterInstallLocation(self) -> "openstudio::InstallLocationType":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterInstallLocation(self)

    def meterSpecificInstallLocation(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterSpecificInstallLocation(self)

    def meterEndUseCategory(self) -> "boost::optional< openstudio::EndUseCategoryType >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterEndUseCategory(self)

    def meterSpecificEndUse(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_meterSpecificEndUse(self)

    def consumptionUnit(self) -> "std::string":
        return _openstudioutilitiesdata.CalibrationUtilityBill_consumptionUnit(self)

    def consumptionUnitConversionFactor(self) -> "double":
        return _openstudioutilitiesdata.CalibrationUtilityBill_consumptionUnitConversionFactor(self)

    def peakDemandUnit(self) -> "boost::optional< std::string >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_peakDemandUnit(self)

    def peakDemandUnitConversionFactor(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_peakDemandUnitConversionFactor(self)

    def timestepsInPeakDemandWindow(self) -> "boost::optional< unsigned int >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_timestepsInPeakDemandWindow(self)

    def minutesInPeakDemandWindow(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_minutesInPeakDemandWindow(self)

    def numberBillingPeriodsInCalculations(self) -> "boost::optional< unsigned int >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_numberBillingPeriodsInCalculations(self)

    def CVRMSE(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_CVRMSE(self)

    def NMBE(self) -> "boost::optional< double >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_NMBE(self)

    def billingPeriods(self) -> "std::vector< openstudio::CalibrationBillingPeriod,std::allocator< openstudio::CalibrationBillingPeriod > >":
        return _openstudioutilitiesdata.CalibrationUtilityBill_billingPeriods(self)

    def addBillingPeriod(self, billingPeriod: 'CalibrationBillingPeriod') -> "bool":
        return _openstudioutilitiesdata.CalibrationUtilityBill_addBillingPeriod(self, billingPeriod)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationUtilityBill
    __del__ = lambda self: None
CalibrationUtilityBill_swigregister = _openstudioutilitiesdata.CalibrationUtilityBill_swigregister
CalibrationUtilityBill_swigregister(CalibrationUtilityBill)

def CalibrationUtilityBill_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationUtilityBill_attributeName()
CalibrationUtilityBill_attributeName = _openstudioutilitiesdata.CalibrationUtilityBill_attributeName

def CalibrationUtilityBill_fromAttribute(attribute: 'Attribute') -> "boost::optional< openstudio::CalibrationUtilityBill >":
    return _openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute(attribute)
CalibrationUtilityBill_fromAttribute = _openstudioutilitiesdata.CalibrationUtilityBill_fromAttribute

class CalibrationResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalibrationResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalibrationResult, name)
    __repr__ = _swig_repr
    __swig_getmethods__["attributeName"] = lambda x: _openstudioutilitiesdata.CalibrationResult_attributeName
    if _newclass:
        attributeName = staticmethod(_openstudioutilitiesdata.CalibrationResult_attributeName)
    __swig_getmethods__["fromAttribute"] = lambda x: _openstudioutilitiesdata.CalibrationResult_fromAttribute
    if _newclass:
        fromAttribute = staticmethod(_openstudioutilitiesdata.CalibrationResult_fromAttribute)

    def __init__(self):
        this = _openstudioutilitiesdata.new_CalibrationResult()
        try:
            self.this.append(this)
        except:
            self.this = this

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.CalibrationResult_attribute(self)

    def utilityBills(self) -> "std::vector< openstudio::CalibrationUtilityBill,std::allocator< openstudio::CalibrationUtilityBill > >":
        return _openstudioutilitiesdata.CalibrationResult_utilityBills(self)

    def addUtilityBill(self, utilityBill: 'CalibrationUtilityBill') -> "bool":
        return _openstudioutilitiesdata.CalibrationResult_addUtilityBill(self, utilityBill)
    __swig_destroy__ = _openstudioutilitiesdata.delete_CalibrationResult
    __del__ = lambda self: None
CalibrationResult_swigregister = _openstudioutilitiesdata.CalibrationResult_swigregister
CalibrationResult_swigregister(CalibrationResult)

def CalibrationResult_attributeName() -> "std::string":
    return _openstudioutilitiesdata.CalibrationResult_attributeName()
CalibrationResult_attributeName = _openstudioutilitiesdata.CalibrationResult_attributeName

def CalibrationResult_fromAttribute(attribute: 'Attribute') -> "boost::optional< openstudio::CalibrationResult >":
    return _openstudioutilitiesdata.CalibrationResult_fromAttribute(attribute)
CalibrationResult_fromAttribute = _openstudioutilitiesdata.CalibrationResult_fromAttribute

class OptionalEndUses(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalEndUses, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalEndUses, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalEndUses(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalEndUses_reset(self)

    def __ref__(self) -> "openstudio::EndUses":
        return _openstudioutilitiesdata.OptionalEndUses___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUses_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalEndUses_isNull(self)

    def get(self) -> "openstudio::EndUses":
        return _openstudioutilitiesdata.OptionalEndUses_get(self)

    def set(self, t: 'EndUses') -> "void":
        return _openstudioutilitiesdata.OptionalEndUses_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalEndUses
    __del__ = lambda self: None
OptionalEndUses_swigregister = _openstudioutilitiesdata.OptionalEndUses_swigregister
OptionalEndUses_swigregister(OptionalEndUses)

class EndUsesVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUsesVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUsesVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.EndUsesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector___len__(self)

    def pop(self) -> "std::vector< openstudio::EndUses >::value_type":
        return _openstudioutilitiesdata.EndUsesVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::EndUses >::difference_type', j: 'std::vector< openstudio::EndUses >::difference_type') -> "std::vector< openstudio::EndUses,std::allocator< openstudio::EndUses > > *":
        return _openstudioutilitiesdata.EndUsesVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::EndUses >::difference_type', j: 'std::vector< openstudio::EndUses >::difference_type') -> "void":
        return _openstudioutilitiesdata.EndUsesVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector___setitem__(self, *args)

    def append(self, x: 'EndUses') -> "void":
        return _openstudioutilitiesdata.EndUsesVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.EndUsesVector_empty(self)

    def size(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_clear(self)

    def swap(self, v: 'EndUsesVector') -> "void":
        return _openstudioutilitiesdata.EndUsesVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::EndUses >::allocator_type":
        return _openstudioutilitiesdata.EndUsesVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_begin(self)

    def end(self) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::EndUses >::reverse_iterator":
        return _openstudioutilitiesdata.EndUsesVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::EndUses >::reverse_iterator":
        return _openstudioutilitiesdata.EndUsesVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::EndUses >::iterator":
        return _openstudioutilitiesdata.EndUsesVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_EndUsesVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'EndUses') -> "void":
        return _openstudioutilitiesdata.EndUsesVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector_front(self)

    def back(self) -> "std::vector< openstudio::EndUses >::value_type const &":
        return _openstudioutilitiesdata.EndUsesVector_back(self)

    def assign(self, n: 'std::vector< openstudio::EndUses >::size_type', x: 'EndUses') -> "void":
        return _openstudioutilitiesdata.EndUsesVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUsesVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::EndUses >::size_type') -> "void":
        return _openstudioutilitiesdata.EndUsesVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::EndUses >::size_type":
        return _openstudioutilitiesdata.EndUsesVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUsesVector
    __del__ = lambda self: None
EndUsesVector_swigregister = _openstudioutilitiesdata.EndUsesVector_swigregister
EndUsesVector_swigregister(EndUsesVector)

class EndUses(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndUses, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EndUses, name)
    __repr__ = _swig_repr
    __swig_getmethods__["attributeName"] = lambda x: _openstudioutilitiesdata.EndUses_attributeName
    if _newclass:
        attributeName = staticmethod(_openstudioutilitiesdata.EndUses_attributeName)
    __swig_getmethods__["getUnitsForFuelType"] = lambda x: _openstudioutilitiesdata.EndUses_getUnitsForFuelType
    if _newclass:
        getUnitsForFuelType = staticmethod(_openstudioutilitiesdata.EndUses_getUnitsForFuelType)
    __swig_getmethods__["fuelTypes"] = lambda x: _openstudioutilitiesdata.EndUses_fuelTypes
    if _newclass:
        fuelTypes = staticmethod(_openstudioutilitiesdata.EndUses_fuelTypes)
    __swig_getmethods__["categories"] = lambda x: _openstudioutilitiesdata.EndUses_categories
    if _newclass:
        categories = staticmethod(_openstudioutilitiesdata.EndUses_categories)
    __swig_getmethods__["fromAttribute"] = lambda x: _openstudioutilitiesdata.EndUses_fromAttribute
    if _newclass:
        fromAttribute = staticmethod(_openstudioutilitiesdata.EndUses_fromAttribute)

    def __init__(self):
        this = _openstudioutilitiesdata.new_EndUses()
        try:
            self.this.append(this)
        except:
            self.this = this

    def attribute(self) -> "openstudio::Attribute":
        return _openstudioutilitiesdata.EndUses_attribute(self)

    def addEndUse(self, *args) -> "void":
        return _openstudioutilitiesdata.EndUses_addEndUse(self, *args)

    def getEndUse(self, *args) -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUse(self, *args)

    def getEndUseByCategory(self, *args) -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUseByCategory(self, *args)

    def getEndUseByFuelType(self, fuelType: 'EndUseFuelType') -> "double":
        return _openstudioutilitiesdata.EndUses_getEndUseByFuelType(self, fuelType)

    def subCategories(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _openstudioutilitiesdata.EndUses_subCategories(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_EndUses
    __del__ = lambda self: None
EndUses_swigregister = _openstudioutilitiesdata.EndUses_swigregister
EndUses_swigregister(EndUses)

def EndUses_attributeName() -> "std::string":
    return _openstudioutilitiesdata.EndUses_attributeName()
EndUses_attributeName = _openstudioutilitiesdata.EndUses_attributeName

def EndUses_getUnitsForFuelType(fuelType: 'EndUseFuelType') -> "std::string":
    return _openstudioutilitiesdata.EndUses_getUnitsForFuelType(fuelType)
EndUses_getUnitsForFuelType = _openstudioutilitiesdata.EndUses_getUnitsForFuelType

def EndUses_fuelTypes() -> "std::vector< openstudio::EndUseFuelType,std::allocator< openstudio::EndUseFuelType > >":
    return _openstudioutilitiesdata.EndUses_fuelTypes()
EndUses_fuelTypes = _openstudioutilitiesdata.EndUses_fuelTypes

def EndUses_categories() -> "std::vector< openstudio::EndUseCategoryType,std::allocator< openstudio::EndUseCategoryType > >":
    return _openstudioutilitiesdata.EndUses_categories()
EndUses_categories = _openstudioutilitiesdata.EndUses_categories

def EndUses_fromAttribute(attribute: 'Attribute') -> "boost::optional< openstudio::EndUses >":
    return _openstudioutilitiesdata.EndUses_fromAttribute(attribute)
EndUses_fromAttribute = _openstudioutilitiesdata.EndUses_fromAttribute

class DoubleFromVectorFunctor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleFromVectorFunctor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleFromVectorFunctor, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _openstudioutilitiesdata.new_DoubleFromVectorFunctor()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_DoubleFromVectorFunctor
    __del__ = lambda self: None
DoubleFromVectorFunctor_swigregister = _openstudioutilitiesdata.DoubleFromVectorFunctor_swigregister
DoubleFromVectorFunctor_swigregister(DoubleFromVectorFunctor)

class VectorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.VectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector___len__(self)

    def pop(self) -> "std::vector< openstudio::Vector >::value_type":
        return _openstudioutilitiesdata.VectorVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::Vector >::difference_type', j: 'std::vector< openstudio::Vector >::difference_type') -> "std::vector< openstudio::Vector,std::allocator< openstudio::Vector > > *":
        return _openstudioutilitiesdata.VectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::Vector >::difference_type', j: 'std::vector< openstudio::Vector >::difference_type') -> "void":
        return _openstudioutilitiesdata.VectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector___setitem__(self, *args)

    def append(self, x: 'Vector') -> "void":
        return _openstudioutilitiesdata.VectorVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.VectorVector_empty(self)

    def size(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.VectorVector_clear(self)

    def swap(self, v: 'VectorVector') -> "void":
        return _openstudioutilitiesdata.VectorVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::Vector >::allocator_type":
        return _openstudioutilitiesdata.VectorVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_begin(self)

    def end(self) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Vector >::reverse_iterator":
        return _openstudioutilitiesdata.VectorVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Vector >::reverse_iterator":
        return _openstudioutilitiesdata.VectorVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.VectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Vector >::iterator":
        return _openstudioutilitiesdata.VectorVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_VectorVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Vector') -> "void":
        return _openstudioutilitiesdata.VectorVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector_front(self)

    def back(self) -> "std::vector< openstudio::Vector >::value_type const &":
        return _openstudioutilitiesdata.VectorVector_back(self)

    def assign(self, n: 'std::vector< openstudio::Vector >::size_type', x: 'Vector') -> "void":
        return _openstudioutilitiesdata.VectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.VectorVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::Vector >::size_type') -> "void":
        return _openstudioutilitiesdata.VectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Vector >::size_type":
        return _openstudioutilitiesdata.VectorVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_VectorVector
    __del__ = lambda self: None
VectorVector_swigregister = _openstudioutilitiesdata.VectorVector_swigregister
VectorVector_swigregister(VectorVector)

class Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_Vector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def size(self) -> "unsigned int":
        return _openstudioutilitiesdata.Vector_size(self)

    def resize(self, N: 'unsigned int', preserve: 'bool') -> "void":
        return _openstudioutilitiesdata.Vector_resize(self, N, preserve)

    def __len__(self) -> "unsigned int":
        return _openstudioutilitiesdata.Vector___len__(self)

    def __getitem__(self, i: 'unsigned int') -> "double":
        return _openstudioutilitiesdata.Vector___getitem__(self, i)

    def __setitem__(self, i: 'unsigned int', x: 'double') -> "void":
        return _openstudioutilitiesdata.Vector___setitem__(self, i, x)

    def __eq__(self, other: 'Vector') -> "bool":
        return _openstudioutilitiesdata.Vector___eq__(self, other)

    def __add__(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___add__(self, *args)

    def __sub__(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___sub__(self, *args)

    def __mul__(self, d: 'double') -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___mul__(self, d)

    def __div__(self, d: 'double') -> "openstudio::Vector":
        return _openstudioutilitiesdata.Vector___div__(self, d)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Vector___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Vector
    __del__ = lambda self: None
Vector_swigregister = _openstudioutilitiesdata.Vector_swigregister
Vector_swigregister(Vector)


def createVector(values: 'DoubleVector') -> "openstudio::Vector":
    return _openstudioutilitiesdata.createVector(values)
createVector = _openstudioutilitiesdata.createVector

def __eq__(*args) -> "bool":
    return _openstudioutilitiesdata.__eq__(*args)
__eq__ = _openstudioutilitiesdata.__eq__

def __ne__(*args) -> "bool":
    return _openstudioutilitiesdata.__ne__(*args)
__ne__ = _openstudioutilitiesdata.__ne__

_openstudioutilitiesdata.LinearInterp_swigconstant(_openstudioutilitiesdata)
LinearInterp = _openstudioutilitiesdata.LinearInterp

_openstudioutilitiesdata.NearestInterp_swigconstant(_openstudioutilitiesdata)
NearestInterp = _openstudioutilitiesdata.NearestInterp

_openstudioutilitiesdata.HoldLastInterp_swigconstant(_openstudioutilitiesdata)
HoldLastInterp = _openstudioutilitiesdata.HoldLastInterp

_openstudioutilitiesdata.HoldNextInterp_swigconstant(_openstudioutilitiesdata)
HoldNextInterp = _openstudioutilitiesdata.HoldNextInterp

_openstudioutilitiesdata.NoneExtrap_swigconstant(_openstudioutilitiesdata)
NoneExtrap = _openstudioutilitiesdata.NoneExtrap

_openstudioutilitiesdata.NearestExtrap_swigconstant(_openstudioutilitiesdata)
NearestExtrap = _openstudioutilitiesdata.NearestExtrap
class InterpInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["extrapolated"] = _openstudioutilitiesdata.InterpInfo_extrapolated_set
    __swig_getmethods__["extrapolated"] = _openstudioutilitiesdata.InterpInfo_extrapolated_get
    if _newclass:
        extrapolated = _swig_property(_openstudioutilitiesdata.InterpInfo_extrapolated_get, _openstudioutilitiesdata.InterpInfo_extrapolated_set)
    __swig_setmethods__["ia"] = _openstudioutilitiesdata.InterpInfo_ia_set
    __swig_getmethods__["ia"] = _openstudioutilitiesdata.InterpInfo_ia_get
    if _newclass:
        ia = _swig_property(_openstudioutilitiesdata.InterpInfo_ia_get, _openstudioutilitiesdata.InterpInfo_ia_set)
    __swig_setmethods__["ib"] = _openstudioutilitiesdata.InterpInfo_ib_set
    __swig_getmethods__["ib"] = _openstudioutilitiesdata.InterpInfo_ib_get
    if _newclass:
        ib = _swig_property(_openstudioutilitiesdata.InterpInfo_ib_get, _openstudioutilitiesdata.InterpInfo_ib_set)
    __swig_setmethods__["wa"] = _openstudioutilitiesdata.InterpInfo_wa_set
    __swig_getmethods__["wa"] = _openstudioutilitiesdata.InterpInfo_wa_get
    if _newclass:
        wa = _swig_property(_openstudioutilitiesdata.InterpInfo_wa_get, _openstudioutilitiesdata.InterpInfo_wa_set)
    __swig_setmethods__["wb"] = _openstudioutilitiesdata.InterpInfo_wb_set
    __swig_getmethods__["wb"] = _openstudioutilitiesdata.InterpInfo_wb_get
    if _newclass:
        wb = _swig_property(_openstudioutilitiesdata.InterpInfo_wb_get, _openstudioutilitiesdata.InterpInfo_wb_set)

    def __init__(self):
        this = _openstudioutilitiesdata.new_InterpInfo()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_InterpInfo
    __del__ = lambda self: None
InterpInfo_swigregister = _openstudioutilitiesdata.InterpInfo_swigregister
InterpInfo_swigregister(InterpInfo)


def interpInfo(x: 'Vector', xi: 'double') -> "openstudio::InterpInfo":
    return _openstudioutilitiesdata.interpInfo(x, xi)
interpInfo = _openstudioutilitiesdata.interpInfo

def randVector(a: 'double', b: 'double', N: 'unsigned int') -> "openstudio::Vector":
    return _openstudioutilitiesdata.randVector(a, b, N)
randVector = _openstudioutilitiesdata.randVector

def linspace(a: 'double', b: 'double', N: 'unsigned int') -> "openstudio::Vector":
    return _openstudioutilitiesdata.linspace(a, b, N)
linspace = _openstudioutilitiesdata.linspace

def deltaSpace(a: 'double', b: 'double', delta: 'double') -> "openstudio::Vector":
    return _openstudioutilitiesdata.deltaSpace(a, b, delta)
deltaSpace = _openstudioutilitiesdata.deltaSpace

def logspace(a: 'double', b: 'double', N: 'unsigned int', base: 'double'=10.0) -> "openstudio::Vector":
    return _openstudioutilitiesdata.logspace(a, b, N, base)
logspace = _openstudioutilitiesdata.logspace

def cumsum(x: 'Vector', runningSum: 'double'=0.0) -> "openstudio::Vector":
    return _openstudioutilitiesdata.cumsum(x, runningSum)
cumsum = _openstudioutilitiesdata.cumsum

def dot(*args) -> "double":
    return _openstudioutilitiesdata.dot(*args)
dot = _openstudioutilitiesdata.dot

def variance(vector: 'Vector') -> "double":
    return _openstudioutilitiesdata.variance(vector)
variance = _openstudioutilitiesdata.variance

def stdDev(vector: 'Vector') -> "double":
    return _openstudioutilitiesdata.stdDev(vector)
stdDev = _openstudioutilitiesdata.stdDev

def sumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.sumVectorFunctor()
sumVectorFunctor = _openstudioutilitiesdata.sumVectorFunctor

def maximumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.maximumVectorFunctor()
maximumVectorFunctor = _openstudioutilitiesdata.maximumVectorFunctor

def minimumVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.minimumVectorFunctor()
minimumVectorFunctor = _openstudioutilitiesdata.minimumVectorFunctor

def meanVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.meanVectorFunctor()
meanVectorFunctor = _openstudioutilitiesdata.meanVectorFunctor

def varianceVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.varianceVectorFunctor()
varianceVectorFunctor = _openstudioutilitiesdata.varianceVectorFunctor

def stdDevVectorFunctor() -> "boost::function1< double,openstudio::Vector const & >":
    return _openstudioutilitiesdata.stdDevVectorFunctor()
stdDevVectorFunctor = _openstudioutilitiesdata.stdDevVectorFunctor

def evaluateDoubleFromVectorFunctor(functor: 'DoubleFromVectorFunctor', vector: 'Vector') -> "double":
    return _openstudioutilitiesdata.evaluateDoubleFromVectorFunctor(functor, vector)
evaluateDoubleFromVectorFunctor = _openstudioutilitiesdata.evaluateDoubleFromVectorFunctor
class MatrixVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.MatrixVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector___len__(self)

    def pop(self) -> "std::vector< openstudio::Matrix >::value_type":
        return _openstudioutilitiesdata.MatrixVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::Matrix >::difference_type', j: 'std::vector< openstudio::Matrix >::difference_type') -> "std::vector< openstudio::Matrix,std::allocator< openstudio::Matrix > > *":
        return _openstudioutilitiesdata.MatrixVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::Matrix >::difference_type', j: 'std::vector< openstudio::Matrix >::difference_type') -> "void":
        return _openstudioutilitiesdata.MatrixVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector___setitem__(self, *args)

    def append(self, x: 'Matrix') -> "void":
        return _openstudioutilitiesdata.MatrixVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.MatrixVector_empty(self)

    def size(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.MatrixVector_clear(self)

    def swap(self, v: 'MatrixVector') -> "void":
        return _openstudioutilitiesdata.MatrixVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::Matrix >::allocator_type":
        return _openstudioutilitiesdata.MatrixVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_begin(self)

    def end(self) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::Matrix >::reverse_iterator":
        return _openstudioutilitiesdata.MatrixVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::Matrix >::reverse_iterator":
        return _openstudioutilitiesdata.MatrixVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.MatrixVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::Matrix >::iterator":
        return _openstudioutilitiesdata.MatrixVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_MatrixVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'Matrix') -> "void":
        return _openstudioutilitiesdata.MatrixVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector_front(self)

    def back(self) -> "std::vector< openstudio::Matrix >::value_type const &":
        return _openstudioutilitiesdata.MatrixVector_back(self)

    def assign(self, n: 'std::vector< openstudio::Matrix >::size_type', x: 'Matrix') -> "void":
        return _openstudioutilitiesdata.MatrixVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.MatrixVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::Matrix >::size_type') -> "void":
        return _openstudioutilitiesdata.MatrixVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::Matrix >::size_type":
        return _openstudioutilitiesdata.MatrixVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_MatrixVector
    __del__ = lambda self: None
MatrixVector_swigregister = _openstudioutilitiesdata.MatrixVector_swigregister
MatrixVector_swigregister(MatrixVector)

class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_Matrix(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def size1(self) -> "unsigned int":
        return _openstudioutilitiesdata.Matrix_size1(self)

    def size2(self) -> "unsigned int":
        return _openstudioutilitiesdata.Matrix_size2(self)

    def resize(self, M: 'unsigned int', N: 'unsigned int', preserve: 'bool') -> "void":
        return _openstudioutilitiesdata.Matrix_resize(self, M, N, preserve)

    def __getitem__(self, i: 'unsigned int') -> "double":
        return _openstudioutilitiesdata.Matrix___getitem__(self, i)

    def __setitem__(self, i: 'unsigned int', x: 'double') -> "void":
        return _openstudioutilitiesdata.Matrix___setitem__(self, i, x)

    def __eq__(self, other: 'Matrix') -> "bool":
        return _openstudioutilitiesdata.Matrix___eq__(self, other)

    def __add__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___add__(self, *args)

    def __sub__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___sub__(self, *args)

    def __mul__(self, *args) -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___mul__(self, *args)

    def __div__(self, d: 'double') -> "openstudio::Matrix":
        return _openstudioutilitiesdata.Matrix___div__(self, d)

    def __str__(self) -> "std::string":
        return _openstudioutilitiesdata.Matrix___str__(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Matrix
    __del__ = lambda self: None
Matrix_swigregister = _openstudioutilitiesdata.Matrix_swigregister
Matrix_swigregister(Matrix)


def interp(*args) -> "openstudio::Matrix":
    return _openstudioutilitiesdata.interp(*args)
interp = _openstudioutilitiesdata.interp

def outerProd(lhs: 'Vector', rhs: 'Vector') -> "openstudio::Matrix":
    return _openstudioutilitiesdata.outerProd(lhs, rhs)
outerProd = _openstudioutilitiesdata.outerProd

def log(*args) -> "openstudio::Matrix":
    return _openstudioutilitiesdata.log(*args)
log = _openstudioutilitiesdata.log

def randMatrix(a: 'double', b: 'double', M: 'unsigned int', N: 'unsigned int') -> "openstudio::Matrix":
    return _openstudioutilitiesdata.randMatrix(a, b, M, N)
randMatrix = _openstudioutilitiesdata.randMatrix

def maximum(*args) -> "double":
    return _openstudioutilitiesdata.maximum(*args)
maximum = _openstudioutilitiesdata.maximum

def minimum(*args) -> "double":
    return _openstudioutilitiesdata.minimum(*args)
minimum = _openstudioutilitiesdata.minimum

def mean(*args) -> "double":
    return _openstudioutilitiesdata.mean(*args)
mean = _openstudioutilitiesdata.mean
class TimeSeriesPtr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesPtr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesPtr, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _openstudioutilitiesdata.new_TimeSeriesPtr()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesPtr
    __del__ = lambda self: None
TimeSeriesPtr_swigregister = _openstudioutilitiesdata.TimeSeriesPtr_swigregister
TimeSeriesPtr_swigregister(TimeSeriesPtr)

class OptionalTimeSeries(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalTimeSeries, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalTimeSeries, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_OptionalTimeSeries(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudioutilitiesdata.OptionalTimeSeries_reset(self)

    def __ref__(self) -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.OptionalTimeSeries___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTimeSeries_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudioutilitiesdata.OptionalTimeSeries_isNull(self)

    def get(self) -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.OptionalTimeSeries_get(self)

    def set(self, t: 'TimeSeries') -> "void":
        return _openstudioutilitiesdata.OptionalTimeSeries_set(self, t)
    __swig_destroy__ = _openstudioutilitiesdata.delete_OptionalTimeSeries
    __del__ = lambda self: None
OptionalTimeSeries_swigregister = _openstudioutilitiesdata.OptionalTimeSeries_swigregister
OptionalTimeSeries_swigregister(OptionalTimeSeries)

class TimeSeriesPtrVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesPtrVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesPtrVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___len__(self)

    def pop(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_pop(self)

    def __getslice__(self, i: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type', j: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type') -> "std::vector< std::shared_ptr< openstudio::TimeSeries >,std::allocator< std::shared_ptr< openstudio::TimeSeries > > > *":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type', j: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::difference_type') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector___setitem__(self, *args)

    def append(self, x: 'TimeSeriesPtr') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_clear(self)

    def swap(self, v: 'TimeSeriesPtrVector') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_swap(self, v)

    def get_allocator(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::allocator_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_get_allocator(self)

    def begin(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::iterator":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_TimeSeriesPtrVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'TimeSeriesPtr') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_back(self)

    def assign(self, n: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type', x: 'TimeSeriesPtr') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type') -> "void":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< openstudio::TimeSeries > >::size_type":
        return _openstudioutilitiesdata.TimeSeriesPtrVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesPtrVector
    __del__ = lambda self: None
TimeSeriesPtrVector_swigregister = _openstudioutilitiesdata.TimeSeriesPtrVector_swigregister
TimeSeriesPtrVector_swigregister(TimeSeriesPtrVector)

class TimeSeriesVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudioutilitiesdata.TimeSeriesVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector___len__(self)

    def pop(self) -> "std::vector< openstudio::TimeSeries >::value_type":
        return _openstudioutilitiesdata.TimeSeriesVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::TimeSeries >::difference_type', j: 'std::vector< openstudio::TimeSeries >::difference_type') -> "std::vector< openstudio::TimeSeries,std::allocator< openstudio::TimeSeries > > *":
        return _openstudioutilitiesdata.TimeSeriesVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::TimeSeries >::difference_type', j: 'std::vector< openstudio::TimeSeries >::difference_type') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector___setitem__(self, *args)

    def append(self, x: 'TimeSeries') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudioutilitiesdata.TimeSeriesVector_empty(self)

    def size(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector_size(self)

    def clear(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_clear(self)

    def swap(self, v: 'TimeSeriesVector') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::TimeSeries >::allocator_type":
        return _openstudioutilitiesdata.TimeSeriesVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_begin(self)

    def end(self) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::TimeSeries >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::TimeSeries >::reverse_iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::TimeSeries >::iterator":
        return _openstudioutilitiesdata.TimeSeriesVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_TimeSeriesVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'TimeSeries') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector_front(self)

    def back(self) -> "std::vector< openstudio::TimeSeries >::value_type const &":
        return _openstudioutilitiesdata.TimeSeriesVector_back(self)

    def assign(self, n: 'std::vector< openstudio::TimeSeries >::size_type', x: 'TimeSeries') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::TimeSeries >::size_type') -> "void":
        return _openstudioutilitiesdata.TimeSeriesVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::TimeSeries >::size_type":
        return _openstudioutilitiesdata.TimeSeriesVector_capacity(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesVector
    __del__ = lambda self: None
TimeSeriesVector_swigregister = _openstudioutilitiesdata.TimeSeriesVector_swigregister
TimeSeriesVector_swigregister(TimeSeriesVector)

class TimeSeriesFromTimeSeriesVectorFunctor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesFromTimeSeriesVectorFunctor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesFromTimeSeriesVectorFunctor, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _openstudioutilitiesdata.new_TimeSeriesFromTimeSeriesVectorFunctor()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeriesFromTimeSeriesVectorFunctor
    __del__ = lambda self: None
TimeSeriesFromTimeSeriesVectorFunctor_swigregister = _openstudioutilitiesdata.TimeSeriesFromTimeSeriesVectorFunctor_swigregister
TimeSeriesFromTimeSeriesVectorFunctor_swigregister(TimeSeriesFromTimeSeriesVectorFunctor)

class TimeSeries(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeries, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeries, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_TimeSeries(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudioutilitiesdata.delete_TimeSeries
    __del__ = lambda self: None

    def intervalLength(self) -> "openstudio::OptionalTime":
        return _openstudioutilitiesdata.TimeSeries_intervalLength(self)

    def dateTimes(self) -> "openstudio::DateTimeVector":
        return _openstudioutilitiesdata.TimeSeries_dateTimes(self)

    def firstReportDateTime(self) -> "openstudio::DateTime":
        return _openstudioutilitiesdata.TimeSeries_firstReportDateTime(self)

    def daysFromFirstReport(self, *args) -> "double":
        return _openstudioutilitiesdata.TimeSeries_daysFromFirstReport(self, *args)

    def secondsFromFirstReport(self, *args) -> "long":
        return _openstudioutilitiesdata.TimeSeries_secondsFromFirstReport(self, *args)

    def units(self) -> "std::string const":
        return _openstudioutilitiesdata.TimeSeries_units(self)

    def value(self, *args) -> "double":
        return _openstudioutilitiesdata.TimeSeries_value(self, *args)

    def values(self, *args) -> "openstudio::Vector":
        return _openstudioutilitiesdata.TimeSeries_values(self, *args)

    def outOfRangeValue(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_outOfRangeValue(self)

    def setOutOfRangeValue(self, value: 'double') -> "void":
        return _openstudioutilitiesdata.TimeSeries_setOutOfRangeValue(self, value)

    def __add__(self, other: 'TimeSeries') -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___add__(self, other)

    def __sub__(self, other: 'TimeSeries') -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___sub__(self, other)

    def __mul__(self, d: 'double') -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___mul__(self, d)

    def __div__(self, d: 'double') -> "openstudio::TimeSeries":
        return _openstudioutilitiesdata.TimeSeries___div__(self, d)

    def integrate(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_integrate(self)

    def averageValue(self) -> "double":
        return _openstudioutilitiesdata.TimeSeries_averageValue(self)
TimeSeries_swigregister = _openstudioutilitiesdata.TimeSeries_swigregister
TimeSeries_swigregister(TimeSeries)


def __mul__(*args) -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.__mul__(*args)
__mul__ = _openstudioutilitiesdata.__mul__

def sum(*args) -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.sum(*args)
sum = _openstudioutilitiesdata.sum

def sumTimeSeriesFunctor() -> "boost::function1< openstudio::TimeSeries,std::vector< openstudio::TimeSeries,std::allocator< openstudio::TimeSeries > > const & >":
    return _openstudioutilitiesdata.sumTimeSeriesFunctor()
sumTimeSeriesFunctor = _openstudioutilitiesdata.sumTimeSeriesFunctor

def evaluateTimeSeriesFromTimeSeriesVectorFunctor(functor: 'TimeSeriesFromTimeSeriesVectorFunctor', timeSeriesVector: 'TimeSeriesVector') -> "openstudio::TimeSeries":
    return _openstudioutilitiesdata.evaluateTimeSeriesFromTimeSeriesVectorFunctor(functor, timeSeriesVector)
evaluateTimeSeriesFromTimeSeriesVectorFunctor = _openstudioutilitiesdata.evaluateTimeSeriesFromTimeSeriesVectorFunctor
class Tag(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tag, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudioutilitiesdata.new_Tag(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def clone(self) -> "openstudio::Tag":
        return _openstudioutilitiesdata.Tag_clone(self)

    def uuid(self) -> "openstudio::UUID":
        return _openstudioutilitiesdata.Tag_uuid(self)

    def name(self) -> "std::string":
        return _openstudioutilitiesdata.Tag_name(self)
    __swig_destroy__ = _openstudioutilitiesdata.delete_Tag
    __del__ = lambda self: None
Tag_swigregister = _openstudioutilitiesdata.Tag_swigregister
Tag_swigregister(Tag)

# This file is compatible with both classic and new-style classes.


