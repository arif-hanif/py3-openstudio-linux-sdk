# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_openstudiomodelavailabilitymanager', [dirname(__file__)])
        except ImportError:
            import _openstudiomodelavailabilitymanager
            return _openstudiomodelavailabilitymanager
        if fp is not None:
            try:
                _mod = imp.load_module('_openstudiomodelavailabilitymanager', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _openstudiomodelavailabilitymanager = swig_import_helper()
    del swig_import_helper
else:
    import _openstudiomodelavailabilitymanager
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _openstudiomodelavailabilitymanager.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _openstudiomodelavailabilitymanager.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_openstudiomodelavailabilitymanager.SHARED_PTR_DISOWN_swigconstant(_openstudiomodelavailabilitymanager)
SHARED_PTR_DISOWN = _openstudiomodelavailabilitymanager.SHARED_PTR_DISOWN
import openstudioutilities
import openstudioutilitiescore
import openstudioutilitiestime
import openstudioutilitiesdata
import openstudioutilitiesunits
import openstudioutilitiesplot
import openstudioutilitiesgeometry
import openstudioutilitiessql
import openstudioutilitiesbcl
import openstudioutilitiesidd
import openstudioutilitiesidf
import openstudioutilitiesfiletypes
import openstudiomodelcore
import openstudiomodelsimulation
import openstudiomodelresources
import openstudiomodelgeometry
import openstudiomodelhvac
class AvailabilityManagerNightCycleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerNightCycleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerNightCycleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerNightCycle,std::allocator< openstudio::model::AvailabilityManagerNightCycle > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerNightCycle') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_clear(self)

    def swap(self, v: 'AvailabilityManagerNightCycleVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerNightCycleVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerNightCycle') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type', x: 'AvailabilityManagerNightCycle') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type', x: 'AvailabilityManagerNightCycle') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerNightCycle >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerNightCycleVector
    __del__ = lambda self: None
AvailabilityManagerNightCycleVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycleVector_swigregister
AvailabilityManagerNightCycleVector_swigregister(AvailabilityManagerNightCycleVector)

class OptionalAvailabilityManagerNightCycle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerNightCycle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerNightCycle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerNightCycle(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerNightCycle":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerNightCycle":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_get(self)

    def set(self, t: 'AvailabilityManagerNightCycle') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerNightCycle
    __del__ = lambda self: None
OptionalAvailabilityManagerNightCycle_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightCycle_swigregister
OptionalAvailabilityManagerNightCycle_swigregister(OptionalAvailabilityManagerNightCycle)

class AvailabilityManagerHybridVentilationVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHybridVentilationVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHybridVentilationVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation,std::allocator< openstudio::model::AvailabilityManagerHybridVentilation > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerHybridVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_clear(self)

    def swap(self, v: 'AvailabilityManagerHybridVentilationVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHybridVentilationVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerHybridVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type', x: 'AvailabilityManagerHybridVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type', x: 'AvailabilityManagerHybridVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHybridVentilationVector
    __del__ = lambda self: None
AvailabilityManagerHybridVentilationVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilationVector_swigregister
AvailabilityManagerHybridVentilationVector_swigregister(AvailabilityManagerHybridVentilationVector)

class OptionalAvailabilityManagerHybridVentilation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerHybridVentilation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerHybridVentilation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerHybridVentilation(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerHybridVentilation":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerHybridVentilation":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_get(self)

    def set(self, t: 'AvailabilityManagerHybridVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerHybridVentilation
    __del__ = lambda self: None
OptionalAvailabilityManagerHybridVentilation_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHybridVentilation_swigregister
OptionalAvailabilityManagerHybridVentilation_swigregister(OptionalAvailabilityManagerHybridVentilation)

class AvailabilityManagerOptimumStartVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerOptimumStartVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerOptimumStartVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart,std::allocator< openstudio::model::AvailabilityManagerOptimumStart > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerOptimumStart') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_clear(self)

    def swap(self, v: 'AvailabilityManagerOptimumStartVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerOptimumStartVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerOptimumStart') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type', x: 'AvailabilityManagerOptimumStart') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type', x: 'AvailabilityManagerOptimumStart') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerOptimumStartVector
    __del__ = lambda self: None
AvailabilityManagerOptimumStartVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStartVector_swigregister
AvailabilityManagerOptimumStartVector_swigregister(AvailabilityManagerOptimumStartVector)

class OptionalAvailabilityManagerOptimumStart(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerOptimumStart, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerOptimumStart, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerOptimumStart(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerOptimumStart":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerOptimumStart":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_get(self)

    def set(self, t: 'AvailabilityManagerOptimumStart') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerOptimumStart
    __del__ = lambda self: None
OptionalAvailabilityManagerOptimumStart_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerOptimumStart_swigregister
OptionalAvailabilityManagerOptimumStart_swigregister(OptionalAvailabilityManagerOptimumStart)

class AvailabilityManagerDifferentialThermostatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerDifferentialThermostatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerDifferentialThermostatVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat,std::allocator< openstudio::model::AvailabilityManagerDifferentialThermostat > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerDifferentialThermostat') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_clear(self)

    def swap(self, v: 'AvailabilityManagerDifferentialThermostatVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerDifferentialThermostatVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerDifferentialThermostat') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type', x: 'AvailabilityManagerDifferentialThermostat') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type', x: 'AvailabilityManagerDifferentialThermostat') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerDifferentialThermostatVector
    __del__ = lambda self: None
AvailabilityManagerDifferentialThermostatVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostatVector_swigregister
AvailabilityManagerDifferentialThermostatVector_swigregister(AvailabilityManagerDifferentialThermostatVector)

class OptionalAvailabilityManagerDifferentialThermostat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerDifferentialThermostat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerDifferentialThermostat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerDifferentialThermostat(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerDifferentialThermostat":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerDifferentialThermostat":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_get(self)

    def set(self, t: 'AvailabilityManagerDifferentialThermostat') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerDifferentialThermostat
    __del__ = lambda self: None
OptionalAvailabilityManagerDifferentialThermostat_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerDifferentialThermostat_swigregister
OptionalAvailabilityManagerDifferentialThermostat_swigregister(OptionalAvailabilityManagerDifferentialThermostat)

class AvailabilityManagerNightVentilationVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerNightVentilationVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerNightVentilationVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation,std::allocator< openstudio::model::AvailabilityManagerNightVentilation > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerNightVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_clear(self)

    def swap(self, v: 'AvailabilityManagerNightVentilationVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerNightVentilationVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerNightVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type', x: 'AvailabilityManagerNightVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type', x: 'AvailabilityManagerNightVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerNightVentilationVector
    __del__ = lambda self: None
AvailabilityManagerNightVentilationVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilationVector_swigregister
AvailabilityManagerNightVentilationVector_swigregister(AvailabilityManagerNightVentilationVector)

class OptionalAvailabilityManagerNightVentilation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerNightVentilation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerNightVentilation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerNightVentilation(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerNightVentilation":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerNightVentilation":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_get(self)

    def set(self, t: 'AvailabilityManagerNightVentilation') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerNightVentilation
    __del__ = lambda self: None
OptionalAvailabilityManagerNightVentilation_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerNightVentilation_swigregister
OptionalAvailabilityManagerNightVentilation_swigregister(OptionalAvailabilityManagerNightVentilation)

class AvailabilityManagerHighTemperatureTurnOnVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHighTemperatureTurnOnVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHighTemperatureTurnOnVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOn > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerHighTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_clear(self)

    def swap(self, v: 'AvailabilityManagerHighTemperatureTurnOnVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHighTemperatureTurnOnVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerHighTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type', x: 'AvailabilityManagerHighTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type', x: 'AvailabilityManagerHighTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHighTemperatureTurnOnVector
    __del__ = lambda self: None
AvailabilityManagerHighTemperatureTurnOnVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOnVector_swigregister
AvailabilityManagerHighTemperatureTurnOnVector_swigregister(AvailabilityManagerHighTemperatureTurnOnVector)

class OptionalAvailabilityManagerHighTemperatureTurnOn(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerHighTemperatureTurnOn, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerHighTemperatureTurnOn, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerHighTemperatureTurnOn(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerHighTemperatureTurnOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerHighTemperatureTurnOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_get(self)

    def set(self, t: 'AvailabilityManagerHighTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerHighTemperatureTurnOn
    __del__ = lambda self: None
OptionalAvailabilityManagerHighTemperatureTurnOn_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOn_swigregister
OptionalAvailabilityManagerHighTemperatureTurnOn_swigregister(OptionalAvailabilityManagerHighTemperatureTurnOn)

class AvailabilityManagerHighTemperatureTurnOffVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHighTemperatureTurnOffVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHighTemperatureTurnOffVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOff > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerHighTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_clear(self)

    def swap(self, v: 'AvailabilityManagerHighTemperatureTurnOffVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHighTemperatureTurnOffVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerHighTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type', x: 'AvailabilityManagerHighTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type', x: 'AvailabilityManagerHighTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHighTemperatureTurnOffVector
    __del__ = lambda self: None
AvailabilityManagerHighTemperatureTurnOffVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOffVector_swigregister
AvailabilityManagerHighTemperatureTurnOffVector_swigregister(AvailabilityManagerHighTemperatureTurnOffVector)

class OptionalAvailabilityManagerHighTemperatureTurnOff(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerHighTemperatureTurnOff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerHighTemperatureTurnOff, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerHighTemperatureTurnOff(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerHighTemperatureTurnOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerHighTemperatureTurnOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_get(self)

    def set(self, t: 'AvailabilityManagerHighTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerHighTemperatureTurnOff
    __del__ = lambda self: None
OptionalAvailabilityManagerHighTemperatureTurnOff_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerHighTemperatureTurnOff_swigregister
OptionalAvailabilityManagerHighTemperatureTurnOff_swigregister(OptionalAvailabilityManagerHighTemperatureTurnOff)

class AvailabilityManagerLowTemperatureTurnOnVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerLowTemperatureTurnOnVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerLowTemperatureTurnOnVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOn > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerLowTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_clear(self)

    def swap(self, v: 'AvailabilityManagerLowTemperatureTurnOnVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerLowTemperatureTurnOnVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerLowTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type', x: 'AvailabilityManagerLowTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type', x: 'AvailabilityManagerLowTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerLowTemperatureTurnOnVector
    __del__ = lambda self: None
AvailabilityManagerLowTemperatureTurnOnVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOnVector_swigregister
AvailabilityManagerLowTemperatureTurnOnVector_swigregister(AvailabilityManagerLowTemperatureTurnOnVector)

class OptionalAvailabilityManagerLowTemperatureTurnOn(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerLowTemperatureTurnOn, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerLowTemperatureTurnOn, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerLowTemperatureTurnOn(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerLowTemperatureTurnOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerLowTemperatureTurnOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_get(self)

    def set(self, t: 'AvailabilityManagerLowTemperatureTurnOn') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerLowTemperatureTurnOn
    __del__ = lambda self: None
OptionalAvailabilityManagerLowTemperatureTurnOn_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOn_swigregister
OptionalAvailabilityManagerLowTemperatureTurnOn_swigregister(OptionalAvailabilityManagerLowTemperatureTurnOn)

class AvailabilityManagerLowTemperatureTurnOffVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerLowTemperatureTurnOffVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerLowTemperatureTurnOffVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOff > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerLowTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_clear(self)

    def swap(self, v: 'AvailabilityManagerLowTemperatureTurnOffVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerLowTemperatureTurnOffVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerLowTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type', x: 'AvailabilityManagerLowTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type', x: 'AvailabilityManagerLowTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerLowTemperatureTurnOffVector
    __del__ = lambda self: None
AvailabilityManagerLowTemperatureTurnOffVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOffVector_swigregister
AvailabilityManagerLowTemperatureTurnOffVector_swigregister(AvailabilityManagerLowTemperatureTurnOffVector)

class OptionalAvailabilityManagerLowTemperatureTurnOff(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerLowTemperatureTurnOff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerLowTemperatureTurnOff, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerLowTemperatureTurnOff(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerLowTemperatureTurnOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerLowTemperatureTurnOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_get(self)

    def set(self, t: 'AvailabilityManagerLowTemperatureTurnOff') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerLowTemperatureTurnOff
    __del__ = lambda self: None
OptionalAvailabilityManagerLowTemperatureTurnOff_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerLowTemperatureTurnOff_swigregister
OptionalAvailabilityManagerLowTemperatureTurnOff_swigregister(OptionalAvailabilityManagerLowTemperatureTurnOff)

class AvailabilityManagerScheduledVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduledVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduledVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerScheduled,std::allocator< openstudio::model::AvailabilityManagerScheduled > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerScheduled') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_clear(self)

    def swap(self, v: 'AvailabilityManagerScheduledVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduledVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerScheduled') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type', x: 'AvailabilityManagerScheduled') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type', x: 'AvailabilityManagerScheduled') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduled >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduledVector
    __del__ = lambda self: None
AvailabilityManagerScheduledVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledVector_swigregister
AvailabilityManagerScheduledVector_swigregister(AvailabilityManagerScheduledVector)

class OptionalAvailabilityManagerScheduled(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerScheduled, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerScheduled, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerScheduled(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerScheduled":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerScheduled":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_get(self)

    def set(self, t: 'AvailabilityManagerScheduled') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerScheduled
    __del__ = lambda self: None
OptionalAvailabilityManagerScheduled_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduled_swigregister
OptionalAvailabilityManagerScheduled_swigregister(OptionalAvailabilityManagerScheduled)

class AvailabilityManagerScheduledOnVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduledOnVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduledOnVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn,std::allocator< openstudio::model::AvailabilityManagerScheduledOn > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerScheduledOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_clear(self)

    def swap(self, v: 'AvailabilityManagerScheduledOnVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduledOnVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerScheduledOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type', x: 'AvailabilityManagerScheduledOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type', x: 'AvailabilityManagerScheduledOn') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduledOnVector
    __del__ = lambda self: None
AvailabilityManagerScheduledOnVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOnVector_swigregister
AvailabilityManagerScheduledOnVector_swigregister(AvailabilityManagerScheduledOnVector)

class OptionalAvailabilityManagerScheduledOn(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerScheduledOn, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerScheduledOn, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerScheduledOn(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerScheduledOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerScheduledOn":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_get(self)

    def set(self, t: 'AvailabilityManagerScheduledOn') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerScheduledOn
    __del__ = lambda self: None
OptionalAvailabilityManagerScheduledOn_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOn_swigregister
OptionalAvailabilityManagerScheduledOn_swigregister(OptionalAvailabilityManagerScheduledOn)

class AvailabilityManagerScheduledOffVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduledOffVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduledOffVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___bool__(self)

    def __len__(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___len__(self)

    def pop(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::value_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_pop(self)

    def __getslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::difference_type') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff,std::allocator< openstudio::model::AvailabilityManagerScheduledOff > > *":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::difference_type', j: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::difference_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector___setitem__(self, *args)

    def append(self, x: 'AvailabilityManagerScheduledOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_append(self, x)

    def empty(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_empty(self)

    def size(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_size(self)

    def clear(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_clear(self)

    def swap(self, v: 'AvailabilityManagerScheduledOffVector') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_swap(self, v)

    def get_allocator(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::allocator_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_get_allocator(self)

    def begin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_begin(self)

    def end(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_end(self)

    def rbegin(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_rbegin(self)

    def rend(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::reverse_iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_rend(self)

    def pop_back(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_pop_back(self)

    def erase(self, *args) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::iterator":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_erase(self, *args)

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduledOffVector(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x: 'AvailabilityManagerScheduledOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_push_back(self, x)

    def front(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_front(self)

    def back(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::value_type const &":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_back(self)

    def assign(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type', x: 'AvailabilityManagerScheduledOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_assign(self, n, x)

    def resize(self, new_size: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type', x: 'AvailabilityManagerScheduledOff') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_resize(self, new_size, x)

    def insert(self, *args) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_insert(self, *args)

    def reserve(self, n: 'std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type') -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_reserve(self, n)

    def capacity(self) -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff >::size_type":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_capacity(self)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduledOffVector
    __del__ = lambda self: None
AvailabilityManagerScheduledOffVector_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOffVector_swigregister
AvailabilityManagerScheduledOffVector_swigregister(AvailabilityManagerScheduledOffVector)

class OptionalAvailabilityManagerScheduledOff(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAvailabilityManagerScheduledOff, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAvailabilityManagerScheduledOff, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_OptionalAvailabilityManagerScheduledOff(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def reset(self) -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_reset(self)

    def __ref__(self) -> "openstudio::model::AvailabilityManagerScheduledOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff___ref__(self)

    def is_initialized(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_is_initialized(self)

    def isNull(self) -> "bool":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_isNull(self)

    def get(self) -> "openstudio::model::AvailabilityManagerScheduledOff":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_get(self)

    def set(self, t: 'AvailabilityManagerScheduledOff') -> "void":
        return _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_set(self, t)
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_OptionalAvailabilityManagerScheduledOff
    __del__ = lambda self: None
OptionalAvailabilityManagerScheduledOff_swigregister = _openstudiomodelavailabilitymanager.OptionalAvailabilityManagerScheduledOff_swigregister
OptionalAvailabilityManagerScheduledOff_swigregister(OptionalAvailabilityManagerScheduledOff)

class AvailabilityManagerNightCycle(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerNightCycle, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerNightCycle, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerNightCycle(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerNightCycle
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_iddObjectType)
    __swig_getmethods__["controlTypeValues"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlTypeValues
    if _newclass:
        controlTypeValues = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlTypeValues)

    def controlType(self) -> "std::string":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlType(self)

    def setControlType(self, controlType: 'std::string') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setControlType(self, controlType)

    def resetControlType(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetControlType(self)

    def isControlTypeDefaulted(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_isControlTypeDefaulted(self)

    def thermostatTolerance(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_thermostatTolerance(self)

    def getThermostatTolerance(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_getThermostatTolerance(self, returnIP)

    def setThermostatTolerance(self, *args) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setThermostatTolerance(self, *args)

    def isThermostatToleranceDefaulted(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_isThermostatToleranceDefaulted(self)

    def resetThermostatTolerance(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetThermostatTolerance(self)

    def cyclingRunTime(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTime(self)

    def setCyclingRunTime(self, *args) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setCyclingRunTime(self, *args)

    def resetCyclingRunTime(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetCyclingRunTime(self)

    def getCyclingRunTime(self, returnIP: 'bool'=False) -> "openstudio::Quantity":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_getCyclingRunTime(self, returnIP)

    def isCyclingRunTimeDefaulted(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_isCyclingRunTimeDefaulted(self)
    __swig_getmethods__["cyclingRunTimeControlTypeValues"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues
    if _newclass:
        cyclingRunTimeControlTypeValues = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues)

    def cyclingRunTimeControlType(self) -> "std::string":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTimeControlType(self)

    def isCyclingRunTimeControlTypeDefaulted(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_isCyclingRunTimeControlTypeDefaulted(self)

    def setCyclingRunTimeControlType(self, cyclingRunTimeControlType: 'std::string') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setCyclingRunTimeControlType(self, cyclingRunTimeControlType)

    def resetCyclingRunTimeControlType(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetCyclingRunTimeControlType(self)

    def controlThermalZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlThermalZone(self)

    def setControlThermalZone(self, thermalZone: 'ThermalZone') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setControlThermalZone(self, thermalZone)

    def resetControlThermalZone(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetControlThermalZone(self)

    def controlThermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlThermalZones(self)

    def setControlThermalZones(self, thermalZones: 'ThermalZoneVector') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setControlThermalZones(self, thermalZones)

    def resetControlThermalZones(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetControlThermalZones(self)

    def coolingControlThermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_coolingControlThermalZones(self)

    def setCoolingControlThermalZones(self, thermalZones: 'ThermalZoneVector') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setCoolingControlThermalZones(self, thermalZones)

    def resetCoolingControlThermalZones(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetCoolingControlThermalZones(self)

    def heatingControlThermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_heatingControlThermalZones(self)

    def setHeatingControlThermalZones(self, thermalZones: 'ThermalZoneVector') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setHeatingControlThermalZones(self, thermalZones)

    def resetHeatingControlThermalZones(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetHeatingControlThermalZones(self)

    def heatingZoneFansOnlyThermalZones(self) -> "std::vector< openstudio::model::ThermalZone,std::allocator< openstudio::model::ThermalZone > >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_heatingZoneFansOnlyThermalZones(self)

    def setHeatingZoneFansOnlyThermalZones(self, thermalZones: 'ThermalZoneVector') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_setHeatingZoneFansOnlyThermalZones(self, thermalZones)

    def resetHeatingZoneFansOnlyThermalZones(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_resetHeatingZoneFansOnlyThermalZones(self)
AvailabilityManagerNightCycle_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_swigregister
AvailabilityManagerNightCycle_swigregister(AvailabilityManagerNightCycle)

def AvailabilityManagerNightCycle_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_iddObjectType()
AvailabilityManagerNightCycle_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_iddObjectType

def AvailabilityManagerNightCycle_controlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlTypeValues()
AvailabilityManagerNightCycle_controlTypeValues = _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_controlTypeValues

def AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues()
AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues = _openstudiomodelavailabilitymanager.AvailabilityManagerNightCycle_cyclingRunTimeControlTypeValues


def toAvailabilityManagerNightCycle(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerNightCycle >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerNightCycle(idfObject)
toAvailabilityManagerNightCycle = _openstudiomodelavailabilitymanager.toAvailabilityManagerNightCycle

def getAvailabilityManagerNightCycle(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerNightCycle >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycle(t_model, t_handle)
getAvailabilityManagerNightCycle = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycle

def getAvailabilityManagerNightCycles(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerNightCycle,std::allocator< openstudio::model::AvailabilityManagerNightCycle > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycles(t_model)
getAvailabilityManagerNightCycles = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycles

def getAvailabilityManagerNightCycleByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerNightCycle >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycleByName(t_model, t_name)
getAvailabilityManagerNightCycleByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCycleByName

def getAvailabilityManagerNightCyclesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerNightCycle,std::allocator< openstudio::model::AvailabilityManagerNightCycle > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCyclesByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerNightCyclesByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightCyclesByName
class AvailabilityManagerHybridVentilation(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHybridVentilation, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHybridVentilation, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHybridVentilation(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHybridVentilation
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_iddObjectType)

    def controlledZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_controlledZone(self)

    def ventilationControlModeSchedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_ventilationControlModeSchedule(self)

    def useWeatherFileRainIndicators(self) -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_useWeatherFileRainIndicators(self)

    def maximumWindSpeed(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_maximumWindSpeed(self)

    def minimumOutdoorTemperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_minimumOutdoorTemperature(self)

    def maximumOutdoorTemperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_maximumOutdoorTemperature(self)

    def minimumOutdoorEnthalpy(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_minimumOutdoorEnthalpy(self)

    def maximumOutdoorEnthalpy(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_maximumOutdoorEnthalpy(self)

    def minimumOutdoorDewpoint(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_minimumOutdoorDewpoint(self)

    def maximumOutdoorDewpoint(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_maximumOutdoorDewpoint(self)

    def minimumOutdoorVentilationAirSchedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_minimumOutdoorVentilationAirSchedule(self)

    def openingFactorFunctionofWindSpeedCurve(self) -> "boost::optional< openstudio::model::Curve >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_openingFactorFunctionofWindSpeedCurve(self)

    def setControlledZone(self, thermalZone: 'ThermalZone') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setControlledZone(self, thermalZone)

    def resetControlledZone(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_resetControlledZone(self)

    def setVentilationControlModeSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setVentilationControlModeSchedule(self, schedule)

    def setUseWeatherFileRainIndicators(self, useWeatherFileRainIndicators: 'bool') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setUseWeatherFileRainIndicators(self, useWeatherFileRainIndicators)

    def setMaximumWindSpeed(self, maximumWindSpeed: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMaximumWindSpeed(self, maximumWindSpeed)

    def setMinimumOutdoorTemperature(self, minimumOutdoorTemperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMinimumOutdoorTemperature(self, minimumOutdoorTemperature)

    def setMaximumOutdoorTemperature(self, maximumOutdoorTemperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMaximumOutdoorTemperature(self, maximumOutdoorTemperature)

    def setMinimumOutdoorEnthalpy(self, minimumOutdoorEnthalpy: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMinimumOutdoorEnthalpy(self, minimumOutdoorEnthalpy)

    def setMaximumOutdoorEnthalpy(self, maximumOutdoorEnthalpy: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMaximumOutdoorEnthalpy(self, maximumOutdoorEnthalpy)

    def setMinimumOutdoorDewpoint(self, minimumOutdoorDewpoint: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMinimumOutdoorDewpoint(self, minimumOutdoorDewpoint)

    def setMaximumOutdoorDewpoint(self, maximumOutdoorDewpoint: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMaximumOutdoorDewpoint(self, maximumOutdoorDewpoint)

    def setMinimumOutdoorVentilationAirSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setMinimumOutdoorVentilationAirSchedule(self, schedule)

    def setOpeningFactorFunctionofWindSpeedCurve(self, curve: 'Curve') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_setOpeningFactorFunctionofWindSpeedCurve(self, curve)

    def resetOpeningFactorFunctionofWindSpeedCurve(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_resetOpeningFactorFunctionofWindSpeedCurve(self)
AvailabilityManagerHybridVentilation_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_swigregister
AvailabilityManagerHybridVentilation_swigregister(AvailabilityManagerHybridVentilation)

def AvailabilityManagerHybridVentilation_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_iddObjectType()
AvailabilityManagerHybridVentilation_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerHybridVentilation_iddObjectType


def toAvailabilityManagerHybridVentilation(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerHybridVentilation >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerHybridVentilation(idfObject)
toAvailabilityManagerHybridVentilation = _openstudiomodelavailabilitymanager.toAvailabilityManagerHybridVentilation

def getAvailabilityManagerHybridVentilation(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerHybridVentilation >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilation(t_model, t_handle)
getAvailabilityManagerHybridVentilation = _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilation

def getAvailabilityManagerHybridVentilations(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation,std::allocator< openstudio::model::AvailabilityManagerHybridVentilation > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilations(t_model)
getAvailabilityManagerHybridVentilations = _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilations

def getAvailabilityManagerHybridVentilationByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerHybridVentilation >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilationByName(t_model, t_name)
getAvailabilityManagerHybridVentilationByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilationByName

def getAvailabilityManagerHybridVentilationsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerHybridVentilation,std::allocator< openstudio::model::AvailabilityManagerHybridVentilation > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilationsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerHybridVentilationsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHybridVentilationsByName
class AvailabilityManagerOptimumStart(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerOptimumStart, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerOptimumStart, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerOptimumStart(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerOptimumStart
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_iddObjectType)
    __swig_getmethods__["controlTypeValues"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlTypeValues
    if _newclass:
        controlTypeValues = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlTypeValues)
    __swig_getmethods__["controlAlgorithmValues"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlAlgorithmValues
    if _newclass:
        controlAlgorithmValues = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlAlgorithmValues)

    def applicabilitySchedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_applicabilitySchedule(self)

    def controlType(self) -> "std::string":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlType(self)

    def controlZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlZone(self)

    def maximumValueforOptimumStartTime(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_maximumValueforOptimumStartTime(self)

    def controlAlgorithm(self) -> "std::string":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlAlgorithm(self)

    def constantTemperatureGradientduringCooling(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_constantTemperatureGradientduringCooling(self)

    def constantTemperatureGradientduringHeating(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_constantTemperatureGradientduringHeating(self)

    def initialTemperatureGradientduringCooling(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_initialTemperatureGradientduringCooling(self)

    def initialTemperatureGradientduringHeating(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_initialTemperatureGradientduringHeating(self)

    def constantStartTime(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_constantStartTime(self)

    def numberofPreviousDays(self) -> "int":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_numberofPreviousDays(self)

    def setApplicabilitySchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setApplicabilitySchedule(self, schedule)

    def setControlType(self, controlType: 'std::string') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setControlType(self, controlType)

    def setControlZone(self, thermalZone: 'ThermalZone') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setControlZone(self, thermalZone)

    def resetControlZone(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_resetControlZone(self)

    def setMaximumValueforOptimumStartTime(self, maximumValueforOptimumStartTime: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setMaximumValueforOptimumStartTime(self, maximumValueforOptimumStartTime)

    def setControlAlgorithm(self, controlAlgorithm: 'std::string') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setControlAlgorithm(self, controlAlgorithm)

    def setConstantTemperatureGradientduringCooling(self, constantTemperatureGradientduringCooling: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setConstantTemperatureGradientduringCooling(self, constantTemperatureGradientduringCooling)

    def setConstantTemperatureGradientduringHeating(self, constantTemperatureGradientduringHeating: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setConstantTemperatureGradientduringHeating(self, constantTemperatureGradientduringHeating)

    def setInitialTemperatureGradientduringCooling(self, initialTemperatureGradientduringCooling: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setInitialTemperatureGradientduringCooling(self, initialTemperatureGradientduringCooling)

    def setInitialTemperatureGradientduringHeating(self, initialTemperatureGradientduringHeating: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setInitialTemperatureGradientduringHeating(self, initialTemperatureGradientduringHeating)

    def setConstantStartTime(self, constantStartTime: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setConstantStartTime(self, constantStartTime)

    def setNumberofPreviousDays(self, numberofPreviousDays: 'int') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_setNumberofPreviousDays(self, numberofPreviousDays)
AvailabilityManagerOptimumStart_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_swigregister
AvailabilityManagerOptimumStart_swigregister(AvailabilityManagerOptimumStart)

def AvailabilityManagerOptimumStart_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_iddObjectType()
AvailabilityManagerOptimumStart_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_iddObjectType

def AvailabilityManagerOptimumStart_controlTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlTypeValues()
AvailabilityManagerOptimumStart_controlTypeValues = _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlTypeValues

def AvailabilityManagerOptimumStart_controlAlgorithmValues() -> "std::vector< std::string,std::allocator< std::string > >":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlAlgorithmValues()
AvailabilityManagerOptimumStart_controlAlgorithmValues = _openstudiomodelavailabilitymanager.AvailabilityManagerOptimumStart_controlAlgorithmValues


def toAvailabilityManagerOptimumStart(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerOptimumStart >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerOptimumStart(idfObject)
toAvailabilityManagerOptimumStart = _openstudiomodelavailabilitymanager.toAvailabilityManagerOptimumStart

def getAvailabilityManagerOptimumStart(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerOptimumStart >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStart(t_model, t_handle)
getAvailabilityManagerOptimumStart = _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStart

def getAvailabilityManagerOptimumStarts(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart,std::allocator< openstudio::model::AvailabilityManagerOptimumStart > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStarts(t_model)
getAvailabilityManagerOptimumStarts = _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStarts

def getAvailabilityManagerOptimumStartByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerOptimumStart >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStartByName(t_model, t_name)
getAvailabilityManagerOptimumStartByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStartByName

def getAvailabilityManagerOptimumStartsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerOptimumStart,std::allocator< openstudio::model::AvailabilityManagerOptimumStart > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStartsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerOptimumStartsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerOptimumStartsByName
class AvailabilityManagerDifferentialThermostat(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerDifferentialThermostat, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerDifferentialThermostat, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerDifferentialThermostat(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerDifferentialThermostat
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_iddObjectType)

    def hotNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_hotNode(self)

    def coldNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_coldNode(self)

    def temperatureDifferenceOnLimit(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_temperatureDifferenceOnLimit(self)

    def temperatureDifferenceOffLimit(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_temperatureDifferenceOffLimit(self)

    def setHotNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_setHotNode(self, node)

    def resetHotNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_resetHotNode(self)

    def setColdNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_setColdNode(self, node)

    def resetColdNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_resetColdNode(self)

    def setTemperatureDifferenceOnLimit(self, temperatureDifferenceOnLimit: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_setTemperatureDifferenceOnLimit(self, temperatureDifferenceOnLimit)

    def setTemperatureDifferenceOffLimit(self, temperatureDifferenceOffLimit: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_setTemperatureDifferenceOffLimit(self, temperatureDifferenceOffLimit)
AvailabilityManagerDifferentialThermostat_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_swigregister
AvailabilityManagerDifferentialThermostat_swigregister(AvailabilityManagerDifferentialThermostat)

def AvailabilityManagerDifferentialThermostat_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_iddObjectType()
AvailabilityManagerDifferentialThermostat_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerDifferentialThermostat_iddObjectType


def toAvailabilityManagerDifferentialThermostat(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerDifferentialThermostat >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerDifferentialThermostat(idfObject)
toAvailabilityManagerDifferentialThermostat = _openstudiomodelavailabilitymanager.toAvailabilityManagerDifferentialThermostat

def getAvailabilityManagerDifferentialThermostat(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerDifferentialThermostat >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostat(t_model, t_handle)
getAvailabilityManagerDifferentialThermostat = _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostat

def getAvailabilityManagerDifferentialThermostats(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat,std::allocator< openstudio::model::AvailabilityManagerDifferentialThermostat > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostats(t_model)
getAvailabilityManagerDifferentialThermostats = _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostats

def getAvailabilityManagerDifferentialThermostatByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerDifferentialThermostat >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostatByName(t_model, t_name)
getAvailabilityManagerDifferentialThermostatByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostatByName

def getAvailabilityManagerDifferentialThermostatsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerDifferentialThermostat,std::allocator< openstudio::model::AvailabilityManagerDifferentialThermostat > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostatsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerDifferentialThermostatsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerDifferentialThermostatsByName
class AvailabilityManagerNightVentilation(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerNightVentilation, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerNightVentilation, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerNightVentilation(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerNightVentilation
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_iddObjectType)

    def applicabilitySchedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_applicabilitySchedule(self)

    def ventilationTemperatureSchedule(self) -> "boost::optional< openstudio::model::Schedule >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_ventilationTemperatureSchedule(self)

    def ventilationTemperatureDifference(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_ventilationTemperatureDifference(self)

    def ventilationTemperatureLowLimit(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_ventilationTemperatureLowLimit(self)

    def nightVentingFlowFraction(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_nightVentingFlowFraction(self)

    def controlZone(self) -> "boost::optional< openstudio::model::ThermalZone >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_controlZone(self)

    def setApplicabilitySchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setApplicabilitySchedule(self, schedule)

    def setVentilationTemperatureSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setVentilationTemperatureSchedule(self, schedule)

    def resetVentilationTemperatureSchedule(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_resetVentilationTemperatureSchedule(self)

    def setVentilationTemperatureDifference(self, ventilationTemperatureDifference: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setVentilationTemperatureDifference(self, ventilationTemperatureDifference)

    def setVentilationTemperatureLowLimit(self, ventilationTemperatureLowLimit: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setVentilationTemperatureLowLimit(self, ventilationTemperatureLowLimit)

    def setNightVentingFlowFraction(self, nightVentingFlowFraction: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setNightVentingFlowFraction(self, nightVentingFlowFraction)

    def setControlZone(self, thermalZone: 'ThermalZone') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_setControlZone(self, thermalZone)

    def resetControlZone(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_resetControlZone(self)
AvailabilityManagerNightVentilation_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_swigregister
AvailabilityManagerNightVentilation_swigregister(AvailabilityManagerNightVentilation)

def AvailabilityManagerNightVentilation_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_iddObjectType()
AvailabilityManagerNightVentilation_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerNightVentilation_iddObjectType


def toAvailabilityManagerNightVentilation(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerNightVentilation >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerNightVentilation(idfObject)
toAvailabilityManagerNightVentilation = _openstudiomodelavailabilitymanager.toAvailabilityManagerNightVentilation

def getAvailabilityManagerNightVentilation(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerNightVentilation >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilation(t_model, t_handle)
getAvailabilityManagerNightVentilation = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilation

def getAvailabilityManagerNightVentilations(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation,std::allocator< openstudio::model::AvailabilityManagerNightVentilation > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilations(t_model)
getAvailabilityManagerNightVentilations = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilations

def getAvailabilityManagerNightVentilationByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerNightVentilation >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilationByName(t_model, t_name)
getAvailabilityManagerNightVentilationByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilationByName

def getAvailabilityManagerNightVentilationsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerNightVentilation,std::allocator< openstudio::model::AvailabilityManagerNightVentilation > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilationsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerNightVentilationsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerNightVentilationsByName
class AvailabilityManagerHighTemperatureTurnOn(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHighTemperatureTurnOn, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHighTemperatureTurnOn, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHighTemperatureTurnOn(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHighTemperatureTurnOn
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_iddObjectType)

    def sensorNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_sensorNode(self)

    def temperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_temperature(self)

    def setSensorNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_setSensorNode(self, node)

    def resetSensorNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_resetSensorNode(self)

    def setTemperature(self, temperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_setTemperature(self, temperature)
AvailabilityManagerHighTemperatureTurnOn_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_swigregister
AvailabilityManagerHighTemperatureTurnOn_swigregister(AvailabilityManagerHighTemperatureTurnOn)

def AvailabilityManagerHighTemperatureTurnOn_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_iddObjectType()
AvailabilityManagerHighTemperatureTurnOn_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOn_iddObjectType


def toAvailabilityManagerHighTemperatureTurnOn(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerHighTemperatureTurnOn(idfObject)
toAvailabilityManagerHighTemperatureTurnOn = _openstudiomodelavailabilitymanager.toAvailabilityManagerHighTemperatureTurnOn

def getAvailabilityManagerHighTemperatureTurnOn(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOn(t_model, t_handle)
getAvailabilityManagerHighTemperatureTurnOn = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOn

def getAvailabilityManagerHighTemperatureTurnOns(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOns(t_model)
getAvailabilityManagerHighTemperatureTurnOns = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOns

def getAvailabilityManagerHighTemperatureTurnOnByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOnByName(t_model, t_name)
getAvailabilityManagerHighTemperatureTurnOnByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOnByName

def getAvailabilityManagerHighTemperatureTurnOnsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOnsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerHighTemperatureTurnOnsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOnsByName
class AvailabilityManagerHighTemperatureTurnOff(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerHighTemperatureTurnOff, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerHighTemperatureTurnOff, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerHighTemperatureTurnOff(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerHighTemperatureTurnOff
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_iddObjectType)

    def sensorNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_sensorNode(self)

    def temperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_temperature(self)

    def setSensorNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_setSensorNode(self, node)

    def resetSensorNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_resetSensorNode(self)

    def setTemperature(self, temperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_setTemperature(self, temperature)
AvailabilityManagerHighTemperatureTurnOff_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_swigregister
AvailabilityManagerHighTemperatureTurnOff_swigregister(AvailabilityManagerHighTemperatureTurnOff)

def AvailabilityManagerHighTemperatureTurnOff_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_iddObjectType()
AvailabilityManagerHighTemperatureTurnOff_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerHighTemperatureTurnOff_iddObjectType


def toAvailabilityManagerHighTemperatureTurnOff(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerHighTemperatureTurnOff(idfObject)
toAvailabilityManagerHighTemperatureTurnOff = _openstudiomodelavailabilitymanager.toAvailabilityManagerHighTemperatureTurnOff

def getAvailabilityManagerHighTemperatureTurnOff(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOff(t_model, t_handle)
getAvailabilityManagerHighTemperatureTurnOff = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOff

def getAvailabilityManagerHighTemperatureTurnOffs(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffs(t_model)
getAvailabilityManagerHighTemperatureTurnOffs = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffs

def getAvailabilityManagerHighTemperatureTurnOffByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerHighTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffByName(t_model, t_name)
getAvailabilityManagerHighTemperatureTurnOffByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffByName

def getAvailabilityManagerHighTemperatureTurnOffsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerHighTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerHighTemperatureTurnOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerHighTemperatureTurnOffsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerHighTemperatureTurnOffsByName
class AvailabilityManagerLowTemperatureTurnOn(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerLowTemperatureTurnOn, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerLowTemperatureTurnOn, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerLowTemperatureTurnOn(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerLowTemperatureTurnOn
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_iddObjectType)

    def sensorNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_sensorNode(self)

    def temperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_temperature(self)

    def setSensorNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_setSensorNode(self, node)

    def resetSensorNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_resetSensorNode(self)

    def setTemperature(self, temperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_setTemperature(self, temperature)
AvailabilityManagerLowTemperatureTurnOn_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_swigregister
AvailabilityManagerLowTemperatureTurnOn_swigregister(AvailabilityManagerLowTemperatureTurnOn)

def AvailabilityManagerLowTemperatureTurnOn_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_iddObjectType()
AvailabilityManagerLowTemperatureTurnOn_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOn_iddObjectType


def toAvailabilityManagerLowTemperatureTurnOn(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerLowTemperatureTurnOn(idfObject)
toAvailabilityManagerLowTemperatureTurnOn = _openstudiomodelavailabilitymanager.toAvailabilityManagerLowTemperatureTurnOn

def getAvailabilityManagerLowTemperatureTurnOn(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOn(t_model, t_handle)
getAvailabilityManagerLowTemperatureTurnOn = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOn

def getAvailabilityManagerLowTemperatureTurnOns(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOns(t_model)
getAvailabilityManagerLowTemperatureTurnOns = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOns

def getAvailabilityManagerLowTemperatureTurnOnByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOnByName(t_model, t_name)
getAvailabilityManagerLowTemperatureTurnOnByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOnByName

def getAvailabilityManagerLowTemperatureTurnOnsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOn,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOnsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerLowTemperatureTurnOnsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOnsByName
class AvailabilityManagerLowTemperatureTurnOff(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerLowTemperatureTurnOff, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerLowTemperatureTurnOff, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerLowTemperatureTurnOff(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerLowTemperatureTurnOff
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_iddObjectType)

    def sensorNode(self) -> "boost::optional< openstudio::model::Node >":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_sensorNode(self)

    def temperature(self) -> "double":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_temperature(self)

    def applicabilitySchedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_applicabilitySchedule(self)

    def setSensorNode(self, node: 'Node') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_setSensorNode(self, node)

    def resetSensorNode(self) -> "void":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_resetSensorNode(self)

    def setTemperature(self, temperature: 'double') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_setTemperature(self, temperature)

    def setApplicabilitySchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_setApplicabilitySchedule(self, schedule)
AvailabilityManagerLowTemperatureTurnOff_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_swigregister
AvailabilityManagerLowTemperatureTurnOff_swigregister(AvailabilityManagerLowTemperatureTurnOff)

def AvailabilityManagerLowTemperatureTurnOff_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_iddObjectType()
AvailabilityManagerLowTemperatureTurnOff_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerLowTemperatureTurnOff_iddObjectType


def toAvailabilityManagerLowTemperatureTurnOff(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerLowTemperatureTurnOff(idfObject)
toAvailabilityManagerLowTemperatureTurnOff = _openstudiomodelavailabilitymanager.toAvailabilityManagerLowTemperatureTurnOff

def getAvailabilityManagerLowTemperatureTurnOff(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOff(t_model, t_handle)
getAvailabilityManagerLowTemperatureTurnOff = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOff

def getAvailabilityManagerLowTemperatureTurnOffs(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffs(t_model)
getAvailabilityManagerLowTemperatureTurnOffs = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffs

def getAvailabilityManagerLowTemperatureTurnOffByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerLowTemperatureTurnOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffByName(t_model, t_name)
getAvailabilityManagerLowTemperatureTurnOffByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffByName

def getAvailabilityManagerLowTemperatureTurnOffsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerLowTemperatureTurnOff,std::allocator< openstudio::model::AvailabilityManagerLowTemperatureTurnOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerLowTemperatureTurnOffsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerLowTemperatureTurnOffsByName
class AvailabilityManagerScheduled(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduled, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduled, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduled(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduled
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_iddObjectType)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_schedule(self)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_setSchedule(self, schedule)
AvailabilityManagerScheduled_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_swigregister
AvailabilityManagerScheduled_swigregister(AvailabilityManagerScheduled)

def AvailabilityManagerScheduled_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_iddObjectType()
AvailabilityManagerScheduled_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduled_iddObjectType


def toAvailabilityManagerScheduled(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerScheduled >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduled(idfObject)
toAvailabilityManagerScheduled = _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduled

def getAvailabilityManagerScheduled(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerScheduled >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduled(t_model, t_handle)
getAvailabilityManagerScheduled = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduled

def getAvailabilityManagerScheduleds(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerScheduled,std::allocator< openstudio::model::AvailabilityManagerScheduled > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduleds(t_model)
getAvailabilityManagerScheduleds = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduleds

def getAvailabilityManagerScheduledByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerScheduled >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledByName(t_model, t_name)
getAvailabilityManagerScheduledByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledByName

def getAvailabilityManagerScheduledsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerScheduled,std::allocator< openstudio::model::AvailabilityManagerScheduled > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerScheduledsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledsByName
class AvailabilityManagerScheduledOn(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduledOn, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduledOn, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduledOn(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduledOn
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_iddObjectType)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_schedule(self)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_setSchedule(self, schedule)
AvailabilityManagerScheduledOn_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_swigregister
AvailabilityManagerScheduledOn_swigregister(AvailabilityManagerScheduledOn)

def AvailabilityManagerScheduledOn_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_iddObjectType()
AvailabilityManagerScheduledOn_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOn_iddObjectType


def toAvailabilityManagerScheduledOn(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOn >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduledOn(idfObject)
toAvailabilityManagerScheduledOn = _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduledOn

def getAvailabilityManagerScheduledOn(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOn(t_model, t_handle)
getAvailabilityManagerScheduledOn = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOn

def getAvailabilityManagerScheduledOns(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn,std::allocator< openstudio::model::AvailabilityManagerScheduledOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOns(t_model)
getAvailabilityManagerScheduledOns = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOns

def getAvailabilityManagerScheduledOnByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOn >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOnByName(t_model, t_name)
getAvailabilityManagerScheduledOnByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOnByName

def getAvailabilityManagerScheduledOnsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOn,std::allocator< openstudio::model::AvailabilityManagerScheduledOn > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOnsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerScheduledOnsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOnsByName
class AvailabilityManagerScheduledOff(openstudiomodelhvac.AvailabilityManager):
    __swig_setmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvailabilityManagerScheduledOff, name, value)
    __swig_getmethods__ = {}
    for _s in [openstudiomodelhvac.AvailabilityManager]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvailabilityManagerScheduledOff, name)
    __repr__ = _swig_repr

    def __init__(self, model: 'Model'):
        this = _openstudiomodelavailabilitymanager.new_AvailabilityManagerScheduledOff(model)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _openstudiomodelavailabilitymanager.delete_AvailabilityManagerScheduledOff
    __del__ = lambda self: None
    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_iddObjectType
    if _newclass:
        iddObjectType = staticmethod(_openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_iddObjectType)

    def schedule(self) -> "openstudio::model::Schedule":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_schedule(self)

    def setSchedule(self, schedule: 'Schedule') -> "bool":
        return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_setSchedule(self, schedule)
AvailabilityManagerScheduledOff_swigregister = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_swigregister
AvailabilityManagerScheduledOff_swigregister(AvailabilityManagerScheduledOff)

def AvailabilityManagerScheduledOff_iddObjectType() -> "openstudio::IddObjectType":
    return _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_iddObjectType()
AvailabilityManagerScheduledOff_iddObjectType = _openstudiomodelavailabilitymanager.AvailabilityManagerScheduledOff_iddObjectType


def toAvailabilityManagerScheduledOff(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOff >":
    return _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduledOff(idfObject)
toAvailabilityManagerScheduledOff = _openstudiomodelavailabilitymanager.toAvailabilityManagerScheduledOff

def getAvailabilityManagerScheduledOff(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOff(t_model, t_handle)
getAvailabilityManagerScheduledOff = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOff

def getAvailabilityManagerScheduledOffs(t_model: 'Model') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff,std::allocator< openstudio::model::AvailabilityManagerScheduledOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffs(t_model)
getAvailabilityManagerScheduledOffs = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffs

def getAvailabilityManagerScheduledOffByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AvailabilityManagerScheduledOff >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffByName(t_model, t_name)
getAvailabilityManagerScheduledOffByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffByName

def getAvailabilityManagerScheduledOffsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AvailabilityManagerScheduledOff,std::allocator< openstudio::model::AvailabilityManagerScheduledOff > >":
    return _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffsByName(t_model, t_name, t_exactMatch)
getAvailabilityManagerScheduledOffsByName = _openstudiomodelavailabilitymanager.getAvailabilityManagerScheduledOffsByName
# This file is compatible with both classic and new-style classes.


