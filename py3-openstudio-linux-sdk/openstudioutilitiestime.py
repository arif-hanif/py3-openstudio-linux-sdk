# This file was automatically generated by SWIG (http://www.swig.org).

# Version 3.0.7

#

# Do not make changes to this file unless you know what you are doing--modify

# the SWIG interface file instead.











from sys import version_info

if version_info >= (2, 6, 0):

    def swig_import_helper():

        from os.path import dirname

        import imp

        fp = None

        try:

            fp, pathname, description = imp.find_module('_openstudioutilitiestime', [dirname(__file__)])

        except ImportError:

            import _openstudioutilitiestime

            return _openstudioutilitiestime

        if fp is not None:

            try:

                _mod = imp.load_module('_openstudioutilitiestime', fp, pathname, description)

            finally:

                fp.close()

            return _mod

    _openstudioutilitiestime = swig_import_helper()

    del swig_import_helper

else:

    import _openstudioutilitiestime

del version_info

try:

    _swig_property = property

except NameError:

    pass  # Python < 2.2 doesn't have 'property'.





def _swig_setattr_nondynamic(self, class_type, name, value, static=1):

    if (name == "thisown"):

        return self.this.own(value)

    if (name == "this"):

        if type(value).__name__ == 'SwigPyObject':

            self.__dict__[name] = value

            return

    method = class_type.__swig_setmethods__.get(name, None)

    if method:

        return method(self, value)

    if (not static):

        if _newclass:

            object.__setattr__(self, name, value)

        else:

            self.__dict__[name] = value

    else:

        raise AttributeError("You cannot add attributes to %s" % self)





def _swig_setattr(self, class_type, name, value):

    return _swig_setattr_nondynamic(self, class_type, name, value, 0)





def _swig_getattr_nondynamic(self, class_type, name, static=1):

    if (name == "thisown"):

        return self.this.own()

    method = class_type.__swig_getmethods__.get(name, None)

    if method:

        return method(self)

    if (not static):

        return object.__getattr__(self, name)

    else:

        raise AttributeError(name)



def _swig_getattr(self, class_type, name):

    return _swig_getattr_nondynamic(self, class_type, name, 0)





def _swig_repr(self):

    try:

        strthis = "proxy of " + self.this.__repr__()

    except:

        strthis = ""

    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)



try:

    _object = object

    _newclass = 1

except AttributeError:

    class _object:

        pass

    _newclass = 0





try:

    import weakref

    weakref_proxy = weakref.proxy

except:

    weakref_proxy = lambda x: x





class SwigPyIterator(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudioutilitiestime.delete_SwigPyIterator

    __del__ = lambda self: None



    def value(self) -> "PyObject *":

        return _openstudioutilitiestime.SwigPyIterator_value(self)



    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.SwigPyIterator_incr(self, n)



    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.SwigPyIterator_decr(self, n)



    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":

        return _openstudioutilitiestime.SwigPyIterator_distance(self, x)



    def equal(self, x: 'SwigPyIterator') -> "bool":

        return _openstudioutilitiestime.SwigPyIterator_equal(self, x)



    def copy(self) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.SwigPyIterator_copy(self)



    def next(self) -> "PyObject *":

        return _openstudioutilitiestime.SwigPyIterator_next(self)



    def __next__(self) -> "PyObject *":

        return _openstudioutilitiestime.SwigPyIterator___next__(self)



    def previous(self) -> "PyObject *":

        return _openstudioutilitiestime.SwigPyIterator_previous(self)



    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.SwigPyIterator_advance(self, n)



    def __eq__(self, x: 'SwigPyIterator') -> "bool":

        return _openstudioutilitiestime.SwigPyIterator___eq__(self, x)



    def __ne__(self, x: 'SwigPyIterator') -> "bool":

        return _openstudioutilitiestime.SwigPyIterator___ne__(self, x)



    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":

        return _openstudioutilitiestime.SwigPyIterator___iadd__(self, n)



    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":

        return _openstudioutilitiestime.SwigPyIterator___isub__(self, n)



    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.SwigPyIterator___add__(self, n)



    def __sub__(self, *args) -> "ptrdiff_t":

        return _openstudioutilitiestime.SwigPyIterator___sub__(self, *args)

    def __iter__(self):

        return self

SwigPyIterator_swigregister = _openstudioutilitiestime.SwigPyIterator_swigregister

SwigPyIterator_swigregister(SwigPyIterator)





_openstudioutilitiestime.SHARED_PTR_DISOWN_swigconstant(_openstudioutilitiestime)

SHARED_PTR_DISOWN = _openstudioutilitiestime.SHARED_PTR_DISOWN

from .import openstudioutilitiescore

class TimeVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, TimeVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.TimeVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudioutilitiestime.TimeVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudioutilitiestime.TimeVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::Time >::size_type":

        return _openstudioutilitiestime.TimeVector___len__(self)



    def pop(self) -> "std::vector< openstudio::Time >::value_type":

        return _openstudioutilitiestime.TimeVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::Time >::difference_type', j: 'std::vector< openstudio::Time >::difference_type') -> "std::vector< openstudio::Time,std::allocator< openstudio::Time > > *":

        return _openstudioutilitiestime.TimeVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudioutilitiestime.TimeVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::Time >::difference_type', j: 'std::vector< openstudio::Time >::difference_type') -> "void":

        return _openstudioutilitiestime.TimeVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudioutilitiestime.TimeVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::Time >::value_type const &":

        return _openstudioutilitiestime.TimeVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudioutilitiestime.TimeVector___setitem__(self, *args)



    def append(self, x: 'Time') -> "void":

        return _openstudioutilitiestime.TimeVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudioutilitiestime.TimeVector_empty(self)



    def size(self) -> "std::vector< openstudio::Time >::size_type":

        return _openstudioutilitiestime.TimeVector_size(self)



    def clear(self) -> "void":

        return _openstudioutilitiestime.TimeVector_clear(self)



    def swap(self, v: 'TimeVector') -> "void":

        return _openstudioutilitiestime.TimeVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::Time >::allocator_type":

        return _openstudioutilitiestime.TimeVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::Time >::iterator":

        return _openstudioutilitiestime.TimeVector_begin(self)



    def end(self) -> "std::vector< openstudio::Time >::iterator":

        return _openstudioutilitiestime.TimeVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::Time >::reverse_iterator":

        return _openstudioutilitiestime.TimeVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::Time >::reverse_iterator":

        return _openstudioutilitiestime.TimeVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudioutilitiestime.TimeVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::Time >::iterator":

        return _openstudioutilitiestime.TimeVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_TimeVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'Time') -> "void":

        return _openstudioutilitiestime.TimeVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::Time >::value_type const &":

        return _openstudioutilitiestime.TimeVector_front(self)



    def back(self) -> "std::vector< openstudio::Time >::value_type const &":

        return _openstudioutilitiestime.TimeVector_back(self)



    def assign(self, n: 'std::vector< openstudio::Time >::size_type', x: 'Time') -> "void":

        return _openstudioutilitiestime.TimeVector_assign(self, n, x)



    def resize(self, *args) -> "void":

        return _openstudioutilitiestime.TimeVector_resize(self, *args)



    def insert(self, *args) -> "void":

        return _openstudioutilitiestime.TimeVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::Time >::size_type') -> "void":

        return _openstudioutilitiestime.TimeVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::Time >::size_type":

        return _openstudioutilitiestime.TimeVector_capacity(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_TimeVector

    __del__ = lambda self: None

TimeVector_swigregister = _openstudioutilitiestime.TimeVector_swigregister

TimeVector_swigregister(TimeVector)



class OptionalTime(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalTime, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalTime, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalTime(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalTime_reset(self)



    def __ref__(self) -> "openstudio::Time":

        return _openstudioutilitiestime.OptionalTime___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalTime_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalTime_isNull(self)



    def get(self) -> "openstudio::Time":

        return _openstudioutilitiestime.OptionalTime_get(self)



    def set(self, t: 'Time') -> "void":

        return _openstudioutilitiestime.OptionalTime_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalTime

    __del__ = lambda self: None

OptionalTime_swigregister = _openstudioutilitiestime.OptionalTime_swigregister

OptionalTime_swigregister(OptionalTime)





def floor0(value: 'double') -> "int":

    return _openstudioutilitiestime.floor0(value)

floor0 = _openstudioutilitiestime.floor0

class Time(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)

    __repr__ = _swig_repr

    __swig_getmethods__["currentTime"] = lambda x: _openstudioutilitiestime.Time_currentTime

    if _newclass:

        currentTime = staticmethod(_openstudioutilitiestime.Time_currentTime)

    __swig_getmethods__["currentTimeUTC"] = lambda x: _openstudioutilitiestime.Time_currentTimeUTC

    if _newclass:

        currentTimeUTC = staticmethod(_openstudioutilitiestime.Time_currentTimeUTC)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_Time(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def __add__(self, time: 'Time') -> "openstudio::Time":

        return _openstudioutilitiestime.Time___add__(self, time)



    def __iadd__(self, time: 'Time') -> "openstudio::Time &":

        return _openstudioutilitiestime.Time___iadd__(self, time)



    def __sub__(self, time: 'Time') -> "openstudio::Time":

        return _openstudioutilitiestime.Time___sub__(self, time)



    def __isub__(self, time: 'Time') -> "openstudio::Time &":

        return _openstudioutilitiestime.Time___isub__(self, time)



    def __mul__(self, mult: 'double') -> "openstudio::Time":

        return _openstudioutilitiestime.Time___mul__(self, mult)



    def __div__(self, div: 'double') -> "openstudio::Time":

        return _openstudioutilitiestime.Time___div__(self, div)



    def __eq__(self, other: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___eq__(self, other)



    def __ne__(self, other: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___ne__(self, other)



    def __lt__(self, rhs: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___lt__(self, rhs)



    def __le__(self, rhs: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___le__(self, rhs)



    def __gt__(self, rhs: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___gt__(self, rhs)



    def __ge__(self, rhs: 'Time') -> "bool":

        return _openstudioutilitiestime.Time___ge__(self, rhs)



    def days(self) -> "int":

        return _openstudioutilitiestime.Time_days(self)



    def hours(self) -> "int":

        return _openstudioutilitiestime.Time_hours(self)



    def minutes(self) -> "int":

        return _openstudioutilitiestime.Time_minutes(self)



    def seconds(self) -> "int":

        return _openstudioutilitiestime.Time_seconds(self)



    def totalDays(self) -> "double":

        return _openstudioutilitiestime.Time_totalDays(self)



    def totalHours(self) -> "double":

        return _openstudioutilitiestime.Time_totalHours(self)



    def totalMinutes(self) -> "double":

        return _openstudioutilitiestime.Time_totalMinutes(self)



    def totalSeconds(self) -> "int":

        return _openstudioutilitiestime.Time_totalSeconds(self)



    def toString(self) -> "std::string":

        return _openstudioutilitiestime.Time_toString(self)



    def __str__(self) -> "std::string":

        return _openstudioutilitiestime.Time___str__(self)



    def __hash__(self) -> "std::string":

        return _openstudioutilitiestime.Time___hash__(self)



    def __cmp__(self, other: 'Time') -> "int":

        return _openstudioutilitiestime.Time___cmp__(self, other)

    __swig_destroy__ = _openstudioutilitiestime.delete_Time

    __del__ = lambda self: None

Time_swigregister = _openstudioutilitiestime.Time_swigregister

Time_swigregister(Time)

cvar = _openstudioutilitiestime.cvar

HOURS_PER_DAY = cvar.HOURS_PER_DAY

MINUTES_PER_HOUR = cvar.MINUTES_PER_HOUR

SECONDS_PER_MINUTE = cvar.SECONDS_PER_MINUTE

MINUTES_PER_SECOND = cvar.MINUTES_PER_SECOND

HOURS_PER_SECOND = cvar.HOURS_PER_SECOND

DAYS_PER_SECOND = cvar.DAYS_PER_SECOND



def Time_currentTime() -> "openstudio::Time":

    return _openstudioutilitiestime.Time_currentTime()

Time_currentTime = _openstudioutilitiestime.Time_currentTime



def Time_currentTimeUTC() -> "openstudio::Time":

    return _openstudioutilitiestime.Time_currentTimeUTC()

Time_currentTimeUTC = _openstudioutilitiestime.Time_currentTimeUTC



class TimeCompare(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeCompare, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, TimeCompare, name)

    __repr__ = _swig_repr



    def __call__(self, lhs: 'Time', rhs: 'Time') -> "bool":

        return _openstudioutilitiestime.TimeCompare___call__(self, lhs, rhs)



    def __init__(self):

        this = _openstudioutilitiestime.new_TimeCompare()

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudioutilitiestime.delete_TimeCompare

    __del__ = lambda self: None

TimeCompare_swigregister = _openstudioutilitiestime.TimeCompare_swigregister

TimeCompare_swigregister(TimeCompare)



class DateVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DateVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DateVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.DateVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudioutilitiestime.DateVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudioutilitiestime.DateVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::Date >::size_type":

        return _openstudioutilitiestime.DateVector___len__(self)



    def pop(self) -> "std::vector< openstudio::Date >::value_type":

        return _openstudioutilitiestime.DateVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::Date >::difference_type', j: 'std::vector< openstudio::Date >::difference_type') -> "std::vector< openstudio::Date,std::allocator< openstudio::Date > > *":

        return _openstudioutilitiestime.DateVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudioutilitiestime.DateVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::Date >::difference_type', j: 'std::vector< openstudio::Date >::difference_type') -> "void":

        return _openstudioutilitiestime.DateVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudioutilitiestime.DateVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::Date >::value_type const &":

        return _openstudioutilitiestime.DateVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudioutilitiestime.DateVector___setitem__(self, *args)



    def append(self, x: 'Date') -> "void":

        return _openstudioutilitiestime.DateVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudioutilitiestime.DateVector_empty(self)



    def size(self) -> "std::vector< openstudio::Date >::size_type":

        return _openstudioutilitiestime.DateVector_size(self)



    def clear(self) -> "void":

        return _openstudioutilitiestime.DateVector_clear(self)



    def swap(self, v: 'DateVector') -> "void":

        return _openstudioutilitiestime.DateVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::Date >::allocator_type":

        return _openstudioutilitiestime.DateVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::Date >::iterator":

        return _openstudioutilitiestime.DateVector_begin(self)



    def end(self) -> "std::vector< openstudio::Date >::iterator":

        return _openstudioutilitiestime.DateVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::Date >::reverse_iterator":

        return _openstudioutilitiestime.DateVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::Date >::reverse_iterator":

        return _openstudioutilitiestime.DateVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudioutilitiestime.DateVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::Date >::iterator":

        return _openstudioutilitiestime.DateVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_DateVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'Date') -> "void":

        return _openstudioutilitiestime.DateVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::Date >::value_type const &":

        return _openstudioutilitiestime.DateVector_front(self)



    def back(self) -> "std::vector< openstudio::Date >::value_type const &":

        return _openstudioutilitiestime.DateVector_back(self)



    def assign(self, n: 'std::vector< openstudio::Date >::size_type', x: 'Date') -> "void":

        return _openstudioutilitiestime.DateVector_assign(self, n, x)



    def resize(self, *args) -> "void":

        return _openstudioutilitiestime.DateVector_resize(self, *args)



    def insert(self, *args) -> "void":

        return _openstudioutilitiestime.DateVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::Date >::size_type') -> "void":

        return _openstudioutilitiestime.DateVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::Date >::size_type":

        return _openstudioutilitiestime.DateVector_capacity(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_DateVector

    __del__ = lambda self: None

DateVector_swigregister = _openstudioutilitiestime.DateVector_swigregister

DateVector_swigregister(DateVector)



class OptionalDate(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDate, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDate, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalDate(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalDate_reset(self)



    def __ref__(self) -> "openstudio::Date":

        return _openstudioutilitiestime.OptionalDate___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalDate_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalDate_isNull(self)



    def get(self) -> "openstudio::Date":

        return _openstudioutilitiestime.OptionalDate_get(self)



    def set(self, t: 'Date') -> "void":

        return _openstudioutilitiestime.OptionalDate_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalDate

    __del__ = lambda self: None

OptionalDate_swigregister = _openstudioutilitiestime.OptionalDate_swigregister

OptionalDate_swigregister(OptionalDate)



class OptionalDayOfWeek(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDayOfWeek, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDayOfWeek, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalDayOfWeek(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalDayOfWeek_reset(self)



    def __ref__(self) -> "openstudio::DayOfWeek":

        return _openstudioutilitiestime.OptionalDayOfWeek___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalDayOfWeek_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalDayOfWeek_isNull(self)



    def get(self) -> "openstudio::DayOfWeek":

        return _openstudioutilitiestime.OptionalDayOfWeek_get(self)



    def set(self, t: 'DayOfWeek') -> "void":

        return _openstudioutilitiestime.OptionalDayOfWeek_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalDayOfWeek

    __del__ = lambda self: None

OptionalDayOfWeek_swigregister = _openstudioutilitiestime.OptionalDayOfWeek_swigregister

OptionalDayOfWeek_swigregister(OptionalDayOfWeek)



class OptionalMonthOfYear(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalMonthOfYear, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalMonthOfYear, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalMonthOfYear(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalMonthOfYear_reset(self)



    def __ref__(self) -> "openstudio::MonthOfYear":

        return _openstudioutilitiestime.OptionalMonthOfYear___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalMonthOfYear_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalMonthOfYear_isNull(self)



    def get(self) -> "openstudio::MonthOfYear":

        return _openstudioutilitiestime.OptionalMonthOfYear_get(self)



    def set(self, t: 'MonthOfYear') -> "void":

        return _openstudioutilitiestime.OptionalMonthOfYear_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalMonthOfYear

    __del__ = lambda self: None

OptionalMonthOfYear_swigregister = _openstudioutilitiestime.OptionalMonthOfYear_swigregister

OptionalMonthOfYear_swigregister(OptionalMonthOfYear)



class OptionalNthDayOfWeekInMonth(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalNthDayOfWeekInMonth, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalNthDayOfWeekInMonth, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalNthDayOfWeekInMonth(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_reset(self)



    def __ref__(self) -> "openstudio::NthDayOfWeekInMonth":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_isNull(self)



    def get(self) -> "openstudio::NthDayOfWeekInMonth":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_get(self)



    def set(self, t: 'NthDayOfWeekInMonth') -> "void":

        return _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalNthDayOfWeekInMonth

    __del__ = lambda self: None

OptionalNthDayOfWeekInMonth_swigregister = _openstudioutilitiestime.OptionalNthDayOfWeekInMonth_swigregister

OptionalNthDayOfWeekInMonth_swigregister(OptionalNthDayOfWeekInMonth)



class DayOfWeek(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DayOfWeek, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DayOfWeek, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_DayOfWeek(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def valueName(self) -> "std::string":

        return _openstudioutilitiestime.DayOfWeek_valueName(self)



    def value(self) -> "int":

        return _openstudioutilitiestime.DayOfWeek_value(self)



    def valueDescription(self) -> "std::string":

        return _openstudioutilitiestime.DayOfWeek_valueDescription(self)



    def __eq__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___eq__(self, other)



    def __ne__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___ne__(self, other)



    def __gt__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___gt__(self, other)



    def __ge__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___ge__(self, other)



    def __lt__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___lt__(self, other)



    def __le__(self, other: 'DayOfWeek') -> "bool":

        return _openstudioutilitiestime.DayOfWeek___le__(self, other)

    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiestime.DayOfWeek_enumName

    if _newclass:

        enumName = staticmethod(_openstudioutilitiestime.DayOfWeek_enumName)

    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiestime.DayOfWeek_getValues

    if _newclass:

        getValues = staticmethod(_openstudioutilitiestime.DayOfWeek_getValues)

    __swig_destroy__ = _openstudioutilitiestime.delete_DayOfWeek

    __del__ = lambda self: None

DayOfWeek_swigregister = _openstudioutilitiestime.DayOfWeek_swigregister

DayOfWeek_swigregister(DayOfWeek)



def DayOfWeek_enumName() -> "std::string":

    return _openstudioutilitiestime.DayOfWeek_enumName()

DayOfWeek_enumName = _openstudioutilitiestime.DayOfWeek_enumName



def DayOfWeek_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":

    return _openstudioutilitiestime.DayOfWeek_getValues()

DayOfWeek_getValues = _openstudioutilitiestime.DayOfWeek_getValues





def dayOfWeek(day: 'std::string const &') -> "openstudio::DayOfWeek":

    return _openstudioutilitiestime.dayOfWeek(day)

dayOfWeek = _openstudioutilitiestime.dayOfWeek

class MonthOfYear(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, MonthOfYear, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, MonthOfYear, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_MonthOfYear(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def valueName(self) -> "std::string":

        return _openstudioutilitiestime.MonthOfYear_valueName(self)



    def value(self) -> "int":

        return _openstudioutilitiestime.MonthOfYear_value(self)



    def valueDescription(self) -> "std::string":

        return _openstudioutilitiestime.MonthOfYear_valueDescription(self)



    def __eq__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___eq__(self, other)



    def __ne__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___ne__(self, other)



    def __gt__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___gt__(self, other)



    def __ge__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___ge__(self, other)



    def __lt__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___lt__(self, other)



    def __le__(self, other: 'MonthOfYear') -> "bool":

        return _openstudioutilitiestime.MonthOfYear___le__(self, other)

    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiestime.MonthOfYear_enumName

    if _newclass:

        enumName = staticmethod(_openstudioutilitiestime.MonthOfYear_enumName)

    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiestime.MonthOfYear_getValues

    if _newclass:

        getValues = staticmethod(_openstudioutilitiestime.MonthOfYear_getValues)

    __swig_destroy__ = _openstudioutilitiestime.delete_MonthOfYear

    __del__ = lambda self: None

MonthOfYear_swigregister = _openstudioutilitiestime.MonthOfYear_swigregister

MonthOfYear_swigregister(MonthOfYear)



def MonthOfYear_enumName() -> "std::string":

    return _openstudioutilitiestime.MonthOfYear_enumName()

MonthOfYear_enumName = _openstudioutilitiestime.MonthOfYear_enumName



def MonthOfYear_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":

    return _openstudioutilitiestime.MonthOfYear_getValues()

MonthOfYear_getValues = _openstudioutilitiestime.MonthOfYear_getValues





def monthOfYear(*args) -> "openstudio::MonthOfYear":

    return _openstudioutilitiestime.monthOfYear(*args)

monthOfYear = _openstudioutilitiestime.monthOfYear



def month(monthOfYear: 'MonthOfYear') -> "unsigned int":

    return _openstudioutilitiestime.month(monthOfYear)

month = _openstudioutilitiestime.month

class NthDayOfWeekInMonth(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, NthDayOfWeekInMonth, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, NthDayOfWeekInMonth, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_NthDayOfWeekInMonth(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def valueName(self) -> "std::string":

        return _openstudioutilitiestime.NthDayOfWeekInMonth_valueName(self)



    def value(self) -> "int":

        return _openstudioutilitiestime.NthDayOfWeekInMonth_value(self)



    def valueDescription(self) -> "std::string":

        return _openstudioutilitiestime.NthDayOfWeekInMonth_valueDescription(self)



    def __eq__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___eq__(self, other)



    def __ne__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___ne__(self, other)



    def __gt__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___gt__(self, other)



    def __ge__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___ge__(self, other)



    def __lt__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___lt__(self, other)



    def __le__(self, other: 'NthDayOfWeekInMonth') -> "bool":

        return _openstudioutilitiestime.NthDayOfWeekInMonth___le__(self, other)

    __swig_getmethods__["enumName"] = lambda x: _openstudioutilitiestime.NthDayOfWeekInMonth_enumName

    if _newclass:

        enumName = staticmethod(_openstudioutilitiestime.NthDayOfWeekInMonth_enumName)

    __swig_getmethods__["getValues"] = lambda x: _openstudioutilitiestime.NthDayOfWeekInMonth_getValues

    if _newclass:

        getValues = staticmethod(_openstudioutilitiestime.NthDayOfWeekInMonth_getValues)

    __swig_destroy__ = _openstudioutilitiestime.delete_NthDayOfWeekInMonth

    __del__ = lambda self: None

NthDayOfWeekInMonth_swigregister = _openstudioutilitiestime.NthDayOfWeekInMonth_swigregister

NthDayOfWeekInMonth_swigregister(NthDayOfWeekInMonth)



def NthDayOfWeekInMonth_enumName() -> "std::string":

    return _openstudioutilitiestime.NthDayOfWeekInMonth_enumName()

NthDayOfWeekInMonth_enumName = _openstudioutilitiestime.NthDayOfWeekInMonth_enumName



def NthDayOfWeekInMonth_getValues() -> "std::set< int,std::less< int >,std::allocator< int > >":

    return _openstudioutilitiestime.NthDayOfWeekInMonth_getValues()

NthDayOfWeekInMonth_getValues = _openstudioutilitiestime.NthDayOfWeekInMonth_getValues



class YearDescription(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, YearDescription, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, YearDescription, name)

    __repr__ = _swig_repr



    def __init__(self):

        this = _openstudioutilitiestime.new_YearDescription()

        try:

            self.this.append(this)

        except:

            self.this = this



    def assumedYear(self) -> "int":

        return _openstudioutilitiestime.YearDescription_assumedYear(self)

    __swig_setmethods__["isLeapYear"] = _openstudioutilitiestime.YearDescription_isLeapYear_set

    __swig_getmethods__["isLeapYear"] = _openstudioutilitiestime.YearDescription_isLeapYear_get

    if _newclass:

        isLeapYear = _swig_property(_openstudioutilitiestime.YearDescription_isLeapYear_get, _openstudioutilitiestime.YearDescription_isLeapYear_set)

    __swig_setmethods__["yearStartsOnDayOfWeek"] = _openstudioutilitiestime.YearDescription_yearStartsOnDayOfWeek_set

    __swig_getmethods__["yearStartsOnDayOfWeek"] = _openstudioutilitiestime.YearDescription_yearStartsOnDayOfWeek_get

    if _newclass:

        yearStartsOnDayOfWeek = _swig_property(_openstudioutilitiestime.YearDescription_yearStartsOnDayOfWeek_get, _openstudioutilitiestime.YearDescription_yearStartsOnDayOfWeek_set)

    __swig_setmethods__["lookInFuture"] = _openstudioutilitiestime.YearDescription_lookInFuture_set

    __swig_getmethods__["lookInFuture"] = _openstudioutilitiestime.YearDescription_lookInFuture_get

    if _newclass:

        lookInFuture = _swig_property(_openstudioutilitiestime.YearDescription_lookInFuture_get, _openstudioutilitiestime.YearDescription_lookInFuture_set)

    __swig_destroy__ = _openstudioutilitiestime.delete_YearDescription

    __del__ = lambda self: None

YearDescription_swigregister = _openstudioutilitiestime.YearDescription_swigregister

YearDescription_swigregister(YearDescription)



class Date(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, Date, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, Date, name)

    __repr__ = _swig_repr

    __swig_getmethods__["logChannel"] = lambda x: _openstudioutilitiestime.Date_logChannel

    if _newclass:

        logChannel = staticmethod(_openstudioutilitiestime.Date_logChannel)

    __swig_getmethods__["fromNthDayOfMonth"] = lambda x: _openstudioutilitiestime.Date_fromNthDayOfMonth

    if _newclass:

        fromNthDayOfMonth = staticmethod(_openstudioutilitiestime.Date_fromNthDayOfMonth)

    __swig_getmethods__["fromDayOfYear"] = lambda x: _openstudioutilitiestime.Date_fromDayOfYear

    if _newclass:

        fromDayOfYear = staticmethod(_openstudioutilitiestime.Date_fromDayOfYear)

    __swig_getmethods__["currentDate"] = lambda x: _openstudioutilitiestime.Date_currentDate

    if _newclass:

        currentDate = staticmethod(_openstudioutilitiestime.Date_currentDate)

    __swig_destroy__ = _openstudioutilitiestime.delete_Date

    __del__ = lambda self: None



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_Date(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def __add__(self, time: 'Time') -> "openstudio::Date":

        return _openstudioutilitiestime.Date___add__(self, time)



    def __iadd__(self, time: 'Time') -> "openstudio::Date &":

        return _openstudioutilitiestime.Date___iadd__(self, time)



    def __isub__(self, time: 'Time') -> "openstudio::Date &":

        return _openstudioutilitiestime.Date___isub__(self, time)



    def __sub__(self, *args) -> "openstudio::Time":

        return _openstudioutilitiestime.Date___sub__(self, *args)



    def __eq__(self, other: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___eq__(self, other)



    def __ne__(self, other: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___ne__(self, other)



    def __lt__(self, rhs: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___lt__(self, rhs)



    def __le__(self, rhs: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___le__(self, rhs)



    def __gt__(self, rhs: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___gt__(self, rhs)



    def __ge__(self, rhs: 'Date') -> "bool":

        return _openstudioutilitiestime.Date___ge__(self, rhs)



    def baseYear(self, *args) -> "void":

        return _openstudioutilitiestime.Date_baseYear(self, *args)



    def assumedBaseYear(self) -> "int":

        return _openstudioutilitiestime.Date_assumedBaseYear(self)



    def year(self) -> "int":

        return _openstudioutilitiestime.Date_year(self)



    def monthOfYear(self) -> "openstudio::MonthOfYear":

        return _openstudioutilitiestime.Date_monthOfYear(self)



    def dayOfMonth(self) -> "unsigned int":

        return _openstudioutilitiestime.Date_dayOfMonth(self)



    def dayOfYear(self) -> "unsigned int":

        return _openstudioutilitiestime.Date_dayOfYear(self)



    def isLeapYear(self, *args) -> "bool":

        return _openstudioutilitiestime.Date_isLeapYear(self, *args)



    def dayOfWeek(self) -> "openstudio::DayOfWeek":

        return _openstudioutilitiestime.Date_dayOfWeek(self)



    def __str__(self) -> "std::string":

        return _openstudioutilitiestime.Date___str__(self)



    def __hash__(self) -> "std::string":

        return _openstudioutilitiestime.Date___hash__(self)



    def __cmp__(self, other: 'Date') -> "int":

        return _openstudioutilitiestime.Date___cmp__(self, other)

Date_swigregister = _openstudioutilitiestime.Date_swigregister

Date_swigregister(Date)



def Date_logChannel() -> "openstudio::LogChannel":

    return _openstudioutilitiestime.Date_logChannel()

Date_logChannel = _openstudioutilitiestime.Date_logChannel



def Date_fromNthDayOfMonth(*args) -> "openstudio::Date":

    return _openstudioutilitiestime.Date_fromNthDayOfMonth(*args)

Date_fromNthDayOfMonth = _openstudioutilitiestime.Date_fromNthDayOfMonth



def Date_fromDayOfYear(*args) -> "openstudio::Date":

    return _openstudioutilitiestime.Date_fromDayOfYear(*args)

Date_fromDayOfYear = _openstudioutilitiestime.Date_fromDayOfYear



def Date_currentDate() -> "openstudio::Date":

    return _openstudioutilitiestime.Date_currentDate()

Date_currentDate = _openstudioutilitiestime.Date_currentDate



class DateCompare(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DateCompare, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DateCompare, name)

    __repr__ = _swig_repr



    def __call__(self, lhs: 'Date', rhs: 'Date') -> "bool":

        return _openstudioutilitiestime.DateCompare___call__(self, lhs, rhs)



    def __init__(self):

        this = _openstudioutilitiestime.new_DateCompare()

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudioutilitiestime.delete_DateCompare

    __del__ = lambda self: None

DateCompare_swigregister = _openstudioutilitiestime.DateCompare_swigregister

DateCompare_swigregister(DateCompare)





def nthDayOfWeekInMonth(*args) -> "openstudio::NthDayOfWeekInMonth":

    return _openstudioutilitiestime.nthDayOfWeekInMonth(*args)

nthDayOfWeekInMonth = _openstudioutilitiestime.nthDayOfWeekInMonth

class DateTimeVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DateTimeVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DateTimeVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.DateTimeVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudioutilitiestime.DateTimeVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudioutilitiestime.DateTimeVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::DateTime >::size_type":

        return _openstudioutilitiestime.DateTimeVector___len__(self)



    def pop(self) -> "std::vector< openstudio::DateTime >::value_type":

        return _openstudioutilitiestime.DateTimeVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::DateTime >::difference_type', j: 'std::vector< openstudio::DateTime >::difference_type') -> "std::vector< openstudio::DateTime,std::allocator< openstudio::DateTime > > *":

        return _openstudioutilitiestime.DateTimeVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudioutilitiestime.DateTimeVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::DateTime >::difference_type', j: 'std::vector< openstudio::DateTime >::difference_type') -> "void":

        return _openstudioutilitiestime.DateTimeVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudioutilitiestime.DateTimeVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::DateTime >::value_type const &":

        return _openstudioutilitiestime.DateTimeVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudioutilitiestime.DateTimeVector___setitem__(self, *args)



    def append(self, x: 'DateTime') -> "void":

        return _openstudioutilitiestime.DateTimeVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudioutilitiestime.DateTimeVector_empty(self)



    def size(self) -> "std::vector< openstudio::DateTime >::size_type":

        return _openstudioutilitiestime.DateTimeVector_size(self)



    def clear(self) -> "void":

        return _openstudioutilitiestime.DateTimeVector_clear(self)



    def swap(self, v: 'DateTimeVector') -> "void":

        return _openstudioutilitiestime.DateTimeVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::DateTime >::allocator_type":

        return _openstudioutilitiestime.DateTimeVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::DateTime >::iterator":

        return _openstudioutilitiestime.DateTimeVector_begin(self)



    def end(self) -> "std::vector< openstudio::DateTime >::iterator":

        return _openstudioutilitiestime.DateTimeVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::DateTime >::reverse_iterator":

        return _openstudioutilitiestime.DateTimeVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::DateTime >::reverse_iterator":

        return _openstudioutilitiestime.DateTimeVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudioutilitiestime.DateTimeVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::DateTime >::iterator":

        return _openstudioutilitiestime.DateTimeVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_DateTimeVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'DateTime') -> "void":

        return _openstudioutilitiestime.DateTimeVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::DateTime >::value_type const &":

        return _openstudioutilitiestime.DateTimeVector_front(self)



    def back(self) -> "std::vector< openstudio::DateTime >::value_type const &":

        return _openstudioutilitiestime.DateTimeVector_back(self)



    def assign(self, n: 'std::vector< openstudio::DateTime >::size_type', x: 'DateTime') -> "void":

        return _openstudioutilitiestime.DateTimeVector_assign(self, n, x)



    def resize(self, *args) -> "void":

        return _openstudioutilitiestime.DateTimeVector_resize(self, *args)



    def insert(self, *args) -> "void":

        return _openstudioutilitiestime.DateTimeVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::DateTime >::size_type') -> "void":

        return _openstudioutilitiestime.DateTimeVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::DateTime >::size_type":

        return _openstudioutilitiestime.DateTimeVector_capacity(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_DateTimeVector

    __del__ = lambda self: None

DateTimeVector_swigregister = _openstudioutilitiestime.DateTimeVector_swigregister

DateTimeVector_swigregister(DateTimeVector)



class DateTimePair(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DateTimePair, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DateTimePair, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_DateTimePair(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_setmethods__["first"] = _openstudioutilitiestime.DateTimePair_first_set

    __swig_getmethods__["first"] = _openstudioutilitiestime.DateTimePair_first_get

    if _newclass:

        first = _swig_property(_openstudioutilitiestime.DateTimePair_first_get, _openstudioutilitiestime.DateTimePair_first_set)

    __swig_setmethods__["second"] = _openstudioutilitiestime.DateTimePair_second_set

    __swig_getmethods__["second"] = _openstudioutilitiestime.DateTimePair_second_get

    if _newclass:

        second = _swig_property(_openstudioutilitiestime.DateTimePair_second_get, _openstudioutilitiestime.DateTimePair_second_set)

    def __len__(self):

        return 2

    def __repr__(self):

        return str((self.first, self.second))

    def __getitem__(self, index): 

        if not (index % 2):

            return self.first

        else:

            return self.second

    def __setitem__(self, index, val):

        if not (index % 2):

            self.first = val

        else:

            self.second = val

    __swig_destroy__ = _openstudioutilitiestime.delete_DateTimePair

    __del__ = lambda self: None

DateTimePair_swigregister = _openstudioutilitiestime.DateTimePair_swigregister

DateTimePair_swigregister(DateTimePair)



class OptionalDateTimePair(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDateTimePair, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDateTimePair, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalDateTimePair(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalDateTimePair_reset(self)



    def __ref__(self) -> "std::pair< openstudio::DateTime,openstudio::DateTime >":

        return _openstudioutilitiestime.OptionalDateTimePair___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalDateTimePair_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalDateTimePair_isNull(self)



    def get(self) -> "std::pair< openstudio::DateTime,openstudio::DateTime >":

        return _openstudioutilitiestime.OptionalDateTimePair_get(self)



    def set(self, t: 'DateTimePair') -> "void":

        return _openstudioutilitiestime.OptionalDateTimePair_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalDateTimePair

    __del__ = lambda self: None

OptionalDateTimePair_swigregister = _openstudioutilitiestime.OptionalDateTimePair_swigregister

OptionalDateTimePair_swigregister(OptionalDateTimePair)



class OptionalDateTime(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalDateTime, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalDateTime, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalDateTime(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalDateTime_reset(self)



    def __ref__(self) -> "openstudio::DateTime":

        return _openstudioutilitiestime.OptionalDateTime___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalDateTime_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalDateTime_isNull(self)



    def get(self) -> "openstudio::DateTime":

        return _openstudioutilitiestime.OptionalDateTime_get(self)



    def set(self, t: 'DateTime') -> "void":

        return _openstudioutilitiestime.OptionalDateTime_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalDateTime

    __del__ = lambda self: None

OptionalDateTime_swigregister = _openstudioutilitiestime.OptionalDateTime_swigregister

OptionalDateTime_swigregister(OptionalDateTime)



class DateTime(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DateTime, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DateTime, name)

    __repr__ = _swig_repr

    __swig_getmethods__["logChannel"] = lambda x: _openstudioutilitiestime.DateTime_logChannel

    if _newclass:

        logChannel = staticmethod(_openstudioutilitiestime.DateTime_logChannel)

    __swig_getmethods__["now"] = lambda x: _openstudioutilitiestime.DateTime_now

    if _newclass:

        now = staticmethod(_openstudioutilitiestime.DateTime_now)

    __swig_getmethods__["nowUTC"] = lambda x: _openstudioutilitiestime.DateTime_nowUTC

    if _newclass:

        nowUTC = staticmethod(_openstudioutilitiestime.DateTime_nowUTC)

    __swig_getmethods__["localOffsetUTC"] = lambda x: _openstudioutilitiestime.DateTime_localOffsetUTC

    if _newclass:

        localOffsetUTC = staticmethod(_openstudioutilitiestime.DateTime_localOffsetUTC)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_DateTime(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def __add__(self, time: 'Time') -> "openstudio::DateTime":

        return _openstudioutilitiestime.DateTime___add__(self, time)



    def __iadd__(self, time: 'Time') -> "openstudio::DateTime &":

        return _openstudioutilitiestime.DateTime___iadd__(self, time)



    def __isub__(self, time: 'Time') -> "openstudio::DateTime &":

        return _openstudioutilitiestime.DateTime___isub__(self, time)



    def __sub__(self, *args) -> "openstudio::Time":

        return _openstudioutilitiestime.DateTime___sub__(self, *args)



    def __eq__(self, other: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___eq__(self, other)



    def __ne__(self, other: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___ne__(self, other)



    def __lt__(self, rhs: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___lt__(self, rhs)



    def __le__(self, rhs: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___le__(self, rhs)



    def __gt__(self, rhs: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___gt__(self, rhs)



    def __ge__(self, rhs: 'DateTime') -> "bool":

        return _openstudioutilitiestime.DateTime___ge__(self, rhs)



    def date(self) -> "openstudio::Date":

        return _openstudioutilitiestime.DateTime_date(self)



    def time(self) -> "openstudio::Time":

        return _openstudioutilitiestime.DateTime_time(self)



    def utcOffset(self) -> "double":

        return _openstudioutilitiestime.DateTime_utcOffset(self)



    def toString(self) -> "std::string":

        return _openstudioutilitiestime.DateTime_toString(self)



    def toISO8601(self) -> "std::string":

        return _openstudioutilitiestime.DateTime_toISO8601(self)



    def toXsdDateTime(self) -> "std::string":

        return _openstudioutilitiestime.DateTime_toXsdDateTime(self)



    def toEpoch(self) -> "time_t":

        return _openstudioutilitiestime.DateTime_toEpoch(self)

    __swig_getmethods__["fromISO8601"] = lambda x: _openstudioutilitiestime.DateTime_fromISO8601

    if _newclass:

        fromISO8601 = staticmethod(_openstudioutilitiestime.DateTime_fromISO8601)

    __swig_getmethods__["fromXsdDateTime"] = lambda x: _openstudioutilitiestime.DateTime_fromXsdDateTime

    if _newclass:

        fromXsdDateTime = staticmethod(_openstudioutilitiestime.DateTime_fromXsdDateTime)

    __swig_getmethods__["fromEpoch"] = lambda x: _openstudioutilitiestime.DateTime_fromEpoch

    if _newclass:

        fromEpoch = staticmethod(_openstudioutilitiestime.DateTime_fromEpoch)



    def __str__(self) -> "std::string":

        return _openstudioutilitiestime.DateTime___str__(self)



    def __hash__(self) -> "std::string":

        return _openstudioutilitiestime.DateTime___hash__(self)



    def __cmp__(self, other: 'DateTime') -> "int":

        return _openstudioutilitiestime.DateTime___cmp__(self, other)



    def toEpochLong(self) -> "long":

        return _openstudioutilitiestime.DateTime_toEpochLong(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_DateTime

    __del__ = lambda self: None

DateTime_swigregister = _openstudioutilitiestime.DateTime_swigregister

DateTime_swigregister(DateTime)



def DateTime_logChannel() -> "openstudio::LogChannel":

    return _openstudioutilitiestime.DateTime_logChannel()

DateTime_logChannel = _openstudioutilitiestime.DateTime_logChannel



def DateTime_now() -> "openstudio::DateTime":

    return _openstudioutilitiestime.DateTime_now()

DateTime_now = _openstudioutilitiestime.DateTime_now



def DateTime_nowUTC() -> "openstudio::DateTime":

    return _openstudioutilitiestime.DateTime_nowUTC()

DateTime_nowUTC = _openstudioutilitiestime.DateTime_nowUTC



def DateTime_localOffsetUTC() -> "double":

    return _openstudioutilitiestime.DateTime_localOffsetUTC()

DateTime_localOffsetUTC = _openstudioutilitiestime.DateTime_localOffsetUTC



def DateTime_fromISO8601(str: 'std::string const &') -> "boost::optional< openstudio::DateTime >":

    return _openstudioutilitiestime.DateTime_fromISO8601(str)

DateTime_fromISO8601 = _openstudioutilitiestime.DateTime_fromISO8601



def DateTime_fromXsdDateTime(str: 'std::string const &') -> "boost::optional< openstudio::DateTime >":

    return _openstudioutilitiestime.DateTime_fromXsdDateTime(str)

DateTime_fromXsdDateTime = _openstudioutilitiestime.DateTime_fromXsdDateTime



def DateTime_fromEpoch(time: 'std::time_t const &') -> "openstudio::DateTime":

    return _openstudioutilitiestime.DateTime_fromEpoch(time)

DateTime_fromEpoch = _openstudioutilitiestime.DateTime_fromEpoch





def __lshift__(*args) -> "std::ostream &":

    return _openstudioutilitiestime.__lshift__(*args)

__lshift__ = _openstudioutilitiestime.__lshift__



def toDateTime(qdt: 'QDateTime') -> "openstudio::DateTime":

    return _openstudioutilitiestime.toDateTime(qdt)

toDateTime = _openstudioutilitiestime.toDateTime



def toQDateTime(dt: 'DateTime') -> "QDateTime":

    return _openstudioutilitiestime.toQDateTime(dt)

toQDateTime = _openstudioutilitiestime.toQDateTime

class CalendarVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, CalendarVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, CalendarVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudioutilitiestime.CalendarVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudioutilitiestime.CalendarVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudioutilitiestime.CalendarVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::Calendar >::size_type":

        return _openstudioutilitiestime.CalendarVector___len__(self)



    def pop(self) -> "std::vector< openstudio::Calendar >::value_type":

        return _openstudioutilitiestime.CalendarVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::Calendar >::difference_type', j: 'std::vector< openstudio::Calendar >::difference_type') -> "std::vector< openstudio::Calendar,std::allocator< openstudio::Calendar > > *":

        return _openstudioutilitiestime.CalendarVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudioutilitiestime.CalendarVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::Calendar >::difference_type', j: 'std::vector< openstudio::Calendar >::difference_type') -> "void":

        return _openstudioutilitiestime.CalendarVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudioutilitiestime.CalendarVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::Calendar >::value_type const &":

        return _openstudioutilitiestime.CalendarVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudioutilitiestime.CalendarVector___setitem__(self, *args)



    def append(self, x: 'Calendar') -> "void":

        return _openstudioutilitiestime.CalendarVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudioutilitiestime.CalendarVector_empty(self)



    def size(self) -> "std::vector< openstudio::Calendar >::size_type":

        return _openstudioutilitiestime.CalendarVector_size(self)



    def clear(self) -> "void":

        return _openstudioutilitiestime.CalendarVector_clear(self)



    def swap(self, v: 'CalendarVector') -> "void":

        return _openstudioutilitiestime.CalendarVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::Calendar >::allocator_type":

        return _openstudioutilitiestime.CalendarVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::Calendar >::iterator":

        return _openstudioutilitiestime.CalendarVector_begin(self)



    def end(self) -> "std::vector< openstudio::Calendar >::iterator":

        return _openstudioutilitiestime.CalendarVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::Calendar >::reverse_iterator":

        return _openstudioutilitiestime.CalendarVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::Calendar >::reverse_iterator":

        return _openstudioutilitiestime.CalendarVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudioutilitiestime.CalendarVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::Calendar >::iterator":

        return _openstudioutilitiestime.CalendarVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_CalendarVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'Calendar') -> "void":

        return _openstudioutilitiestime.CalendarVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::Calendar >::value_type const &":

        return _openstudioutilitiestime.CalendarVector_front(self)



    def back(self) -> "std::vector< openstudio::Calendar >::value_type const &":

        return _openstudioutilitiestime.CalendarVector_back(self)



    def assign(self, n: 'std::vector< openstudio::Calendar >::size_type', x: 'Calendar') -> "void":

        return _openstudioutilitiestime.CalendarVector_assign(self, n, x)



    def resize(self, *args) -> "void":

        return _openstudioutilitiestime.CalendarVector_resize(self, *args)



    def insert(self, *args) -> "void":

        return _openstudioutilitiestime.CalendarVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::Calendar >::size_type') -> "void":

        return _openstudioutilitiestime.CalendarVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::Calendar >::size_type":

        return _openstudioutilitiestime.CalendarVector_capacity(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_CalendarVector

    __del__ = lambda self: None

CalendarVector_swigregister = _openstudioutilitiestime.CalendarVector_swigregister

CalendarVector_swigregister(CalendarVector)



class OptionalCalendar(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalCalendar, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalCalendar, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_OptionalCalendar(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudioutilitiestime.OptionalCalendar_reset(self)



    def __ref__(self) -> "openstudio::Calendar":

        return _openstudioutilitiestime.OptionalCalendar___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudioutilitiestime.OptionalCalendar_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudioutilitiestime.OptionalCalendar_isNull(self)



    def get(self) -> "openstudio::Calendar":

        return _openstudioutilitiestime.OptionalCalendar_get(self)



    def set(self, t: 'Calendar') -> "void":

        return _openstudioutilitiestime.OptionalCalendar_set(self, t)

    __swig_destroy__ = _openstudioutilitiestime.delete_OptionalCalendar

    __del__ = lambda self: None

OptionalCalendar_swigregister = _openstudioutilitiestime.OptionalCalendar_swigregister

OptionalCalendar_swigregister(OptionalCalendar)



class Calendar(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, Calendar, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, Calendar, name)

    __repr__ = _swig_repr

    __swig_getmethods__["logChannel"] = lambda x: _openstudioutilitiestime.Calendar_logChannel

    if _newclass:

        logChannel = staticmethod(_openstudioutilitiestime.Calendar_logChannel)



    def __init__(self, *args):

        this = _openstudioutilitiestime.new_Calendar(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def standardDaylightSavings(self) -> "void":

        return _openstudioutilitiestime.Calendar_standardDaylightSavings(self)



    def standardHolidays(self) -> "void":

        return _openstudioutilitiestime.Calendar_standardHolidays(self)



    def daylightSavings(self, daylightSavingsStart: 'Date', daylightSavingsEnd: 'Date') -> "void":

        return _openstudioutilitiestime.Calendar_daylightSavings(self, daylightSavingsStart, daylightSavingsEnd)



    def addHoliday(self, date: 'Date', name: 'std::string const &') -> "void":

        return _openstudioutilitiestime.Calendar_addHoliday(self, date, name)



    def addNamedDay(self, date: 'Date', name: 'std::string const &') -> "void":

        return _openstudioutilitiestime.Calendar_addNamedDay(self, date, name)



    def includesDate(self, date: 'Date') -> "bool":

        return _openstudioutilitiestime.Calendar_includesDate(self, date)



    def isDaylightSavings(self, date: 'Date') -> "bool":

        return _openstudioutilitiestime.Calendar_isDaylightSavings(self, date)



    def isHoliday(self, date: 'Date') -> "bool":

        return _openstudioutilitiestime.Calendar_isHoliday(self, date)



    def isNamedDay(self, date: 'Date') -> "bool":

        return _openstudioutilitiestime.Calendar_isNamedDay(self, date)



    def getName(self, date: 'Date') -> "std::string":

        return _openstudioutilitiestime.Calendar_getName(self, date)



    def startDate(self) -> "openstudio::Date":

        return _openstudioutilitiestime.Calendar_startDate(self)



    def endDate(self) -> "openstudio::Date":

        return _openstudioutilitiestime.Calendar_endDate(self)

    __swig_destroy__ = _openstudioutilitiestime.delete_Calendar

    __del__ = lambda self: None

Calendar_swigregister = _openstudioutilitiestime.Calendar_swigregister

Calendar_swigregister(Calendar)



def Calendar_logChannel() -> "openstudio::LogChannel":

    return _openstudioutilitiestime.Calendar_logChannel()

Calendar_logChannel = _openstudioutilitiestime.Calendar_logChannel



# This file is compatible with both classic and new-style classes.





