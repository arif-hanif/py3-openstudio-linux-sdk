# This file was automatically generated by SWIG (http://www.swig.org).

# Version 3.0.7

#

# Do not make changes to this file unless you know what you are doing--modify

# the SWIG interface file instead.











from sys import version_info

if version_info >= (2, 6, 0):

    def swig_import_helper():

        from os.path import dirname

        import imp

        fp = None

        try:

            fp, pathname, description = imp.find_module('_openstudiomodelairflow', [dirname(__file__)])

        except ImportError:

            import _openstudiomodelairflow

            return _openstudiomodelairflow

        if fp is not None:

            try:

                _mod = imp.load_module('_openstudiomodelairflow', fp, pathname, description)

            finally:

                fp.close()

            return _mod

    _openstudiomodelairflow = swig_import_helper()

    del swig_import_helper

else:

    import _openstudiomodelairflow

del version_info

try:

    _swig_property = property

except NameError:

    pass  # Python < 2.2 doesn't have 'property'.





def _swig_setattr_nondynamic(self, class_type, name, value, static=1):

    if (name == "thisown"):

        return self.this.own(value)

    if (name == "this"):

        if type(value).__name__ == 'SwigPyObject':

            self.__dict__[name] = value

            return

    method = class_type.__swig_setmethods__.get(name, None)

    if method:

        return method(self, value)

    if (not static):

        if _newclass:

            object.__setattr__(self, name, value)

        else:

            self.__dict__[name] = value

    else:

        raise AttributeError("You cannot add attributes to %s" % self)





def _swig_setattr(self, class_type, name, value):

    return _swig_setattr_nondynamic(self, class_type, name, value, 0)





def _swig_getattr_nondynamic(self, class_type, name, static=1):

    if (name == "thisown"):

        return self.this.own()

    method = class_type.__swig_getmethods__.get(name, None)

    if method:

        return method(self)

    if (not static):

        return object.__getattr__(self, name)

    else:

        raise AttributeError(name)



def _swig_getattr(self, class_type, name):

    return _swig_getattr_nondynamic(self, class_type, name, 0)





def _swig_repr(self):

    try:

        strthis = "proxy of " + self.this.__repr__()

    except:

        strthis = ""

    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)



try:

    _object = object

    _newclass = 1

except AttributeError:

    class _object:

        pass

    _newclass = 0





try:

    import weakref

    weakref_proxy = weakref.proxy

except:

    weakref_proxy = lambda x: x





class SwigPyIterator(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined - class is abstract")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_SwigPyIterator

    __del__ = lambda self: None



    def value(self) -> "PyObject *":

        return _openstudiomodelairflow.SwigPyIterator_value(self)



    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.SwigPyIterator_incr(self, n)



    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.SwigPyIterator_decr(self, n)



    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":

        return _openstudiomodelairflow.SwigPyIterator_distance(self, x)



    def equal(self, x: 'SwigPyIterator') -> "bool":

        return _openstudiomodelairflow.SwigPyIterator_equal(self, x)



    def copy(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.SwigPyIterator_copy(self)



    def next(self) -> "PyObject *":

        return _openstudiomodelairflow.SwigPyIterator_next(self)



    def __next__(self) -> "PyObject *":

        return _openstudiomodelairflow.SwigPyIterator___next__(self)



    def previous(self) -> "PyObject *":

        return _openstudiomodelairflow.SwigPyIterator_previous(self)



    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.SwigPyIterator_advance(self, n)



    def __eq__(self, x: 'SwigPyIterator') -> "bool":

        return _openstudiomodelairflow.SwigPyIterator___eq__(self, x)



    def __ne__(self, x: 'SwigPyIterator') -> "bool":

        return _openstudiomodelairflow.SwigPyIterator___ne__(self, x)



    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":

        return _openstudiomodelairflow.SwigPyIterator___iadd__(self, n)



    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":

        return _openstudiomodelairflow.SwigPyIterator___isub__(self, n)



    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.SwigPyIterator___add__(self, n)



    def __sub__(self, *args) -> "ptrdiff_t":

        return _openstudiomodelairflow.SwigPyIterator___sub__(self, *args)

    def __iter__(self):

        return self

SwigPyIterator_swigregister = _openstudiomodelairflow.SwigPyIterator_swigregister

SwigPyIterator_swigregister(SwigPyIterator)





_openstudiomodelairflow.SHARED_PTR_DISOWN_swigconstant(_openstudiomodelairflow)

SHARED_PTR_DISOWN = _openstudiomodelairflow.SHARED_PTR_DISOWN

from .import openstudioutilities

from .import openstudioutilitiescore

from .import openstudioutilitiestime

from .import openstudioutilitiesdata

from .import openstudioutilitiesunits

from .import openstudioutilitiesplot

from .import openstudioutilitiesgeometry

from .import openstudioutilitiessql

from .import openstudioutilitiesbcl

from .import openstudioutilitiesidd

from .import openstudioutilitiesidf

from .import openstudioutilitiesfiletypes

from .import openstudiomodelcore

from .import openstudiomodelsimulation

from .import openstudiomodelresources

from .import openstudiomodelgeometry

from .import openstudiomodelhvac

class AirflowNetworkComponentVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkComponentVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkComponentVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::size_type":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::value_type":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkComponent >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkComponent >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkComponent,std::allocator< openstudio::model::AirflowNetworkComponent > > *":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkComponent >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkComponent >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkComponent >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkComponent') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::size_type":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_clear(self)



    def swap(self, v: 'AirflowNetworkComponentVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::iterator":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::iterator":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkComponent >::iterator":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkComponentVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkComponent') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkComponent >::size_type', x: 'AirflowNetworkComponent') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkComponent >::size_type', x: 'AirflowNetworkComponent') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkComponent >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkComponent >::size_type":

        return _openstudiomodelairflow.AirflowNetworkComponentVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkComponentVector

    __del__ = lambda self: None

AirflowNetworkComponentVector_swigregister = _openstudiomodelairflow.AirflowNetworkComponentVector_swigregister

AirflowNetworkComponentVector_swigregister(AirflowNetworkComponentVector)



class OptionalAirflowNetworkComponent(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkComponent, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkComponent, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkComponent(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkComponent":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkComponent":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent_get(self)



    def set(self, t: 'AirflowNetworkComponent') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkComponent_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkComponent

    __del__ = lambda self: None

OptionalAirflowNetworkComponent_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkComponent_swigregister

OptionalAirflowNetworkComponent_swigregister(OptionalAirflowNetworkComponent)



class AirflowNetworkNodeVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkNodeVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkNodeVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::value_type":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkNode >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkNode,std::allocator< openstudio::model::AirflowNetworkNode > > *":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkNode >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_clear(self)



    def swap(self, v: 'AirflowNetworkNodeVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkNodeVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkNode >::size_type', x: 'AirflowNetworkNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkNode >::size_type', x: 'AirflowNetworkNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkNode >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkNodeVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkNodeVector

    __del__ = lambda self: None

AirflowNetworkNodeVector_swigregister = _openstudiomodelairflow.AirflowNetworkNodeVector_swigregister

AirflowNetworkNodeVector_swigregister(AirflowNetworkNodeVector)



class OptionalAirflowNetworkNode(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkNode, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkNode, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkNode(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode_get(self)



    def set(self, t: 'AirflowNetworkNode') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkNode_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkNode

    __del__ = lambda self: None

OptionalAirflowNetworkNode_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkNode_swigregister

OptionalAirflowNetworkNode_swigregister(OptionalAirflowNetworkNode)



class AirflowNetworkLinkageVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkLinkageVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkLinkageVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::value_type":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkLinkage >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkLinkage >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkLinkage,std::allocator< openstudio::model::AirflowNetworkLinkage > > *":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkLinkage >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkLinkage >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_clear(self)



    def swap(self, v: 'AirflowNetworkLinkageVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkLinkageVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkLinkage >::size_type', x: 'AirflowNetworkLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkLinkage >::size_type', x: 'AirflowNetworkLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkLinkage >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLinkageVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkLinkageVector

    __del__ = lambda self: None

AirflowNetworkLinkageVector_swigregister = _openstudiomodelairflow.AirflowNetworkLinkageVector_swigregister

AirflowNetworkLinkageVector_swigregister(AirflowNetworkLinkageVector)



class OptionalAirflowNetworkLinkage(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkLinkage, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkLinkage, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkLinkage(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkLinkage":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkLinkage":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage_get(self)



    def set(self, t: 'AirflowNetworkLinkage') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkLinkage_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkLinkage

    __del__ = lambda self: None

OptionalAirflowNetworkLinkage_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkLinkage_swigregister

OptionalAirflowNetworkLinkage_swigregister(OptionalAirflowNetworkLinkage)



class AirflowNetworkComponent(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkComponent, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkComponent, name)

    __repr__ = _swig_repr



    def __init__(self, type: 'IddObjectType', model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkComponent(type, model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkComponent

    __del__ = lambda self: None



    def componentModelObject(self) -> "boost::optional< openstudio::model::ModelObject >":

        return _openstudiomodelairflow.AirflowNetworkComponent_componentModelObject(self)

AirflowNetworkComponent_swigregister = _openstudiomodelairflow.AirflowNetworkComponent_swigregister

AirflowNetworkComponent_swigregister(AirflowNetworkComponent)





def toAirflowNetworkComponent(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkComponent >":

    return _openstudiomodelairflow.toAirflowNetworkComponent(idfObject)

toAirflowNetworkComponent = _openstudiomodelairflow.toAirflowNetworkComponent



def getAirflowNetworkComponent(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkComponent >":

    return _openstudiomodelairflow.getAirflowNetworkComponent(t_model, t_handle)

getAirflowNetworkComponent = _openstudiomodelairflow.getAirflowNetworkComponent



def getAirflowNetworkComponents(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkComponent,std::allocator< openstudio::model::AirflowNetworkComponent > >":

    return _openstudiomodelairflow.getAirflowNetworkComponents(t_model)

getAirflowNetworkComponents = _openstudiomodelairflow.getAirflowNetworkComponents



def getAirflowNetworkComponentByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkComponent >":

    return _openstudiomodelairflow.getAirflowNetworkComponentByName(t_model, t_name)

getAirflowNetworkComponentByName = _openstudiomodelairflow.getAirflowNetworkComponentByName



def getAirflowNetworkComponentsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkComponent,std::allocator< openstudio::model::AirflowNetworkComponent > >":

    return _openstudiomodelairflow.getAirflowNetworkComponentsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkComponentsByName = _openstudiomodelairflow.getAirflowNetworkComponentsByName

class AirflowNetworkNode(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkNode, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkNode, name)

    __repr__ = _swig_repr



    def __init__(self, type: 'IddObjectType', model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkNode(type, model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkNode

    __del__ = lambda self: None

AirflowNetworkNode_swigregister = _openstudiomodelairflow.AirflowNetworkNode_swigregister

AirflowNetworkNode_swigregister(AirflowNetworkNode)





def toAirflowNetworkNode(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkNode >":

    return _openstudiomodelairflow.toAirflowNetworkNode(idfObject)

toAirflowNetworkNode = _openstudiomodelairflow.toAirflowNetworkNode



def getAirflowNetworkNode(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkNode >":

    return _openstudiomodelairflow.getAirflowNetworkNode(t_model, t_handle)

getAirflowNetworkNode = _openstudiomodelairflow.getAirflowNetworkNode



def getAirflowNetworkNodes(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkNode,std::allocator< openstudio::model::AirflowNetworkNode > >":

    return _openstudiomodelairflow.getAirflowNetworkNodes(t_model)

getAirflowNetworkNodes = _openstudiomodelairflow.getAirflowNetworkNodes



def getAirflowNetworkNodeByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkNode >":

    return _openstudiomodelairflow.getAirflowNetworkNodeByName(t_model, t_name)

getAirflowNetworkNodeByName = _openstudiomodelairflow.getAirflowNetworkNodeByName



def getAirflowNetworkNodesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkNode,std::allocator< openstudio::model::AirflowNetworkNode > >":

    return _openstudiomodelairflow.getAirflowNetworkNodesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkNodesByName = _openstudiomodelairflow.getAirflowNetworkNodesByName

class AirflowNetworkLinkage(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkLinkage, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkLinkage, name)

    __repr__ = _swig_repr



    def __init__(self, type: 'IddObjectType', model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkLinkage(type, model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkLinkage

    __del__ = lambda self: None

AirflowNetworkLinkage_swigregister = _openstudiomodelairflow.AirflowNetworkLinkage_swigregister

AirflowNetworkLinkage_swigregister(AirflowNetworkLinkage)





def toAirflowNetworkLinkage(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkLinkage >":

    return _openstudiomodelairflow.toAirflowNetworkLinkage(idfObject)

toAirflowNetworkLinkage = _openstudiomodelairflow.toAirflowNetworkLinkage



def getAirflowNetworkLinkage(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkLinkage >":

    return _openstudiomodelairflow.getAirflowNetworkLinkage(t_model, t_handle)

getAirflowNetworkLinkage = _openstudiomodelairflow.getAirflowNetworkLinkage



def getAirflowNetworkLinkages(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkLinkage,std::allocator< openstudio::model::AirflowNetworkLinkage > >":

    return _openstudiomodelairflow.getAirflowNetworkLinkages(t_model)

getAirflowNetworkLinkages = _openstudiomodelairflow.getAirflowNetworkLinkages



def getAirflowNetworkLinkageByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkLinkage >":

    return _openstudiomodelairflow.getAirflowNetworkLinkageByName(t_model, t_name)

getAirflowNetworkLinkageByName = _openstudiomodelairflow.getAirflowNetworkLinkageByName



def getAirflowNetworkLinkagesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkLinkage,std::allocator< openstudio::model::AirflowNetworkLinkage > >":

    return _openstudiomodelairflow.getAirflowNetworkLinkagesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkLinkagesByName = _openstudiomodelairflow.getAirflowNetworkLinkagesByName

class AirflowNetworkConstantPressureDropVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkConstantPressureDropVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkConstantPressureDropVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::value_type":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop,std::allocator< openstudio::model::AirflowNetworkConstantPressureDrop > > *":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkConstantPressureDrop') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_clear(self)



    def swap(self, v: 'AirflowNetworkConstantPressureDropVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::iterator":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::iterator":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::iterator":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkConstantPressureDropVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkConstantPressureDrop') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type', x: 'AirflowNetworkConstantPressureDrop') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type', x: 'AirflowNetworkConstantPressureDrop') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop >::size_type":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkConstantPressureDropVector

    __del__ = lambda self: None

AirflowNetworkConstantPressureDropVector_swigregister = _openstudiomodelairflow.AirflowNetworkConstantPressureDropVector_swigregister

AirflowNetworkConstantPressureDropVector_swigregister(AirflowNetworkConstantPressureDropVector)



class OptionalAirflowNetworkConstantPressureDrop(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkConstantPressureDrop, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkConstantPressureDrop, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkConstantPressureDrop(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkConstantPressureDrop":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkConstantPressureDrop":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_get(self)



    def set(self, t: 'AirflowNetworkConstantPressureDrop') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkConstantPressureDrop

    __del__ = lambda self: None

OptionalAirflowNetworkConstantPressureDrop_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkConstantPressureDrop_swigregister

OptionalAirflowNetworkConstantPressureDrop_swigregister(OptionalAirflowNetworkConstantPressureDrop)



class AirflowNetworkCrackVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkCrackVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkCrackVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::size_type":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::value_type":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkCrack >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkCrack >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkCrack,std::allocator< openstudio::model::AirflowNetworkCrack > > *":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkCrack >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkCrack >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkCrack >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkCrack') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::size_type":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_clear(self)



    def swap(self, v: 'AirflowNetworkCrackVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::iterator":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::iterator":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkCrack >::iterator":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkCrackVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkCrack') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkCrack >::size_type', x: 'AirflowNetworkCrack') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkCrack >::size_type', x: 'AirflowNetworkCrack') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkCrack >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkCrack >::size_type":

        return _openstudiomodelairflow.AirflowNetworkCrackVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkCrackVector

    __del__ = lambda self: None

AirflowNetworkCrackVector_swigregister = _openstudiomodelairflow.AirflowNetworkCrackVector_swigregister

AirflowNetworkCrackVector_swigregister(AirflowNetworkCrackVector)



class OptionalAirflowNetworkCrack(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkCrack, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkCrack, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkCrack(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkCrack":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkCrack":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack_get(self)



    def set(self, t: 'AirflowNetworkCrack') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkCrack_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkCrack

    __del__ = lambda self: None

OptionalAirflowNetworkCrack_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkCrack_swigregister

OptionalAirflowNetworkCrack_swigregister(OptionalAirflowNetworkCrack)



class AirflowNetworkDetailedOpeningVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDetailedOpeningVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDetailedOpeningVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::value_type":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening,std::allocator< openstudio::model::AirflowNetworkDetailedOpening > > *":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkDetailedOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_clear(self)



    def swap(self, v: 'AirflowNetworkDetailedOpeningVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDetailedOpeningVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkDetailedOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type', x: 'AirflowNetworkDetailedOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type', x: 'AirflowNetworkDetailedOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDetailedOpeningVector

    __del__ = lambda self: None

AirflowNetworkDetailedOpeningVector_swigregister = _openstudiomodelairflow.AirflowNetworkDetailedOpeningVector_swigregister

AirflowNetworkDetailedOpeningVector_swigregister(AirflowNetworkDetailedOpeningVector)



class OptionalAirflowNetworkDetailedOpening(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkDetailedOpening, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkDetailedOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkDetailedOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkDetailedOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkDetailedOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_get(self)



    def set(self, t: 'AirflowNetworkDetailedOpening') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkDetailedOpening

    __del__ = lambda self: None

OptionalAirflowNetworkDetailedOpening_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkDetailedOpening_swigregister

OptionalAirflowNetworkDetailedOpening_swigregister(OptionalAirflowNetworkDetailedOpening)



class AirflowNetworkDistributionLinkageVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDistributionLinkageVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDistributionLinkageVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::value_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage,std::allocator< openstudio::model::AirflowNetworkDistributionLinkage > > *":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkDistributionLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_clear(self)



    def swap(self, v: 'AirflowNetworkDistributionLinkageVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDistributionLinkageVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkDistributionLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type', x: 'AirflowNetworkDistributionLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type', x: 'AirflowNetworkDistributionLinkage') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDistributionLinkageVector

    __del__ = lambda self: None

AirflowNetworkDistributionLinkageVector_swigregister = _openstudiomodelairflow.AirflowNetworkDistributionLinkageVector_swigregister

AirflowNetworkDistributionLinkageVector_swigregister(AirflowNetworkDistributionLinkageVector)



class OptionalAirflowNetworkDistributionLinkage(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkDistributionLinkage, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkDistributionLinkage, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkDistributionLinkage(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkDistributionLinkage":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkDistributionLinkage":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_get(self)



    def set(self, t: 'AirflowNetworkDistributionLinkage') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkDistributionLinkage

    __del__ = lambda self: None

OptionalAirflowNetworkDistributionLinkage_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkDistributionLinkage_swigregister

OptionalAirflowNetworkDistributionLinkage_swigregister(OptionalAirflowNetworkDistributionLinkage)



class AirflowNetworkDistributionNodeVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDistributionNodeVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDistributionNodeVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::value_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkDistributionNode,std::allocator< openstudio::model::AirflowNetworkDistributionNode > > *":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkDistributionNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_clear(self)



    def swap(self, v: 'AirflowNetworkDistributionNodeVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDistributionNodeVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkDistributionNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type', x: 'AirflowNetworkDistributionNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type', x: 'AirflowNetworkDistributionNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkDistributionNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDistributionNodeVector

    __del__ = lambda self: None

AirflowNetworkDistributionNodeVector_swigregister = _openstudiomodelairflow.AirflowNetworkDistributionNodeVector_swigregister

AirflowNetworkDistributionNodeVector_swigregister(AirflowNetworkDistributionNodeVector)



class OptionalAirflowNetworkDistributionNode(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkDistributionNode, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkDistributionNode, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkDistributionNode(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkDistributionNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkDistributionNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_get(self)



    def set(self, t: 'AirflowNetworkDistributionNode') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkDistributionNode

    __del__ = lambda self: None

OptionalAirflowNetworkDistributionNode_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkDistributionNode_swigregister

OptionalAirflowNetworkDistributionNode_swigregister(OptionalAirflowNetworkDistributionNode)



class AirflowNetworkDuctVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDuctVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDuctVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::value_type":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDuct >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDuct >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkDuct,std::allocator< openstudio::model::AirflowNetworkDuct > > *":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDuct >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDuct >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_clear(self)



    def swap(self, v: 'AirflowNetworkDuctVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDuctVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkDuct >::size_type', x: 'AirflowNetworkDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkDuct >::size_type', x: 'AirflowNetworkDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkDuct >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDuctVector

    __del__ = lambda self: None

AirflowNetworkDuctVector_swigregister = _openstudiomodelairflow.AirflowNetworkDuctVector_swigregister

AirflowNetworkDuctVector_swigregister(AirflowNetworkDuctVector)



class OptionalAirflowNetworkDuct(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkDuct, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkDuct, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkDuct(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkDuct":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkDuct":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct_get(self)



    def set(self, t: 'AirflowNetworkDuct') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuct_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkDuct

    __del__ = lambda self: None

OptionalAirflowNetworkDuct_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkDuct_swigregister

OptionalAirflowNetworkDuct_swigregister(OptionalAirflowNetworkDuct)



class AirflowNetworkDuctViewFactorsVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDuctViewFactorsVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDuctViewFactorsVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::value_type":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors,std::allocator< openstudio::model::AirflowNetworkDuctViewFactors > > *":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkDuctViewFactors') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_clear(self)



    def swap(self, v: 'AirflowNetworkDuctViewFactorsVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::iterator":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDuctViewFactorsVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkDuctViewFactors') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type', x: 'AirflowNetworkDuctViewFactors') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type', x: 'AirflowNetworkDuctViewFactors') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors >::size_type":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDuctViewFactorsVector

    __del__ = lambda self: None

AirflowNetworkDuctViewFactorsVector_swigregister = _openstudiomodelairflow.AirflowNetworkDuctViewFactorsVector_swigregister

AirflowNetworkDuctViewFactorsVector_swigregister(AirflowNetworkDuctViewFactorsVector)



class OptionalAirflowNetworkDuctViewFactors(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkDuctViewFactors, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkDuctViewFactors, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkDuctViewFactors(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkDuctViewFactors":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkDuctViewFactors":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_get(self)



    def set(self, t: 'AirflowNetworkDuctViewFactors') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkDuctViewFactors

    __del__ = lambda self: None

OptionalAirflowNetworkDuctViewFactors_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkDuctViewFactors_swigregister

OptionalAirflowNetworkDuctViewFactors_swigregister(OptionalAirflowNetworkDuctViewFactors)



class AirflowNetworkEffectiveLeakageAreaVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkEffectiveLeakageAreaVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkEffectiveLeakageAreaVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::value_type":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea,std::allocator< openstudio::model::AirflowNetworkEffectiveLeakageArea > > *":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkEffectiveLeakageArea') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_clear(self)



    def swap(self, v: 'AirflowNetworkEffectiveLeakageAreaVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkEffectiveLeakageAreaVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkEffectiveLeakageArea') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type', x: 'AirflowNetworkEffectiveLeakageArea') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type', x: 'AirflowNetworkEffectiveLeakageArea') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkEffectiveLeakageAreaVector

    __del__ = lambda self: None

AirflowNetworkEffectiveLeakageAreaVector_swigregister = _openstudiomodelairflow.AirflowNetworkEffectiveLeakageAreaVector_swigregister

AirflowNetworkEffectiveLeakageAreaVector_swigregister(AirflowNetworkEffectiveLeakageAreaVector)



class OptionalAirflowNetworkEffectiveLeakageArea(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkEffectiveLeakageArea, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkEffectiveLeakageArea, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkEffectiveLeakageArea(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkEffectiveLeakageArea":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkEffectiveLeakageArea":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_get(self)



    def set(self, t: 'AirflowNetworkEffectiveLeakageArea') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkEffectiveLeakageArea

    __del__ = lambda self: None

OptionalAirflowNetworkEffectiveLeakageArea_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkEffectiveLeakageArea_swigregister

OptionalAirflowNetworkEffectiveLeakageArea_swigregister(OptionalAirflowNetworkEffectiveLeakageArea)



class AirflowNetworkEquivalentDuctVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkEquivalentDuctVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkEquivalentDuctVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::value_type":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct,std::allocator< openstudio::model::AirflowNetworkEquivalentDuct > > *":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkEquivalentDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_clear(self)



    def swap(self, v: 'AirflowNetworkEquivalentDuctVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::iterator":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkEquivalentDuctVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkEquivalentDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type', x: 'AirflowNetworkEquivalentDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type', x: 'AirflowNetworkEquivalentDuct') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct >::size_type":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkEquivalentDuctVector

    __del__ = lambda self: None

AirflowNetworkEquivalentDuctVector_swigregister = _openstudiomodelairflow.AirflowNetworkEquivalentDuctVector_swigregister

AirflowNetworkEquivalentDuctVector_swigregister(AirflowNetworkEquivalentDuctVector)



class OptionalAirflowNetworkEquivalentDuct(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkEquivalentDuct, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkEquivalentDuct, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkEquivalentDuct(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkEquivalentDuct":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkEquivalentDuct":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_get(self)



    def set(self, t: 'AirflowNetworkEquivalentDuct') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkEquivalentDuct

    __del__ = lambda self: None

OptionalAirflowNetworkEquivalentDuct_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkEquivalentDuct_swigregister

OptionalAirflowNetworkEquivalentDuct_swigregister(OptionalAirflowNetworkEquivalentDuct)



class AirflowNetworkExternalNodeVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkExternalNodeVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkExternalNodeVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::value_type":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkExternalNode,std::allocator< openstudio::model::AirflowNetworkExternalNode > > *":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkExternalNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_clear(self)



    def swap(self, v: 'AirflowNetworkExternalNodeVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::iterator":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkExternalNodeVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkExternalNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type', x: 'AirflowNetworkExternalNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type', x: 'AirflowNetworkExternalNode') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkExternalNode >::size_type":

        return _openstudiomodelairflow.AirflowNetworkExternalNodeVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkExternalNodeVector

    __del__ = lambda self: None

AirflowNetworkExternalNodeVector_swigregister = _openstudiomodelairflow.AirflowNetworkExternalNodeVector_swigregister

AirflowNetworkExternalNodeVector_swigregister(AirflowNetworkExternalNodeVector)



class OptionalAirflowNetworkExternalNode(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkExternalNode, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkExternalNode, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkExternalNode(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkExternalNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkExternalNode":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_get(self)



    def set(self, t: 'AirflowNetworkExternalNode') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkExternalNode

    __del__ = lambda self: None

OptionalAirflowNetworkExternalNode_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkExternalNode_swigregister

OptionalAirflowNetworkExternalNode_swigregister(OptionalAirflowNetworkExternalNode)



class AirflowNetworkFanVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkFanVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkFanVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkFanVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkFanVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkFanVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkFanVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::value_type":

        return _openstudiomodelairflow.AirflowNetworkFanVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkFan >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkFan >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkFan,std::allocator< openstudio::model::AirflowNetworkFan > > *":

        return _openstudiomodelairflow.AirflowNetworkFanVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkFan >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkFan >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkFanVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkFanVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkFanVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_clear(self)



    def swap(self, v: 'AirflowNetworkFanVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkFanVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkFanVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkFanVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkFanVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkFanVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkFanVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkFanVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkFanVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkFanVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkFan >::size_type', x: 'AirflowNetworkFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkFan >::size_type', x: 'AirflowNetworkFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkFan >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkFanVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkFanVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkFanVector

    __del__ = lambda self: None

AirflowNetworkFanVector_swigregister = _openstudiomodelairflow.AirflowNetworkFanVector_swigregister

AirflowNetworkFanVector_swigregister(AirflowNetworkFanVector)



class OptionalAirflowNetworkFan(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkFan, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkFan, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkFan(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkFan":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkFan":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan_get(self)



    def set(self, t: 'AirflowNetworkFan') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkFan_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkFan

    __del__ = lambda self: None

OptionalAirflowNetworkFan_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkFan_swigregister

OptionalAirflowNetworkFan_swigregister(OptionalAirflowNetworkFan)



class AirflowNetworkHorizontalOpeningVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkHorizontalOpeningVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkHorizontalOpeningVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::value_type":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening,std::allocator< openstudio::model::AirflowNetworkHorizontalOpening > > *":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkHorizontalOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_clear(self)



    def swap(self, v: 'AirflowNetworkHorizontalOpeningVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkHorizontalOpeningVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkHorizontalOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type', x: 'AirflowNetworkHorizontalOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type', x: 'AirflowNetworkHorizontalOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkHorizontalOpeningVector

    __del__ = lambda self: None

AirflowNetworkHorizontalOpeningVector_swigregister = _openstudiomodelairflow.AirflowNetworkHorizontalOpeningVector_swigregister

AirflowNetworkHorizontalOpeningVector_swigregister(AirflowNetworkHorizontalOpeningVector)



class OptionalAirflowNetworkHorizontalOpening(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkHorizontalOpening, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkHorizontalOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkHorizontalOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkHorizontalOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkHorizontalOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_get(self)



    def set(self, t: 'AirflowNetworkHorizontalOpening') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkHorizontalOpening

    __del__ = lambda self: None

OptionalAirflowNetworkHorizontalOpening_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkHorizontalOpening_swigregister

OptionalAirflowNetworkHorizontalOpening_swigregister(OptionalAirflowNetworkHorizontalOpening)



class AirflowNetworkLeakageRatioVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkLeakageRatioVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkLeakageRatioVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::value_type":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio,std::allocator< openstudio::model::AirflowNetworkLeakageRatio > > *":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkLeakageRatio') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_clear(self)



    def swap(self, v: 'AirflowNetworkLeakageRatioVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::iterator":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkLeakageRatioVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkLeakageRatio') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type', x: 'AirflowNetworkLeakageRatio') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type', x: 'AirflowNetworkLeakageRatio') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio >::size_type":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkLeakageRatioVector

    __del__ = lambda self: None

AirflowNetworkLeakageRatioVector_swigregister = _openstudiomodelairflow.AirflowNetworkLeakageRatioVector_swigregister

AirflowNetworkLeakageRatioVector_swigregister(AirflowNetworkLeakageRatioVector)



class OptionalAirflowNetworkLeakageRatio(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkLeakageRatio, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkLeakageRatio, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkLeakageRatio(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkLeakageRatio":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkLeakageRatio":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_get(self)



    def set(self, t: 'AirflowNetworkLeakageRatio') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkLeakageRatio

    __del__ = lambda self: None

OptionalAirflowNetworkLeakageRatio_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkLeakageRatio_swigregister

OptionalAirflowNetworkLeakageRatio_swigregister(OptionalAirflowNetworkLeakageRatio)



class AirflowNetworkOccupantVentilationControlVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkOccupantVentilationControlVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkOccupantVentilationControlVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::value_type":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl,std::allocator< openstudio::model::AirflowNetworkOccupantVentilationControl > > *":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkOccupantVentilationControl') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_clear(self)



    def swap(self, v: 'AirflowNetworkOccupantVentilationControlVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkOccupantVentilationControlVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkOccupantVentilationControl') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type', x: 'AirflowNetworkOccupantVentilationControl') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type', x: 'AirflowNetworkOccupantVentilationControl') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkOccupantVentilationControlVector

    __del__ = lambda self: None

AirflowNetworkOccupantVentilationControlVector_swigregister = _openstudiomodelairflow.AirflowNetworkOccupantVentilationControlVector_swigregister

AirflowNetworkOccupantVentilationControlVector_swigregister(AirflowNetworkOccupantVentilationControlVector)



class OptionalAirflowNetworkOccupantVentilationControl(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkOccupantVentilationControl, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkOccupantVentilationControl, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkOccupantVentilationControl(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkOccupantVentilationControl":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkOccupantVentilationControl":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_get(self)



    def set(self, t: 'AirflowNetworkOccupantVentilationControl') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkOccupantVentilationControl

    __del__ = lambda self: None

OptionalAirflowNetworkOccupantVentilationControl_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkOccupantVentilationControl_swigregister

OptionalAirflowNetworkOccupantVentilationControl_swigregister(OptionalAirflowNetworkOccupantVentilationControl)



class AirflowNetworkOutdoorAirflowVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkOutdoorAirflowVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkOutdoorAirflowVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::value_type":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow,std::allocator< openstudio::model::AirflowNetworkOutdoorAirflow > > *":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkOutdoorAirflow') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_clear(self)



    def swap(self, v: 'AirflowNetworkOutdoorAirflowVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::iterator":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkOutdoorAirflowVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkOutdoorAirflow') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type', x: 'AirflowNetworkOutdoorAirflow') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type', x: 'AirflowNetworkOutdoorAirflow') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow >::size_type":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkOutdoorAirflowVector

    __del__ = lambda self: None

AirflowNetworkOutdoorAirflowVector_swigregister = _openstudiomodelairflow.AirflowNetworkOutdoorAirflowVector_swigregister

AirflowNetworkOutdoorAirflowVector_swigregister(AirflowNetworkOutdoorAirflowVector)



class OptionalAirflowNetworkOutdoorAirflow(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkOutdoorAirflow, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkOutdoorAirflow, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkOutdoorAirflow(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkOutdoorAirflow":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkOutdoorAirflow":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_get(self)



    def set(self, t: 'AirflowNetworkOutdoorAirflow') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkOutdoorAirflow

    __del__ = lambda self: None

OptionalAirflowNetworkOutdoorAirflow_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkOutdoorAirflow_swigregister

OptionalAirflowNetworkOutdoorAirflow_swigregister(OptionalAirflowNetworkOutdoorAirflow)



class AirflowNetworkReferenceCrackConditionsVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkReferenceCrackConditionsVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkReferenceCrackConditionsVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::value_type":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions,std::allocator< openstudio::model::AirflowNetworkReferenceCrackConditions > > *":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkReferenceCrackConditions') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_clear(self)



    def swap(self, v: 'AirflowNetworkReferenceCrackConditionsVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::iterator":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::iterator":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::iterator":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkReferenceCrackConditionsVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkReferenceCrackConditions') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type', x: 'AirflowNetworkReferenceCrackConditions') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type', x: 'AirflowNetworkReferenceCrackConditions') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions >::size_type":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkReferenceCrackConditionsVector

    __del__ = lambda self: None

AirflowNetworkReferenceCrackConditionsVector_swigregister = _openstudiomodelairflow.AirflowNetworkReferenceCrackConditionsVector_swigregister

AirflowNetworkReferenceCrackConditionsVector_swigregister(AirflowNetworkReferenceCrackConditionsVector)



class OptionalAirflowNetworkReferenceCrackConditions(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkReferenceCrackConditions, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkReferenceCrackConditions, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkReferenceCrackConditions(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkReferenceCrackConditions":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkReferenceCrackConditions":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_get(self)



    def set(self, t: 'AirflowNetworkReferenceCrackConditions') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkReferenceCrackConditions

    __del__ = lambda self: None

OptionalAirflowNetworkReferenceCrackConditions_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkReferenceCrackConditions_swigregister

OptionalAirflowNetworkReferenceCrackConditions_swigregister(OptionalAirflowNetworkReferenceCrackConditions)



class AirflowNetworkSimpleOpeningVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkSimpleOpeningVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkSimpleOpeningVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::value_type":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening,std::allocator< openstudio::model::AirflowNetworkSimpleOpening > > *":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkSimpleOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_clear(self)



    def swap(self, v: 'AirflowNetworkSimpleOpeningVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkSimpleOpeningVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkSimpleOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type', x: 'AirflowNetworkSimpleOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type', x: 'AirflowNetworkSimpleOpening') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkSimpleOpeningVector

    __del__ = lambda self: None

AirflowNetworkSimpleOpeningVector_swigregister = _openstudiomodelairflow.AirflowNetworkSimpleOpeningVector_swigregister

AirflowNetworkSimpleOpeningVector_swigregister(AirflowNetworkSimpleOpeningVector)



class OptionalAirflowNetworkSimpleOpening(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkSimpleOpening, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkSimpleOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkSimpleOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkSimpleOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkSimpleOpening":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_get(self)



    def set(self, t: 'AirflowNetworkSimpleOpening') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkSimpleOpening

    __del__ = lambda self: None

OptionalAirflowNetworkSimpleOpening_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkSimpleOpening_swigregister

OptionalAirflowNetworkSimpleOpening_swigregister(OptionalAirflowNetworkSimpleOpening)



class OptionalAirflowNetworkSimulationControl(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkSimulationControl, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkSimulationControl, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkSimulationControl(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkSimulationControl":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkSimulationControl":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_get(self)



    def set(self, t: 'AirflowNetworkSimulationControl') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkSimulationControl

    __del__ = lambda self: None

OptionalAirflowNetworkSimulationControl_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkSimulationControl_swigregister

OptionalAirflowNetworkSimulationControl_swigregister(OptionalAirflowNetworkSimulationControl)



class AirflowNetworkSurfaceVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkSurfaceVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkSurfaceVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::value_type":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkSurface >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkSurface >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkSurface,std::allocator< openstudio::model::AirflowNetworkSurface > > *":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkSurface >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkSurface >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkSurface >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkSurface') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_clear(self)



    def swap(self, v: 'AirflowNetworkSurfaceVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkSurface >::iterator":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkSurfaceVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkSurface') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkSurface >::size_type', x: 'AirflowNetworkSurface') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkSurface >::size_type', x: 'AirflowNetworkSurface') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkSurface >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkSurface >::size_type":

        return _openstudiomodelairflow.AirflowNetworkSurfaceVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkSurfaceVector

    __del__ = lambda self: None

AirflowNetworkSurfaceVector_swigregister = _openstudiomodelairflow.AirflowNetworkSurfaceVector_swigregister

AirflowNetworkSurfaceVector_swigregister(AirflowNetworkSurfaceVector)



class OptionalAirflowNetworkSurface(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkSurface, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkSurface, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkSurface(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkSurface":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkSurface":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface_get(self)



    def set(self, t: 'AirflowNetworkSurface') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkSurface_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkSurface

    __del__ = lambda self: None

OptionalAirflowNetworkSurface_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkSurface_swigregister

OptionalAirflowNetworkSurface_swigregister(OptionalAirflowNetworkSurface)



class AirflowNetworkZoneVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkZoneVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkZoneVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::value_type":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkZone >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkZone >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkZone,std::allocator< openstudio::model::AirflowNetworkZone > > *":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkZone >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkZone >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkZone >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkZone') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_clear(self)



    def swap(self, v: 'AirflowNetworkZoneVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkZone >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkZoneVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkZone') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkZone >::size_type', x: 'AirflowNetworkZone') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkZone >::size_type', x: 'AirflowNetworkZone') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkZone >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkZone >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkZoneVector

    __del__ = lambda self: None

AirflowNetworkZoneVector_swigregister = _openstudiomodelairflow.AirflowNetworkZoneVector_swigregister

AirflowNetworkZoneVector_swigregister(AirflowNetworkZoneVector)



class OptionalAirflowNetworkZone(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkZone, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkZone, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkZone(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkZone":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkZone":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone_get(self)



    def set(self, t: 'AirflowNetworkZone') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkZone_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkZone

    __del__ = lambda self: None

OptionalAirflowNetworkZone_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkZone_swigregister

OptionalAirflowNetworkZone_swigregister(OptionalAirflowNetworkZone)



class AirflowNetworkZoneExhaustFanVector(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkZoneExhaustFanVector, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkZoneExhaustFanVector, name)

    __repr__ = _swig_repr



    def iterator(self) -> "swig::SwigPyIterator *":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_iterator(self)

    def __iter__(self):

        return self.iterator()



    def __nonzero__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___nonzero__(self)



    def __bool__(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___bool__(self)



    def __len__(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___len__(self)



    def pop(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::value_type":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_pop(self)



    def __getslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::difference_type') -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan,std::allocator< openstudio::model::AirflowNetworkZoneExhaustFan > > *":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___getslice__(self, i, j)



    def __setslice__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___setslice__(self, *args)



    def __delslice__(self, i: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::difference_type', j: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::difference_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___delslice__(self, i, j)



    def __delitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___delitem__(self, *args)



    def __getitem__(self, *args) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___getitem__(self, *args)



    def __setitem__(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector___setitem__(self, *args)



    def append(self, x: 'AirflowNetworkZoneExhaustFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_append(self, x)



    def empty(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_empty(self)



    def size(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_size(self)



    def clear(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_clear(self)



    def swap(self, v: 'AirflowNetworkZoneExhaustFanVector') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_swap(self, v)



    def get_allocator(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::allocator_type":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_get_allocator(self)



    def begin(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_begin(self)



    def end(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_end(self)



    def rbegin(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_rbegin(self)



    def rend(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::reverse_iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_rend(self)



    def pop_back(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_pop_back(self)



    def erase(self, *args) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::iterator":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_erase(self, *args)



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkZoneExhaustFanVector(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def push_back(self, x: 'AirflowNetworkZoneExhaustFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_push_back(self, x)



    def front(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_front(self)



    def back(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::value_type const &":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_back(self)



    def assign(self, n: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type', x: 'AirflowNetworkZoneExhaustFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_assign(self, n, x)



    def resize(self, new_size: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type', x: 'AirflowNetworkZoneExhaustFan') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_resize(self, new_size, x)



    def insert(self, *args) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_insert(self, *args)



    def reserve(self, n: 'std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type') -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_reserve(self, n)



    def capacity(self) -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan >::size_type":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_capacity(self)

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkZoneExhaustFanVector

    __del__ = lambda self: None

AirflowNetworkZoneExhaustFanVector_swigregister = _openstudiomodelairflow.AirflowNetworkZoneExhaustFanVector_swigregister

AirflowNetworkZoneExhaustFanVector_swigregister(AirflowNetworkZoneExhaustFanVector)



class OptionalAirflowNetworkZoneExhaustFan(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, OptionalAirflowNetworkZoneExhaustFan, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, OptionalAirflowNetworkZoneExhaustFan, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_OptionalAirflowNetworkZoneExhaustFan(*args)

        try:

            self.this.append(this)

        except:

            self.this = this



    def reset(self) -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_reset(self)



    def __ref__(self) -> "openstudio::model::AirflowNetworkZoneExhaustFan":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan___ref__(self)



    def is_initialized(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_is_initialized(self)



    def isNull(self) -> "bool":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_isNull(self)



    def get(self) -> "openstudio::model::AirflowNetworkZoneExhaustFan":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_get(self)



    def set(self, t: 'AirflowNetworkZoneExhaustFan') -> "void":

        return _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_set(self, t)

    __swig_destroy__ = _openstudiomodelairflow.delete_OptionalAirflowNetworkZoneExhaustFan

    __del__ = lambda self: None

OptionalAirflowNetworkZoneExhaustFan_swigregister = _openstudiomodelairflow.OptionalAirflowNetworkZoneExhaustFan_swigregister

OptionalAirflowNetworkZoneExhaustFan_swigregister(OptionalAirflowNetworkZoneExhaustFan)



class AirflowNetworkConstantPressureDrop(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkConstantPressureDrop, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkConstantPressureDrop, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model', pressureDrop: 'double'):

        this = _openstudiomodelairflow.new_AirflowNetworkConstantPressureDrop(model, pressureDrop)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkConstantPressureDrop

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkConstantPressureDrop_iddObjectType)



    def pressureDrop(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_pressureDrop(self)



    def setPressureDrop(self, pressureDrop: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_setPressureDrop(self, pressureDrop)

AirflowNetworkConstantPressureDrop_swigregister = _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_swigregister

AirflowNetworkConstantPressureDrop_swigregister(AirflowNetworkConstantPressureDrop)



def AirflowNetworkConstantPressureDrop_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_iddObjectType()

AirflowNetworkConstantPressureDrop_iddObjectType = _openstudiomodelairflow.AirflowNetworkConstantPressureDrop_iddObjectType





def toAirflowNetworkConstantPressureDrop(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkConstantPressureDrop >":

    return _openstudiomodelairflow.toAirflowNetworkConstantPressureDrop(idfObject)

toAirflowNetworkConstantPressureDrop = _openstudiomodelairflow.toAirflowNetworkConstantPressureDrop



def getAirflowNetworkConstantPressureDrop(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkConstantPressureDrop >":

    return _openstudiomodelairflow.getAirflowNetworkConstantPressureDrop(t_model, t_handle)

getAirflowNetworkConstantPressureDrop = _openstudiomodelairflow.getAirflowNetworkConstantPressureDrop



def getAirflowNetworkConstantPressureDrops(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop,std::allocator< openstudio::model::AirflowNetworkConstantPressureDrop > >":

    return _openstudiomodelairflow.getAirflowNetworkConstantPressureDrops(t_model)

getAirflowNetworkConstantPressureDrops = _openstudiomodelairflow.getAirflowNetworkConstantPressureDrops



def getAirflowNetworkConstantPressureDropByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkConstantPressureDrop >":

    return _openstudiomodelairflow.getAirflowNetworkConstantPressureDropByName(t_model, t_name)

getAirflowNetworkConstantPressureDropByName = _openstudiomodelairflow.getAirflowNetworkConstantPressureDropByName



def getAirflowNetworkConstantPressureDropsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkConstantPressureDrop,std::allocator< openstudio::model::AirflowNetworkConstantPressureDrop > >":

    return _openstudiomodelairflow.getAirflowNetworkConstantPressureDropsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkConstantPressureDropsByName = _openstudiomodelairflow.getAirflowNetworkConstantPressureDropsByName

class AirflowNetworkCrack(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkCrack, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkCrack, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkCrack(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkCrack

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkCrack_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkCrack_iddObjectType)



    def airMassFlowCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkCrack_airMassFlowCoefficient(self)



    def airMassFlowExponent(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkCrack_airMassFlowExponent(self)



    def isAirMassFlowExponentDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrack_isAirMassFlowExponentDefaulted(self)



    def referenceCrackConditions(self) -> "boost::optional< openstudio::model::AirflowNetworkReferenceCrackConditions >":

        return _openstudiomodelairflow.AirflowNetworkCrack_referenceCrackConditions(self)



    def setAirMassFlowCoefficient(self, airMassFlowCoefficientatReferenceConditions: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrack_setAirMassFlowCoefficient(self, airMassFlowCoefficientatReferenceConditions)



    def setAirMassFlowExponent(self, airMassFlowExponent: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrack_setAirMassFlowExponent(self, airMassFlowExponent)



    def resetAirMassFlowExponent(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrack_resetAirMassFlowExponent(self)



    def setReferenceCrackConditions(self, referenceCrackConditions: 'AirflowNetworkReferenceCrackConditions') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkCrack_setReferenceCrackConditions(self, referenceCrackConditions)



    def resetReferenceCrackConditions(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkCrack_resetReferenceCrackConditions(self)

AirflowNetworkCrack_swigregister = _openstudiomodelairflow.AirflowNetworkCrack_swigregister

AirflowNetworkCrack_swigregister(AirflowNetworkCrack)



def AirflowNetworkCrack_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkCrack_iddObjectType()

AirflowNetworkCrack_iddObjectType = _openstudiomodelairflow.AirflowNetworkCrack_iddObjectType





def toAirflowNetworkCrack(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkCrack >":

    return _openstudiomodelairflow.toAirflowNetworkCrack(idfObject)

toAirflowNetworkCrack = _openstudiomodelairflow.toAirflowNetworkCrack



def getAirflowNetworkCrack(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkCrack >":

    return _openstudiomodelairflow.getAirflowNetworkCrack(t_model, t_handle)

getAirflowNetworkCrack = _openstudiomodelairflow.getAirflowNetworkCrack



def getAirflowNetworkCracks(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkCrack,std::allocator< openstudio::model::AirflowNetworkCrack > >":

    return _openstudiomodelairflow.getAirflowNetworkCracks(t_model)

getAirflowNetworkCracks = _openstudiomodelairflow.getAirflowNetworkCracks



def getAirflowNetworkCrackByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkCrack >":

    return _openstudiomodelairflow.getAirflowNetworkCrackByName(t_model, t_name)

getAirflowNetworkCrackByName = _openstudiomodelairflow.getAirflowNetworkCrackByName



def getAirflowNetworkCracksByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkCrack,std::allocator< openstudio::model::AirflowNetworkCrack > >":

    return _openstudiomodelairflow.getAirflowNetworkCracksByName(t_model, t_name, t_exactMatch)

getAirflowNetworkCracksByName = _openstudiomodelairflow.getAirflowNetworkCracksByName

class DetailedOpeningFactorData(_object):

    __swig_setmethods__ = {}

    __setattr__ = lambda self, name, value: _swig_setattr(self, DetailedOpeningFactorData, name, value)

    __swig_getmethods__ = {}

    __getattr__ = lambda self, name: _swig_getattr(self, DetailedOpeningFactorData, name)

    __repr__ = _swig_repr



    def __init__(self, openingFactor: 'double', dischargeCoefficient: 'double', widthFactor: 'double', heightFactor: 'double', startHeightFactor: 'double'):

        this = _openstudiomodelairflow.new_DetailedOpeningFactorData(openingFactor, dischargeCoefficient, widthFactor, heightFactor, startHeightFactor)

        try:

            self.this.append(this)

        except:

            self.this = this



    def openingFactor(self) -> "double":

        return _openstudiomodelairflow.DetailedOpeningFactorData_openingFactor(self)



    def dischargeCoefficient(self) -> "double":

        return _openstudiomodelairflow.DetailedOpeningFactorData_dischargeCoefficient(self)



    def widthFactor(self) -> "double":

        return _openstudiomodelairflow.DetailedOpeningFactorData_widthFactor(self)



    def heightFactor(self) -> "double":

        return _openstudiomodelairflow.DetailedOpeningFactorData_heightFactor(self)



    def startHeightFactor(self) -> "double":

        return _openstudiomodelairflow.DetailedOpeningFactorData_startHeightFactor(self)



    def setOpeningFactor(self, openingFactor: 'double') -> "bool":

        return _openstudiomodelairflow.DetailedOpeningFactorData_setOpeningFactor(self, openingFactor)



    def setDischargeCoefficient(self, dischargeCoefficient: 'double') -> "bool":

        return _openstudiomodelairflow.DetailedOpeningFactorData_setDischargeCoefficient(self, dischargeCoefficient)



    def setWidthFactor(self, widthFactor: 'double') -> "bool":

        return _openstudiomodelairflow.DetailedOpeningFactorData_setWidthFactor(self, widthFactor)



    def setHeightFactor(self, heightFactor: 'double') -> "bool":

        return _openstudiomodelairflow.DetailedOpeningFactorData_setHeightFactor(self, heightFactor)



    def setStartHeightFactor(self, startHeightFactor: 'double') -> "bool":

        return _openstudiomodelairflow.DetailedOpeningFactorData_setStartHeightFactor(self, startHeightFactor)

    __swig_destroy__ = _openstudiomodelairflow.delete_DetailedOpeningFactorData

    __del__ = lambda self: None

DetailedOpeningFactorData_swigregister = _openstudiomodelairflow.DetailedOpeningFactorData_swigregister

DetailedOpeningFactorData_swigregister(DetailedOpeningFactorData)



class AirflowNetworkDetailedOpening(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDetailedOpening, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDetailedOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkDetailedOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDetailedOpening

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkDetailedOpening_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkDetailedOpening_iddObjectType)

    __swig_getmethods__["typeofRectangularLargeVerticalOpeningValues"] = lambda x: _openstudiomodelairflow.AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues

    if _newclass:

        typeofRectangularLargeVerticalOpeningValues = staticmethod(_openstudiomodelairflow.AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues)



    def airMassFlowCoefficientWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_airMassFlowCoefficientWhenOpeningisClosed(self)



    def airMassFlowExponentWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_airMassFlowExponentWhenOpeningisClosed(self)



    def isAirMassFlowExponentWhenOpeningisClosedDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_isAirMassFlowExponentWhenOpeningisClosedDefaulted(self)



    def typeofRectangularLargeVerticalOpening(self) -> "std::string":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpening(self)



    def isTypeofRectangularLargeVerticalOpeningDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_isTypeofRectangularLargeVerticalOpeningDefaulted(self)



    def extraCrackLengthorHeightofPivotingAxis(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_extraCrackLengthorHeightofPivotingAxis(self)



    def isExtraCrackLengthorHeightofPivotingAxisDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_isExtraCrackLengthorHeightofPivotingAxisDefaulted(self)



    def openingFactors(self) -> "std::vector< openstudio::model::DetailedOpeningFactorData,std::allocator< openstudio::model::DetailedOpeningFactorData > >":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_openingFactors(self)



    def setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed)



    def setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed)



    def resetAirMassFlowExponentWhenOpeningisClosed(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_resetAirMassFlowExponentWhenOpeningisClosed(self)



    def setTypeofRectangularLargeVerticalOpening(self, typeofRectangularLargeVerticalOpening: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_setTypeofRectangularLargeVerticalOpening(self, typeofRectangularLargeVerticalOpening)



    def resetTypeofRectangularLargeVerticalOpening(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_resetTypeofRectangularLargeVerticalOpening(self)



    def setExtraCrackLengthorHeightofPivotingAxis(self, extraCrackLengthorHeightofPivotingAxis: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_setExtraCrackLengthorHeightofPivotingAxis(self, extraCrackLengthorHeightofPivotingAxis)



    def resetExtraCrackLengthorHeightofPivotingAxis(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_resetExtraCrackLengthorHeightofPivotingAxis(self)



    def setOpeningFactors(self, factors: 'std::vector< openstudio::model::DetailedOpeningFactorData,std::allocator< openstudio::model::DetailedOpeningFactorData > > &') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDetailedOpening_setOpeningFactors(self, factors)

AirflowNetworkDetailedOpening_swigregister = _openstudiomodelairflow.AirflowNetworkDetailedOpening_swigregister

AirflowNetworkDetailedOpening_swigregister(AirflowNetworkDetailedOpening)



def AirflowNetworkDetailedOpening_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkDetailedOpening_iddObjectType()

AirflowNetworkDetailedOpening_iddObjectType = _openstudiomodelairflow.AirflowNetworkDetailedOpening_iddObjectType



def AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues() -> "std::vector< std::string,std::allocator< std::string > >":

    return _openstudiomodelairflow.AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues()

AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues = _openstudiomodelairflow.AirflowNetworkDetailedOpening_typeofRectangularLargeVerticalOpeningValues





def toAirflowNetworkDetailedOpening(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkDetailedOpening >":

    return _openstudiomodelairflow.toAirflowNetworkDetailedOpening(idfObject)

toAirflowNetworkDetailedOpening = _openstudiomodelairflow.toAirflowNetworkDetailedOpening



def getAirflowNetworkDetailedOpening(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkDetailedOpening >":

    return _openstudiomodelairflow.getAirflowNetworkDetailedOpening(t_model, t_handle)

getAirflowNetworkDetailedOpening = _openstudiomodelairflow.getAirflowNetworkDetailedOpening



def getAirflowNetworkDetailedOpenings(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening,std::allocator< openstudio::model::AirflowNetworkDetailedOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkDetailedOpenings(t_model)

getAirflowNetworkDetailedOpenings = _openstudiomodelairflow.getAirflowNetworkDetailedOpenings



def getAirflowNetworkDetailedOpeningByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkDetailedOpening >":

    return _openstudiomodelairflow.getAirflowNetworkDetailedOpeningByName(t_model, t_name)

getAirflowNetworkDetailedOpeningByName = _openstudiomodelairflow.getAirflowNetworkDetailedOpeningByName



def getAirflowNetworkDetailedOpeningsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkDetailedOpening,std::allocator< openstudio::model::AirflowNetworkDetailedOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkDetailedOpeningsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkDetailedOpeningsByName = _openstudiomodelairflow.getAirflowNetworkDetailedOpeningsByName

class AirflowNetworkDistributionLinkage(AirflowNetworkLinkage):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkLinkage]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDistributionLinkage, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkLinkage]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDistributionLinkage, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model', node1: 'AirflowNetworkNode', node2: 'AirflowNetworkNode', component: 'AirflowNetworkComponent'):

        this = _openstudiomodelairflow.new_AirflowNetworkDistributionLinkage(model, node1, node2, component)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDistributionLinkage

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkDistributionLinkage_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkDistributionLinkage_iddObjectType)



    def node1(self) -> "openstudio::model::AirflowNetworkNode":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_node1(self)



    def node2(self) -> "openstudio::model::AirflowNetworkNode":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_node2(self)



    def component(self) -> "openstudio::model::AirflowNetworkComponent":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_component(self)



    def thermalZone(self) -> "boost::optional< openstudio::model::ThermalZone >":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_thermalZone(self)



    def setNode1(self, airflowNetworkNodeAndZone: 'AirflowNetworkNode') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_setNode1(self, airflowNetworkNodeAndZone)



    def setNode2(self, airflowNetworkNodeAndZone: 'AirflowNetworkNode') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_setNode2(self, airflowNetworkNodeAndZone)



    def setComponent(self, airflowNetworkComponent: 'AirflowNetworkComponent') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_setComponent(self, airflowNetworkComponent)



    def setThermalZone(self, zone: 'ThermalZone') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_setThermalZone(self, zone)



    def resetThermalZone(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_resetThermalZone(self)

AirflowNetworkDistributionLinkage_swigregister = _openstudiomodelairflow.AirflowNetworkDistributionLinkage_swigregister

AirflowNetworkDistributionLinkage_swigregister(AirflowNetworkDistributionLinkage)



def AirflowNetworkDistributionLinkage_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkDistributionLinkage_iddObjectType()

AirflowNetworkDistributionLinkage_iddObjectType = _openstudiomodelairflow.AirflowNetworkDistributionLinkage_iddObjectType





def toAirflowNetworkDistributionLinkage(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkDistributionLinkage >":

    return _openstudiomodelairflow.toAirflowNetworkDistributionLinkage(idfObject)

toAirflowNetworkDistributionLinkage = _openstudiomodelairflow.toAirflowNetworkDistributionLinkage



def getAirflowNetworkDistributionLinkage(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkDistributionLinkage >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionLinkage(t_model, t_handle)

getAirflowNetworkDistributionLinkage = _openstudiomodelairflow.getAirflowNetworkDistributionLinkage



def getAirflowNetworkDistributionLinkages(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage,std::allocator< openstudio::model::AirflowNetworkDistributionLinkage > >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionLinkages(t_model)

getAirflowNetworkDistributionLinkages = _openstudiomodelairflow.getAirflowNetworkDistributionLinkages



def getAirflowNetworkDistributionLinkageByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkDistributionLinkage >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionLinkageByName(t_model, t_name)

getAirflowNetworkDistributionLinkageByName = _openstudiomodelairflow.getAirflowNetworkDistributionLinkageByName



def getAirflowNetworkDistributionLinkagesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkDistributionLinkage,std::allocator< openstudio::model::AirflowNetworkDistributionLinkage > >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionLinkagesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkDistributionLinkagesByName = _openstudiomodelairflow.getAirflowNetworkDistributionLinkagesByName

class AirflowNetworkDistributionNode(AirflowNetworkNode):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDistributionNode, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDistributionNode, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkDistributionNode(model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDistributionNode

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkDistributionNode_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkDistributionNode_iddObjectType)



    def node(self) -> "boost::optional< openstudio::model::Node >":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_node(self)



    def airLoopHVACZoneMixer(self) -> "boost::optional< openstudio::model::AirLoopHVACZoneMixer >":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_airLoopHVACZoneMixer(self)



    def airLoopHVACZoneSplitter(self) -> "boost::optional< openstudio::model::AirLoopHVACZoneSplitter >":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_airLoopHVACZoneSplitter(self)



    def airLoopHVACOutdoorAirSystem(self) -> "boost::optional< openstudio::model::AirLoopHVACOutdoorAirSystem >":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_airLoopHVACOutdoorAirSystem(self)



    def nodeHeight(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_nodeHeight(self)



    def isNodeHeightDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_isNodeHeightDefaulted(self)



    def setNodeHeight(self, nodeHeight: 'double') -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_setNodeHeight(self, nodeHeight)



    def resetNodeHeight(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDistributionNode_resetNodeHeight(self)

AirflowNetworkDistributionNode_swigregister = _openstudiomodelairflow.AirflowNetworkDistributionNode_swigregister

AirflowNetworkDistributionNode_swigregister(AirflowNetworkDistributionNode)



def AirflowNetworkDistributionNode_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkDistributionNode_iddObjectType()

AirflowNetworkDistributionNode_iddObjectType = _openstudiomodelairflow.AirflowNetworkDistributionNode_iddObjectType





def toAirflowNetworkDistributionNode(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkDistributionNode >":

    return _openstudiomodelairflow.toAirflowNetworkDistributionNode(idfObject)

toAirflowNetworkDistributionNode = _openstudiomodelairflow.toAirflowNetworkDistributionNode



def getAirflowNetworkDistributionNode(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkDistributionNode >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionNode(t_model, t_handle)

getAirflowNetworkDistributionNode = _openstudiomodelairflow.getAirflowNetworkDistributionNode



def getAirflowNetworkDistributionNodes(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkDistributionNode,std::allocator< openstudio::model::AirflowNetworkDistributionNode > >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionNodes(t_model)

getAirflowNetworkDistributionNodes = _openstudiomodelairflow.getAirflowNetworkDistributionNodes



def getAirflowNetworkDistributionNodeByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkDistributionNode >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionNodeByName(t_model, t_name)

getAirflowNetworkDistributionNodeByName = _openstudiomodelairflow.getAirflowNetworkDistributionNodeByName



def getAirflowNetworkDistributionNodesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkDistributionNode,std::allocator< openstudio::model::AirflowNetworkDistributionNode > >":

    return _openstudiomodelairflow.getAirflowNetworkDistributionNodesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkDistributionNodesByName = _openstudiomodelairflow.getAirflowNetworkDistributionNodesByName

class AirflowNetworkDuct(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDuct, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDuct, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkDuct(model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDuct

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkDuct_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkDuct_iddObjectType)



    def ductLength(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_ductLength(self)



    def hydraulicDiameter(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_hydraulicDiameter(self)



    def crossSectionArea(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_crossSectionArea(self)



    def surfaceRoughness(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_surfaceRoughness(self)



    def isSurfaceRoughnessDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isSurfaceRoughnessDefaulted(self)



    def coefficientforLocalDynamicLossDuetoFitting(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_coefficientforLocalDynamicLossDuetoFitting(self)



    def isCoefficientforLocalDynamicLossDuetoFittingDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isCoefficientforLocalDynamicLossDuetoFittingDefaulted(self)



    def ductWallHeatTransmittanceCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_ductWallHeatTransmittanceCoefficient(self)



    def isDuctWallHeatTransmittanceCoefficientDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isDuctWallHeatTransmittanceCoefficientDefaulted(self)



    def insideConvectionCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_insideConvectionCoefficient(self)



    def isInsideConvectionCoefficientDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isInsideConvectionCoefficientDefaulted(self)



    def outsideConvectionCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_outsideConvectionCoefficient(self)



    def isOutsideConvectionCoefficientDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isOutsideConvectionCoefficientDefaulted(self)



    def overallMoistureTransmittanceCoefficientfromAirtoAir(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuct_overallMoistureTransmittanceCoefficientfromAirtoAir(self)



    def isOverallMoistureTransmittanceCoefficientfromAirtoAirDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_isOverallMoistureTransmittanceCoefficientfromAirtoAirDefaulted(self)



    def setDuctLength(self, ductLength: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setDuctLength(self, ductLength)



    def setHydraulicDiameter(self, hydraulicDiameter: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setHydraulicDiameter(self, hydraulicDiameter)



    def setCrossSectionArea(self, crossSectionArea: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setCrossSectionArea(self, crossSectionArea)



    def setSurfaceRoughness(self, surfaceRoughness: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setSurfaceRoughness(self, surfaceRoughness)



    def resetSurfaceRoughness(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetSurfaceRoughness(self)



    def setCoefficientforLocalDynamicLossDuetoFitting(self, coefficientforLocalDynamicLossDuetoFitting: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setCoefficientforLocalDynamicLossDuetoFitting(self, coefficientforLocalDynamicLossDuetoFitting)



    def resetCoefficientforLocalDynamicLossDuetoFitting(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetCoefficientforLocalDynamicLossDuetoFitting(self)



    def setDuctWallHeatTransmittanceCoefficient(self, coefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setDuctWallHeatTransmittanceCoefficient(self, coefficient)



    def resetDuctWallHeatTransmittanceCoefficient(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetDuctWallHeatTransmittanceCoefficient(self)



    def setInsideConvectionCoefficient(self, coefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setInsideConvectionCoefficient(self, coefficient)



    def resetInsideConvectionCoefficient(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetInsideConvectionCoefficient(self)



    def setOutsideConvectionCoefficient(self, coefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setOutsideConvectionCoefficient(self, coefficient)



    def resetOutsideConvectionCoefficient(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetOutsideConvectionCoefficient(self)



    def setOverallMoistureTransmittanceCoefficientfromAirtoAir(self, overallMoistureTransmittanceCoefficientfromAirtoAir: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuct_setOverallMoistureTransmittanceCoefficientfromAirtoAir(self, overallMoistureTransmittanceCoefficientfromAirtoAir)



    def resetOverallMoistureTransmittanceCoefficientfromAirtoAir(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuct_resetOverallMoistureTransmittanceCoefficientfromAirtoAir(self)

AirflowNetworkDuct_swigregister = _openstudiomodelairflow.AirflowNetworkDuct_swigregister

AirflowNetworkDuct_swigregister(AirflowNetworkDuct)



def AirflowNetworkDuct_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkDuct_iddObjectType()

AirflowNetworkDuct_iddObjectType = _openstudiomodelairflow.AirflowNetworkDuct_iddObjectType





def toAirflowNetworkDuct(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkDuct >":

    return _openstudiomodelairflow.toAirflowNetworkDuct(idfObject)

toAirflowNetworkDuct = _openstudiomodelairflow.toAirflowNetworkDuct



def getAirflowNetworkDuct(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkDuct >":

    return _openstudiomodelairflow.getAirflowNetworkDuct(t_model, t_handle)

getAirflowNetworkDuct = _openstudiomodelairflow.getAirflowNetworkDuct



def getAirflowNetworkDucts(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkDuct,std::allocator< openstudio::model::AirflowNetworkDuct > >":

    return _openstudiomodelairflow.getAirflowNetworkDucts(t_model)

getAirflowNetworkDucts = _openstudiomodelairflow.getAirflowNetworkDucts



def getAirflowNetworkDuctByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkDuct >":

    return _openstudiomodelairflow.getAirflowNetworkDuctByName(t_model, t_name)

getAirflowNetworkDuctByName = _openstudiomodelairflow.getAirflowNetworkDuctByName



def getAirflowNetworkDuctsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkDuct,std::allocator< openstudio::model::AirflowNetworkDuct > >":

    return _openstudiomodelairflow.getAirflowNetworkDuctsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkDuctsByName = _openstudiomodelairflow.getAirflowNetworkDuctsByName

class AirflowNetworkDuctViewFactors(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkDuctViewFactors, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkDuctViewFactors, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkDuctViewFactors(model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkDuctViewFactors

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkDuctViewFactors_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkDuctViewFactors_iddObjectType)



    def linkage(self) -> "openstudio::model::AirflowNetworkLinkage":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_linkage(self)



    def ductSurfaceExposureFraction(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_ductSurfaceExposureFraction(self)



    def isDuctSurfaceExposureFractionDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_isDuctSurfaceExposureFractionDefaulted(self)



    def ductSurfaceEmittance(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_ductSurfaceEmittance(self)



    def isDuctSurfaceEmittanceDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_isDuctSurfaceEmittanceDefaulted(self)



    def getViewFactor(self, surf: 'PlanarSurface') -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_getViewFactor(self, surf)



    def viewFactors(self) -> "std::vector< std::pair< openstudio::model::PlanarSurface,double >,std::allocator< std::pair< openstudio::model::PlanarSurface,double > > >":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_viewFactors(self)



    def setLinkage(self, linkage: 'AirflowNetworkLinkage') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_setLinkage(self, linkage)



    def setDuctSurfaceExposureFraction(self, ductSurfaceExposureFraction: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_setDuctSurfaceExposureFraction(self, ductSurfaceExposureFraction)



    def resetDuctSurfaceExposureFraction(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_resetDuctSurfaceExposureFraction(self)



    def setDuctSurfaceEmittance(self, ductSurfaceEmittance: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_setDuctSurfaceEmittance(self, ductSurfaceEmittance)



    def resetDuctSurfaceEmittance(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_resetDuctSurfaceEmittance(self)



    def setViewFactor(self, surf: 'PlanarSurface', F: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_setViewFactor(self, surf, F)



    def removeViewFactor(self, surf: 'PlanarSurface') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_removeViewFactor(self, surf)



    def resetViewFactors(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_resetViewFactors(self)

AirflowNetworkDuctViewFactors_swigregister = _openstudiomodelairflow.AirflowNetworkDuctViewFactors_swigregister

AirflowNetworkDuctViewFactors_swigregister(AirflowNetworkDuctViewFactors)



def AirflowNetworkDuctViewFactors_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkDuctViewFactors_iddObjectType()

AirflowNetworkDuctViewFactors_iddObjectType = _openstudiomodelairflow.AirflowNetworkDuctViewFactors_iddObjectType





def toAirflowNetworkDuctViewFactors(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkDuctViewFactors >":

    return _openstudiomodelairflow.toAirflowNetworkDuctViewFactors(idfObject)

toAirflowNetworkDuctViewFactors = _openstudiomodelairflow.toAirflowNetworkDuctViewFactors



def getAirflowNetworkDuctViewFactors(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkDuctViewFactors >":

    return _openstudiomodelairflow.getAirflowNetworkDuctViewFactors(t_model, t_handle)

getAirflowNetworkDuctViewFactors = _openstudiomodelairflow.getAirflowNetworkDuctViewFactors



def getAirflowNetworkDuctViewFactorss(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors,std::allocator< openstudio::model::AirflowNetworkDuctViewFactors > >":

    return _openstudiomodelairflow.getAirflowNetworkDuctViewFactorss(t_model)

getAirflowNetworkDuctViewFactorss = _openstudiomodelairflow.getAirflowNetworkDuctViewFactorss



def getAirflowNetworkDuctViewFactorsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkDuctViewFactors >":

    return _openstudiomodelairflow.getAirflowNetworkDuctViewFactorsByName(t_model, t_name)

getAirflowNetworkDuctViewFactorsByName = _openstudiomodelairflow.getAirflowNetworkDuctViewFactorsByName



def getAirflowNetworkDuctViewFactorssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkDuctViewFactors,std::allocator< openstudio::model::AirflowNetworkDuctViewFactors > >":

    return _openstudiomodelairflow.getAirflowNetworkDuctViewFactorssByName(t_model, t_name, t_exactMatch)

getAirflowNetworkDuctViewFactorssByName = _openstudiomodelairflow.getAirflowNetworkDuctViewFactorssByName

class AirflowNetworkEffectiveLeakageArea(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkEffectiveLeakageArea, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkEffectiveLeakageArea, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkEffectiveLeakageArea(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkEffectiveLeakageArea

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_iddObjectType)



    def effectiveLeakageArea(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_effectiveLeakageArea(self)



    def dischargeCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_dischargeCoefficient(self)



    def isDischargeCoefficientDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_isDischargeCoefficientDefaulted(self)



    def referencePressureDifference(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_referencePressureDifference(self)



    def isReferencePressureDifferenceDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_isReferencePressureDifferenceDefaulted(self)



    def airMassFlowExponent(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_airMassFlowExponent(self)



    def isAirMassFlowExponentDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_isAirMassFlowExponentDefaulted(self)



    def setEffectiveLeakageArea(self, effectiveLeakageArea: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_setEffectiveLeakageArea(self, effectiveLeakageArea)



    def setDischargeCoefficient(self, dischargeCoefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_setDischargeCoefficient(self, dischargeCoefficient)



    def resetDischargeCoefficient(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_resetDischargeCoefficient(self)



    def setReferencePressureDifference(self, referencePressureDifference: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_setReferencePressureDifference(self, referencePressureDifference)



    def resetReferencePressureDifference(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_resetReferencePressureDifference(self)



    def setAirMassFlowExponent(self, airMassFlowExponent: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_setAirMassFlowExponent(self, airMassFlowExponent)



    def resetAirMassFlowExponent(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_resetAirMassFlowExponent(self)

AirflowNetworkEffectiveLeakageArea_swigregister = _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_swigregister

AirflowNetworkEffectiveLeakageArea_swigregister(AirflowNetworkEffectiveLeakageArea)



def AirflowNetworkEffectiveLeakageArea_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_iddObjectType()

AirflowNetworkEffectiveLeakageArea_iddObjectType = _openstudiomodelairflow.AirflowNetworkEffectiveLeakageArea_iddObjectType





def toAirflowNetworkEffectiveLeakageArea(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkEffectiveLeakageArea >":

    return _openstudiomodelairflow.toAirflowNetworkEffectiveLeakageArea(idfObject)

toAirflowNetworkEffectiveLeakageArea = _openstudiomodelairflow.toAirflowNetworkEffectiveLeakageArea



def getAirflowNetworkEffectiveLeakageArea(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkEffectiveLeakageArea >":

    return _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageArea(t_model, t_handle)

getAirflowNetworkEffectiveLeakageArea = _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageArea



def getAirflowNetworkEffectiveLeakageAreas(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea,std::allocator< openstudio::model::AirflowNetworkEffectiveLeakageArea > >":

    return _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreas(t_model)

getAirflowNetworkEffectiveLeakageAreas = _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreas



def getAirflowNetworkEffectiveLeakageAreaByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkEffectiveLeakageArea >":

    return _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreaByName(t_model, t_name)

getAirflowNetworkEffectiveLeakageAreaByName = _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreaByName



def getAirflowNetworkEffectiveLeakageAreasByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkEffectiveLeakageArea,std::allocator< openstudio::model::AirflowNetworkEffectiveLeakageArea > >":

    return _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreasByName(t_model, t_name, t_exactMatch)

getAirflowNetworkEffectiveLeakageAreasByName = _openstudiomodelairflow.getAirflowNetworkEffectiveLeakageAreasByName

class AirflowNetworkEquivalentDuct(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkEquivalentDuct, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkEquivalentDuct, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkEquivalentDuct

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkEquivalentDuct_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkEquivalentDuct_iddObjectType)



    def straightComponent(self) -> "boost::optional< openstudio::model::StraightComponent >":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_straightComponent(self)



    def coilObjectType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_coilObjectType(self)



    def heatExchangerObjectType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_heatExchangerObjectType(self)



    def terminalUnitObjectType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_terminalUnitObjectType(self)



    def airPathLength(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_airPathLength(self)



    def airPathHydraulicDiameter(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_airPathHydraulicDiameter(self)



    def setAirPathLength(self, airPathLength: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_setAirPathLength(self, airPathLength)



    def setAirPathHydraulicDiameter(self, airPathHydraulicDiameter: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_setAirPathHydraulicDiameter(self, airPathHydraulicDiameter)

AirflowNetworkEquivalentDuct_swigregister = _openstudiomodelairflow.AirflowNetworkEquivalentDuct_swigregister

AirflowNetworkEquivalentDuct_swigregister(AirflowNetworkEquivalentDuct)



def AirflowNetworkEquivalentDuct_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkEquivalentDuct_iddObjectType()

AirflowNetworkEquivalentDuct_iddObjectType = _openstudiomodelairflow.AirflowNetworkEquivalentDuct_iddObjectType





def toAirflowNetworkEquivalentDuct(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkEquivalentDuct >":

    return _openstudiomodelairflow.toAirflowNetworkEquivalentDuct(idfObject)

toAirflowNetworkEquivalentDuct = _openstudiomodelairflow.toAirflowNetworkEquivalentDuct



def getAirflowNetworkEquivalentDuct(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkEquivalentDuct >":

    return _openstudiomodelairflow.getAirflowNetworkEquivalentDuct(t_model, t_handle)

getAirflowNetworkEquivalentDuct = _openstudiomodelairflow.getAirflowNetworkEquivalentDuct



def getAirflowNetworkEquivalentDucts(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct,std::allocator< openstudio::model::AirflowNetworkEquivalentDuct > >":

    return _openstudiomodelairflow.getAirflowNetworkEquivalentDucts(t_model)

getAirflowNetworkEquivalentDucts = _openstudiomodelairflow.getAirflowNetworkEquivalentDucts



def getAirflowNetworkEquivalentDuctByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkEquivalentDuct >":

    return _openstudiomodelairflow.getAirflowNetworkEquivalentDuctByName(t_model, t_name)

getAirflowNetworkEquivalentDuctByName = _openstudiomodelairflow.getAirflowNetworkEquivalentDuctByName



def getAirflowNetworkEquivalentDuctsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkEquivalentDuct,std::allocator< openstudio::model::AirflowNetworkEquivalentDuct > >":

    return _openstudiomodelairflow.getAirflowNetworkEquivalentDuctsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkEquivalentDuctsByName = _openstudiomodelairflow.getAirflowNetworkEquivalentDuctsByName

class AirflowNetworkExternalNode(AirflowNetworkNode):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkExternalNode, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkExternalNode, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkExternalNode(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkExternalNode

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkExternalNode_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkExternalNode_iddObjectType)

    __swig_getmethods__["windAngleTypeValues"] = lambda x: _openstudiomodelairflow.AirflowNetworkExternalNode_windAngleTypeValues

    if _newclass:

        windAngleTypeValues = staticmethod(_openstudiomodelairflow.AirflowNetworkExternalNode_windAngleTypeValues)



    def externalNodeHeight(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_externalNodeHeight(self)



    def isExternalNodeHeightDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_isExternalNodeHeightDefaulted(self)



    def windPressureCoefficientCurve(self) -> "openstudio::model::Curve":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_windPressureCoefficientCurve(self)



    def symmetricWindPressureCoefficientCurve(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_symmetricWindPressureCoefficientCurve(self)



    def isSymmetricWindPressureCoefficientCurveDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_isSymmetricWindPressureCoefficientCurveDefaulted(self)



    def windAngleType(self) -> "std::string":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_windAngleType(self)



    def isWindAngleTypeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_isWindAngleTypeDefaulted(self)



    def setExternalNodeHeight(self, externalNodeHeight: 'double') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_setExternalNodeHeight(self, externalNodeHeight)



    def resetExternalNodeHeight(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_resetExternalNodeHeight(self)



    def setWindPressureCoefficientCurve(self, wPCValue: 'Curve') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_setWindPressureCoefficientCurve(self, wPCValue)



    def setSymmetricWindPressureCoefficientCurve(self, symmetricWindPressureCoefficientCurve: 'bool') -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_setSymmetricWindPressureCoefficientCurve(self, symmetricWindPressureCoefficientCurve)



    def resetSymmetricWindPressureCoefficientCurve(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_resetSymmetricWindPressureCoefficientCurve(self)



    def setWindAngleType(self, windAngleType: 'std::string const &') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_setWindAngleType(self, windAngleType)



    def resetWindAngleType(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkExternalNode_resetWindAngleType(self)

AirflowNetworkExternalNode_swigregister = _openstudiomodelairflow.AirflowNetworkExternalNode_swigregister

AirflowNetworkExternalNode_swigregister(AirflowNetworkExternalNode)



def AirflowNetworkExternalNode_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkExternalNode_iddObjectType()

AirflowNetworkExternalNode_iddObjectType = _openstudiomodelairflow.AirflowNetworkExternalNode_iddObjectType



def AirflowNetworkExternalNode_windAngleTypeValues() -> "std::vector< std::string,std::allocator< std::string > >":

    return _openstudiomodelairflow.AirflowNetworkExternalNode_windAngleTypeValues()

AirflowNetworkExternalNode_windAngleTypeValues = _openstudiomodelairflow.AirflowNetworkExternalNode_windAngleTypeValues





def toAirflowNetworkExternalNode(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkExternalNode >":

    return _openstudiomodelairflow.toAirflowNetworkExternalNode(idfObject)

toAirflowNetworkExternalNode = _openstudiomodelairflow.toAirflowNetworkExternalNode



def getAirflowNetworkExternalNode(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkExternalNode >":

    return _openstudiomodelairflow.getAirflowNetworkExternalNode(t_model, t_handle)

getAirflowNetworkExternalNode = _openstudiomodelairflow.getAirflowNetworkExternalNode



def getAirflowNetworkExternalNodes(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkExternalNode,std::allocator< openstudio::model::AirflowNetworkExternalNode > >":

    return _openstudiomodelairflow.getAirflowNetworkExternalNodes(t_model)

getAirflowNetworkExternalNodes = _openstudiomodelairflow.getAirflowNetworkExternalNodes



def getAirflowNetworkExternalNodeByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkExternalNode >":

    return _openstudiomodelairflow.getAirflowNetworkExternalNodeByName(t_model, t_name)

getAirflowNetworkExternalNodeByName = _openstudiomodelairflow.getAirflowNetworkExternalNodeByName



def getAirflowNetworkExternalNodesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkExternalNode,std::allocator< openstudio::model::AirflowNetworkExternalNode > >":

    return _openstudiomodelairflow.getAirflowNetworkExternalNodesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkExternalNodesByName = _openstudiomodelairflow.getAirflowNetworkExternalNodesByName

class AirflowNetworkFan(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkFan, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkFan, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkFan

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkFan_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkFan_iddObjectType)



    def fanConstantVolume(self) -> "boost::optional< openstudio::model::FanConstantVolume >":

        return _openstudiomodelairflow.AirflowNetworkFan_fanConstantVolume(self)



    def fanVariableVolume(self) -> "boost::optional< openstudio::model::FanVariableVolume >":

        return _openstudiomodelairflow.AirflowNetworkFan_fanVariableVolume(self)



    def fanOnOff(self) -> "boost::optional< openstudio::model::FanOnOff >":

        return _openstudiomodelairflow.AirflowNetworkFan_fanOnOff(self)

AirflowNetworkFan_swigregister = _openstudiomodelairflow.AirflowNetworkFan_swigregister

AirflowNetworkFan_swigregister(AirflowNetworkFan)



def AirflowNetworkFan_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkFan_iddObjectType()

AirflowNetworkFan_iddObjectType = _openstudiomodelairflow.AirflowNetworkFan_iddObjectType





def toAirflowNetworkFan(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkFan >":

    return _openstudiomodelairflow.toAirflowNetworkFan(idfObject)

toAirflowNetworkFan = _openstudiomodelairflow.toAirflowNetworkFan



def getAirflowNetworkFan(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkFan >":

    return _openstudiomodelairflow.getAirflowNetworkFan(t_model, t_handle)

getAirflowNetworkFan = _openstudiomodelairflow.getAirflowNetworkFan



def getAirflowNetworkFans(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkFan,std::allocator< openstudio::model::AirflowNetworkFan > >":

    return _openstudiomodelairflow.getAirflowNetworkFans(t_model)

getAirflowNetworkFans = _openstudiomodelairflow.getAirflowNetworkFans



def getAirflowNetworkFanByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkFan >":

    return _openstudiomodelairflow.getAirflowNetworkFanByName(t_model, t_name)

getAirflowNetworkFanByName = _openstudiomodelairflow.getAirflowNetworkFanByName



def getAirflowNetworkFansByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkFan,std::allocator< openstudio::model::AirflowNetworkFan > >":

    return _openstudiomodelairflow.getAirflowNetworkFansByName(t_model, t_name, t_exactMatch)

getAirflowNetworkFansByName = _openstudiomodelairflow.getAirflowNetworkFansByName

class AirflowNetworkHorizontalOpening(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkHorizontalOpening, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkHorizontalOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkHorizontalOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkHorizontalOpening

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkHorizontalOpening_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkHorizontalOpening_iddObjectType)



    def airMassFlowCoefficientWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_airMassFlowCoefficientWhenOpeningisClosed(self)



    def airMassFlowExponentWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_airMassFlowExponentWhenOpeningisClosed(self)



    def isAirMassFlowExponentWhenOpeningisClosedDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_isAirMassFlowExponentWhenOpeningisClosedDefaulted(self)



    def slopingPlaneAngle(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_slopingPlaneAngle(self)



    def isSlopingPlaneAngleDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_isSlopingPlaneAngleDefaulted(self)



    def dischargeCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_dischargeCoefficient(self)



    def setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed)



    def setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed)



    def resetAirMassFlowExponentWhenOpeningisClosed(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_resetAirMassFlowExponentWhenOpeningisClosed(self)



    def setSlopingPlaneAngle(self, slopingPlaneAngle: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_setSlopingPlaneAngle(self, slopingPlaneAngle)



    def resetSlopingPlaneAngle(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_resetSlopingPlaneAngle(self)



    def setDischargeCoefficient(self, dischargeCoefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_setDischargeCoefficient(self, dischargeCoefficient)

AirflowNetworkHorizontalOpening_swigregister = _openstudiomodelairflow.AirflowNetworkHorizontalOpening_swigregister

AirflowNetworkHorizontalOpening_swigregister(AirflowNetworkHorizontalOpening)



def AirflowNetworkHorizontalOpening_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkHorizontalOpening_iddObjectType()

AirflowNetworkHorizontalOpening_iddObjectType = _openstudiomodelairflow.AirflowNetworkHorizontalOpening_iddObjectType





def toAirflowNetworkHorizontalOpening(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkHorizontalOpening >":

    return _openstudiomodelairflow.toAirflowNetworkHorizontalOpening(idfObject)

toAirflowNetworkHorizontalOpening = _openstudiomodelairflow.toAirflowNetworkHorizontalOpening



def getAirflowNetworkHorizontalOpening(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkHorizontalOpening >":

    return _openstudiomodelairflow.getAirflowNetworkHorizontalOpening(t_model, t_handle)

getAirflowNetworkHorizontalOpening = _openstudiomodelairflow.getAirflowNetworkHorizontalOpening



def getAirflowNetworkHorizontalOpenings(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening,std::allocator< openstudio::model::AirflowNetworkHorizontalOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkHorizontalOpenings(t_model)

getAirflowNetworkHorizontalOpenings = _openstudiomodelairflow.getAirflowNetworkHorizontalOpenings



def getAirflowNetworkHorizontalOpeningByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkHorizontalOpening >":

    return _openstudiomodelairflow.getAirflowNetworkHorizontalOpeningByName(t_model, t_name)

getAirflowNetworkHorizontalOpeningByName = _openstudiomodelairflow.getAirflowNetworkHorizontalOpeningByName



def getAirflowNetworkHorizontalOpeningsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkHorizontalOpening,std::allocator< openstudio::model::AirflowNetworkHorizontalOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkHorizontalOpeningsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkHorizontalOpeningsByName = _openstudiomodelairflow.getAirflowNetworkHorizontalOpeningsByName

class AirflowNetworkLeakageRatio(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkLeakageRatio, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkLeakageRatio, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model'):

        this = _openstudiomodelairflow.new_AirflowNetworkLeakageRatio(model)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkLeakageRatio

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkLeakageRatio_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkLeakageRatio_iddObjectType)



    def effectiveLeakageRatio(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_effectiveLeakageRatio(self)



    def maximumFlowRate(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_maximumFlowRate(self)



    def referencePressureDifference(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_referencePressureDifference(self)



    def airMassFlowExponent(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_airMassFlowExponent(self)



    def isAirMassFlowExponentDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_isAirMassFlowExponentDefaulted(self)



    def setEffectiveLeakageRatio(self, effectiveLeakageRatio: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_setEffectiveLeakageRatio(self, effectiveLeakageRatio)



    def resetEffectiveLeakageRatio(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_resetEffectiveLeakageRatio(self)



    def setMaximumFlowRate(self, maximumFlowRate: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_setMaximumFlowRate(self, maximumFlowRate)



    def setReferencePressureDifference(self, referencePressureDifference: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_setReferencePressureDifference(self, referencePressureDifference)



    def setAirMassFlowExponent(self, airMassFlowExponent: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_setAirMassFlowExponent(self, airMassFlowExponent)



    def resetAirMassFlowExponent(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkLeakageRatio_resetAirMassFlowExponent(self)

AirflowNetworkLeakageRatio_swigregister = _openstudiomodelairflow.AirflowNetworkLeakageRatio_swigregister

AirflowNetworkLeakageRatio_swigregister(AirflowNetworkLeakageRatio)



def AirflowNetworkLeakageRatio_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkLeakageRatio_iddObjectType()

AirflowNetworkLeakageRatio_iddObjectType = _openstudiomodelairflow.AirflowNetworkLeakageRatio_iddObjectType





def toAirflowNetworkLeakageRatio(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkLeakageRatio >":

    return _openstudiomodelairflow.toAirflowNetworkLeakageRatio(idfObject)

toAirflowNetworkLeakageRatio = _openstudiomodelairflow.toAirflowNetworkLeakageRatio



def getAirflowNetworkLeakageRatio(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkLeakageRatio >":

    return _openstudiomodelairflow.getAirflowNetworkLeakageRatio(t_model, t_handle)

getAirflowNetworkLeakageRatio = _openstudiomodelairflow.getAirflowNetworkLeakageRatio



def getAirflowNetworkLeakageRatios(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio,std::allocator< openstudio::model::AirflowNetworkLeakageRatio > >":

    return _openstudiomodelairflow.getAirflowNetworkLeakageRatios(t_model)

getAirflowNetworkLeakageRatios = _openstudiomodelairflow.getAirflowNetworkLeakageRatios



def getAirflowNetworkLeakageRatioByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkLeakageRatio >":

    return _openstudiomodelairflow.getAirflowNetworkLeakageRatioByName(t_model, t_name)

getAirflowNetworkLeakageRatioByName = _openstudiomodelairflow.getAirflowNetworkLeakageRatioByName



def getAirflowNetworkLeakageRatiosByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkLeakageRatio,std::allocator< openstudio::model::AirflowNetworkLeakageRatio > >":

    return _openstudiomodelairflow.getAirflowNetworkLeakageRatiosByName(t_model, t_name, t_exactMatch)

getAirflowNetworkLeakageRatiosByName = _openstudiomodelairflow.getAirflowNetworkLeakageRatiosByName

class AirflowNetworkOccupantVentilationControl(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkOccupantVentilationControl, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkOccupantVentilationControl, name)

    __repr__ = _swig_repr



    def __init__(self, model: 'Model', curve: 'Curve'):

        this = _openstudiomodelairflow.new_AirflowNetworkOccupantVentilationControl(model, curve)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkOccupantVentilationControl

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_iddObjectType)



    def minimumOpeningTime(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_minimumOpeningTime(self)



    def isMinimumOpeningTimeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_isMinimumOpeningTimeDefaulted(self)



    def minimumClosingTime(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_minimumClosingTime(self)



    def isMinimumClosingTimeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_isMinimumClosingTimeDefaulted(self)



    def thermalComfortLowTemperatureCurve(self) -> "openstudio::model::Curve":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_thermalComfortLowTemperatureCurve(self)



    def thermalComfortTemperatureBoundaryPoint(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_thermalComfortTemperatureBoundaryPoint(self)



    def isThermalComfortTemperatureBoundaryPointDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_isThermalComfortTemperatureBoundaryPointDefaulted(self)



    def thermalComfortHighTemperatureCurve(self) -> "boost::optional< openstudio::model::Curve >":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_thermalComfortHighTemperatureCurve(self)



    def maximumPredictedPercentageofDissatisfiedThreshold(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_maximumPredictedPercentageofDissatisfiedThreshold(self)



    def isMaximumPredictedPercentageofDissatisfiedThresholdDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_isMaximumPredictedPercentageofDissatisfiedThresholdDefaulted(self)



    def occupancyCheck(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_occupancyCheck(self)



    def isOccupancyCheckDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_isOccupancyCheckDefaulted(self)



    def openingProbabilitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_openingProbabilitySchedule(self)



    def closingProbabilitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_closingProbabilitySchedule(self)



    def setMinimumOpeningTime(self, minimumOpeningTime: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setMinimumOpeningTime(self, minimumOpeningTime)



    def resetMinimumOpeningTime(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetMinimumOpeningTime(self)



    def setMinimumClosingTime(self, minimumClosingTime: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setMinimumClosingTime(self, minimumClosingTime)



    def resetMinimumClosingTime(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetMinimumClosingTime(self)



    def setThermalComfortLowTemperatureCurve(self, curve: 'Curve') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setThermalComfortLowTemperatureCurve(self, curve)



    def setThermalComfortTemperatureBoundaryPoint(self, thermalComfortTemperatureBoundaryPoint: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setThermalComfortTemperatureBoundaryPoint(self, thermalComfortTemperatureBoundaryPoint)



    def resetThermalComfortTemperatureBoundaryPoint(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetThermalComfortTemperatureBoundaryPoint(self)



    def setThermalComfortHighTemperatureCurve(self, curve: 'Curve') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setThermalComfortHighTemperatureCurve(self, curve)



    def resetThermalComfortHighTemperatureCurve(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetThermalComfortHighTemperatureCurve(self)



    def setMaximumPredictedPercentageofDissatisfiedThreshold(self, maximumPredictedPercentageofDissatisfiedThreshold: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setMaximumPredictedPercentageofDissatisfiedThreshold(self, maximumPredictedPercentageofDissatisfiedThreshold)



    def resetMaximumPredictedPercentageofDissatisfiedThreshold(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetMaximumPredictedPercentageofDissatisfiedThreshold(self)



    def setOccupancyCheck(self, occupancyCheck: 'bool') -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setOccupancyCheck(self, occupancyCheck)



    def resetOccupancyCheck(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetOccupancyCheck(self)



    def setOpeningProbabilitySchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setOpeningProbabilitySchedule(self, schedule)



    def resetOpeningProbabilitySchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetOpeningProbabilitySchedule(self)



    def setClosingProbabilitySchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_setClosingProbabilitySchedule(self, schedule)



    def resetClosingProbabilitySchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_resetClosingProbabilitySchedule(self)

AirflowNetworkOccupantVentilationControl_swigregister = _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_swigregister

AirflowNetworkOccupantVentilationControl_swigregister(AirflowNetworkOccupantVentilationControl)



def AirflowNetworkOccupantVentilationControl_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_iddObjectType()

AirflowNetworkOccupantVentilationControl_iddObjectType = _openstudiomodelairflow.AirflowNetworkOccupantVentilationControl_iddObjectType





def toAirflowNetworkOccupantVentilationControl(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkOccupantVentilationControl >":

    return _openstudiomodelairflow.toAirflowNetworkOccupantVentilationControl(idfObject)

toAirflowNetworkOccupantVentilationControl = _openstudiomodelairflow.toAirflowNetworkOccupantVentilationControl



def getAirflowNetworkOccupantVentilationControl(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkOccupantVentilationControl >":

    return _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControl(t_model, t_handle)

getAirflowNetworkOccupantVentilationControl = _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControl



def getAirflowNetworkOccupantVentilationControls(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl,std::allocator< openstudio::model::AirflowNetworkOccupantVentilationControl > >":

    return _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControls(t_model)

getAirflowNetworkOccupantVentilationControls = _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControls



def getAirflowNetworkOccupantVentilationControlByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkOccupantVentilationControl >":

    return _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControlByName(t_model, t_name)

getAirflowNetworkOccupantVentilationControlByName = _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControlByName



def getAirflowNetworkOccupantVentilationControlsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkOccupantVentilationControl,std::allocator< openstudio::model::AirflowNetworkOccupantVentilationControl > >":

    return _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControlsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkOccupantVentilationControlsByName = _openstudiomodelairflow.getAirflowNetworkOccupantVentilationControlsByName

class AirflowNetworkOutdoorAirflow(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkOutdoorAirflow, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkOutdoorAirflow, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkOutdoorAirflow

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkOutdoorAirflow_iddObjectType)



    def controllerOutdoorAir(self) -> "boost::optional< openstudio::model::ControllerOutdoorAir >":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_controllerOutdoorAir(self)



    def crack(self) -> "boost::optional< openstudio::model::AirflowNetworkCrack >":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_crack(self)



    def setCrack(self, crack: 'AirflowNetworkCrack') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_setCrack(self, crack)

AirflowNetworkOutdoorAirflow_swigregister = _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_swigregister

AirflowNetworkOutdoorAirflow_swigregister(AirflowNetworkOutdoorAirflow)



def AirflowNetworkOutdoorAirflow_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_iddObjectType()

AirflowNetworkOutdoorAirflow_iddObjectType = _openstudiomodelairflow.AirflowNetworkOutdoorAirflow_iddObjectType





def toAirflowNetworkOutdoorAirflow(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkOutdoorAirflow >":

    return _openstudiomodelairflow.toAirflowNetworkOutdoorAirflow(idfObject)

toAirflowNetworkOutdoorAirflow = _openstudiomodelairflow.toAirflowNetworkOutdoorAirflow



def getAirflowNetworkOutdoorAirflow(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkOutdoorAirflow >":

    return _openstudiomodelairflow.getAirflowNetworkOutdoorAirflow(t_model, t_handle)

getAirflowNetworkOutdoorAirflow = _openstudiomodelairflow.getAirflowNetworkOutdoorAirflow



def getAirflowNetworkOutdoorAirflows(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow,std::allocator< openstudio::model::AirflowNetworkOutdoorAirflow > >":

    return _openstudiomodelairflow.getAirflowNetworkOutdoorAirflows(t_model)

getAirflowNetworkOutdoorAirflows = _openstudiomodelairflow.getAirflowNetworkOutdoorAirflows



def getAirflowNetworkOutdoorAirflowByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkOutdoorAirflow >":

    return _openstudiomodelairflow.getAirflowNetworkOutdoorAirflowByName(t_model, t_name)

getAirflowNetworkOutdoorAirflowByName = _openstudiomodelairflow.getAirflowNetworkOutdoorAirflowByName



def getAirflowNetworkOutdoorAirflowsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkOutdoorAirflow,std::allocator< openstudio::model::AirflowNetworkOutdoorAirflow > >":

    return _openstudiomodelairflow.getAirflowNetworkOutdoorAirflowsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkOutdoorAirflowsByName = _openstudiomodelairflow.getAirflowNetworkOutdoorAirflowsByName

class AirflowNetworkReferenceCrackConditions(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkReferenceCrackConditions, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkReferenceCrackConditions, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkReferenceCrackConditions(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkReferenceCrackConditions

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_iddObjectType)



    def temperature(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_temperature(self)



    def isTemperatureDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_isTemperatureDefaulted(self)



    def barometricPressure(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_barometricPressure(self)



    def isBarometricPressureDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_isBarometricPressureDefaulted(self)



    def humidityRatio(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_humidityRatio(self)



    def isHumidityRatioDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_isHumidityRatioDefaulted(self)



    def setTemperature(self, referenceTemperature: 'double') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_setTemperature(self, referenceTemperature)



    def resetTemperature(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_resetTemperature(self)



    def setBarometricPressure(self, referenceBarometricPressure: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_setBarometricPressure(self, referenceBarometricPressure)



    def resetBarometricPressure(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_resetBarometricPressure(self)



    def setHumidityRatio(self, referenceHumidityRatio: 'double') -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_setHumidityRatio(self, referenceHumidityRatio)



    def resetHumidityRatio(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_resetHumidityRatio(self)

AirflowNetworkReferenceCrackConditions_swigregister = _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_swigregister

AirflowNetworkReferenceCrackConditions_swigregister(AirflowNetworkReferenceCrackConditions)



def AirflowNetworkReferenceCrackConditions_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_iddObjectType()

AirflowNetworkReferenceCrackConditions_iddObjectType = _openstudiomodelairflow.AirflowNetworkReferenceCrackConditions_iddObjectType





def toAirflowNetworkReferenceCrackConditions(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkReferenceCrackConditions >":

    return _openstudiomodelairflow.toAirflowNetworkReferenceCrackConditions(idfObject)

toAirflowNetworkReferenceCrackConditions = _openstudiomodelairflow.toAirflowNetworkReferenceCrackConditions



def getAirflowNetworkReferenceCrackConditions(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkReferenceCrackConditions >":

    return _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditions(t_model, t_handle)

getAirflowNetworkReferenceCrackConditions = _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditions



def getAirflowNetworkReferenceCrackConditionss(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions,std::allocator< openstudio::model::AirflowNetworkReferenceCrackConditions > >":

    return _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionss(t_model)

getAirflowNetworkReferenceCrackConditionss = _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionss



def getAirflowNetworkReferenceCrackConditionsByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkReferenceCrackConditions >":

    return _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionsByName(t_model, t_name)

getAirflowNetworkReferenceCrackConditionsByName = _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionsByName



def getAirflowNetworkReferenceCrackConditionssByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkReferenceCrackConditions,std::allocator< openstudio::model::AirflowNetworkReferenceCrackConditions > >":

    return _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionssByName(t_model, t_name, t_exactMatch)

getAirflowNetworkReferenceCrackConditionssByName = _openstudiomodelairflow.getAirflowNetworkReferenceCrackConditionssByName

class AirflowNetworkSimpleOpening(AirflowNetworkComponent):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkSimpleOpening, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkComponent]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkSimpleOpening, name)

    __repr__ = _swig_repr



    def __init__(self, *args):

        this = _openstudiomodelairflow.new_AirflowNetworkSimpleOpening(*args)

        try:

            self.this.append(this)

        except:

            self.this = this

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkSimpleOpening

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkSimpleOpening_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkSimpleOpening_iddObjectType)



    def airMassFlowCoefficientWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_airMassFlowCoefficientWhenOpeningisClosed(self)



    def airMassFlowExponentWhenOpeningisClosed(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_airMassFlowExponentWhenOpeningisClosed(self)



    def isAirMassFlowExponentWhenOpeningisClosedDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_isAirMassFlowExponentWhenOpeningisClosedDefaulted(self)



    def minimumDensityDifferenceforTwoWayFlow(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_minimumDensityDifferenceforTwoWayFlow(self)



    def dischargeCoefficient(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_dischargeCoefficient(self)



    def setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_setAirMassFlowCoefficientWhenOpeningisClosed(self, airMassFlowCoefficientWhenOpeningisClosed)



    def setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_setAirMassFlowExponentWhenOpeningisClosed(self, airMassFlowExponentWhenOpeningisClosed)



    def resetAirMassFlowExponentWhenOpeningisClosed(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_resetAirMassFlowExponentWhenOpeningisClosed(self)



    def setMinimumDensityDifferenceforTwoWayFlow(self, minimumDensityDifferenceforTwoWayFlow: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_setMinimumDensityDifferenceforTwoWayFlow(self, minimumDensityDifferenceforTwoWayFlow)



    def setDischargeCoefficient(self, dischargeCoefficient: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimpleOpening_setDischargeCoefficient(self, dischargeCoefficient)

AirflowNetworkSimpleOpening_swigregister = _openstudiomodelairflow.AirflowNetworkSimpleOpening_swigregister

AirflowNetworkSimpleOpening_swigregister(AirflowNetworkSimpleOpening)



def AirflowNetworkSimpleOpening_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkSimpleOpening_iddObjectType()

AirflowNetworkSimpleOpening_iddObjectType = _openstudiomodelairflow.AirflowNetworkSimpleOpening_iddObjectType





def toAirflowNetworkSimpleOpening(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkSimpleOpening >":

    return _openstudiomodelairflow.toAirflowNetworkSimpleOpening(idfObject)

toAirflowNetworkSimpleOpening = _openstudiomodelairflow.toAirflowNetworkSimpleOpening



def getAirflowNetworkSimpleOpening(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkSimpleOpening >":

    return _openstudiomodelairflow.getAirflowNetworkSimpleOpening(t_model, t_handle)

getAirflowNetworkSimpleOpening = _openstudiomodelairflow.getAirflowNetworkSimpleOpening



def getAirflowNetworkSimpleOpenings(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening,std::allocator< openstudio::model::AirflowNetworkSimpleOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkSimpleOpenings(t_model)

getAirflowNetworkSimpleOpenings = _openstudiomodelairflow.getAirflowNetworkSimpleOpenings



def getAirflowNetworkSimpleOpeningByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkSimpleOpening >":

    return _openstudiomodelairflow.getAirflowNetworkSimpleOpeningByName(t_model, t_name)

getAirflowNetworkSimpleOpeningByName = _openstudiomodelairflow.getAirflowNetworkSimpleOpeningByName



def getAirflowNetworkSimpleOpeningsByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkSimpleOpening,std::allocator< openstudio::model::AirflowNetworkSimpleOpening > >":

    return _openstudiomodelairflow.getAirflowNetworkSimpleOpeningsByName(t_model, t_name, t_exactMatch)

getAirflowNetworkSimpleOpeningsByName = _openstudiomodelairflow.getAirflowNetworkSimpleOpeningsByName

class AirflowNetworkSimulationControl(openstudiomodelcore.ParentObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ParentObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkSimulationControl, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ParentObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkSimulationControl, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkSimulationControl

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkSimulationControl_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkSimulationControl_iddObjectType)



    def airflowNetworkControl(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_airflowNetworkControl(self)



    def isAirflowNetworkControlDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isAirflowNetworkControlDefaulted(self)



    def windPressureCoefficientType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_windPressureCoefficientType(self)



    def isWindPressureCoefficientTypeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isWindPressureCoefficientTypeDefaulted(self)



    def heightSelectionforLocalWindPressureCalculation(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_heightSelectionforLocalWindPressureCalculation(self)



    def isHeightSelectionforLocalWindPressureCalculationDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isHeightSelectionforLocalWindPressureCalculationDefaulted(self)



    def buildingType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_buildingType(self)



    def isBuildingTypeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isBuildingTypeDefaulted(self)



    def maximumNumberofIterations(self) -> "boost::optional< int >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_maximumNumberofIterations(self)



    def isMaximumNumberofIterationsDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isMaximumNumberofIterationsDefaulted(self)



    def initializationType(self) -> "boost::optional< std::string >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_initializationType(self)



    def isInitializationTypeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isInitializationTypeDefaulted(self)



    def relativeAirflowConvergenceTolerance(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_relativeAirflowConvergenceTolerance(self)



    def isRelativeAirflowConvergenceToleranceDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isRelativeAirflowConvergenceToleranceDefaulted(self)



    def absoluteAirflowConvergenceTolerance(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_absoluteAirflowConvergenceTolerance(self)



    def isAbsoluteAirflowConvergenceToleranceDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isAbsoluteAirflowConvergenceToleranceDefaulted(self)



    def convergenceAccelerationLimit(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_convergenceAccelerationLimit(self)



    def isConvergenceAccelerationLimitDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isConvergenceAccelerationLimitDefaulted(self)



    def azimuthAngleofLongAxisofBuilding(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_azimuthAngleofLongAxisofBuilding(self)



    def isAzimuthAngleofLongAxisofBuildingDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isAzimuthAngleofLongAxisofBuildingDefaulted(self)



    def buildingAspectRatio(self) -> "boost::optional< double >":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_buildingAspectRatio(self)



    def isBuildingAspectRatioDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isBuildingAspectRatioDefaulted(self)



    def heightDependenceofExternalNodeTemperature(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_heightDependenceofExternalNodeTemperature(self)



    def isHeightDependenceofExternalNodeTemperatureDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_isHeightDependenceofExternalNodeTemperatureDefaulted(self)



    def setAirflowNetworkControl(self, airflowNetworkControl: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setAirflowNetworkControl(self, airflowNetworkControl)



    def resetAirflowNetworkControl(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetAirflowNetworkControl(self)



    def setWindPressureCoefficientType(self, type: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setWindPressureCoefficientType(self, type)



    def resetWindPressureCoefficientType(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetWindPressureCoefficientType(self)



    def setHeightSelectionforLocalWindPressureCalculation(self, height: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setHeightSelectionforLocalWindPressureCalculation(self, height)



    def resetHeightSelectionforLocalWindPressureCalculation(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetHeightSelectionforLocalWindPressureCalculation(self)



    def setBuildingType(self, type: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setBuildingType(self, type)



    def resetBuildingType(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetBuildingType(self)



    def setMaximumNumberofIterations(self, number: 'int') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setMaximumNumberofIterations(self, number)



    def resetMaximumNumberofIterations(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetMaximumNumberofIterations(self)



    def setInitializationType(self, type: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setInitializationType(self, type)



    def resetInitializationType(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetInitializationType(self)



    def setRelativeAirflowConvergenceTolerance(self, tolerance: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setRelativeAirflowConvergenceTolerance(self, tolerance)



    def resetRelativeAirflowConvergenceTolerance(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetRelativeAirflowConvergenceTolerance(self)



    def setAbsoluteAirflowConvergenceTolerance(self, tolerance: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setAbsoluteAirflowConvergenceTolerance(self, tolerance)



    def resetAbsoluteAirflowConvergenceTolerance(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetAbsoluteAirflowConvergenceTolerance(self)



    def setConvergenceAccelerationLimit(self, limit: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setConvergenceAccelerationLimit(self, limit)



    def resetConvergenceAccelerationLimit(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetConvergenceAccelerationLimit(self)



    def setAzimuthAngleofLongAxisofBuilding(self, angle: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setAzimuthAngleofLongAxisofBuilding(self, angle)



    def resetAzimuthAngleofLongAxisofBuilding(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetAzimuthAngleofLongAxisofBuilding(self)



    def setBuildingAspectRatio(self, ratio: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setBuildingAspectRatio(self, ratio)



    def resetBuildingAspectRatio(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetBuildingAspectRatio(self)



    def setHeightDependenceofExternalNodeTemperature(self, tf: 'bool') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_setHeightDependenceofExternalNodeTemperature(self, tf)



    def resetHeightDependenceofExternalNodeTemperature(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSimulationControl_resetHeightDependenceofExternalNodeTemperature(self)

AirflowNetworkSimulationControl_swigregister = _openstudiomodelairflow.AirflowNetworkSimulationControl_swigregister

AirflowNetworkSimulationControl_swigregister(AirflowNetworkSimulationControl)



def AirflowNetworkSimulationControl_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkSimulationControl_iddObjectType()

AirflowNetworkSimulationControl_iddObjectType = _openstudiomodelairflow.AirflowNetworkSimulationControl_iddObjectType





def toAirflowNetworkSimulationControl(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkSimulationControl >":

    return _openstudiomodelairflow.toAirflowNetworkSimulationControl(idfObject)

toAirflowNetworkSimulationControl = _openstudiomodelairflow.toAirflowNetworkSimulationControl



def getAirflowNetworkSimulationControl(t_model: 'Model') -> "openstudio::model::AirflowNetworkSimulationControl":

    return _openstudiomodelairflow.getAirflowNetworkSimulationControl(t_model)

getAirflowNetworkSimulationControl = _openstudiomodelairflow.getAirflowNetworkSimulationControl



def getOptionalAirflowNetworkSimulationControl(t_model: 'Model') -> "boost::optional< openstudio::model::AirflowNetworkSimulationControl >":

    return _openstudiomodelairflow.getOptionalAirflowNetworkSimulationControl(t_model)

getOptionalAirflowNetworkSimulationControl = _openstudiomodelairflow.getOptionalAirflowNetworkSimulationControl

class AirflowNetworkSurface(AirflowNetworkLinkage):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkLinkage]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkSurface, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkLinkage]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkSurface, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkSurface

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkSurface_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkSurface_iddObjectType)

    __swig_getmethods__["ventilationControlModeValues"] = lambda x: _openstudiomodelairflow.AirflowNetworkSurface_ventilationControlModeValues

    if _newclass:

        ventilationControlModeValues = staticmethod(_openstudiomodelairflow.AirflowNetworkSurface_ventilationControlModeValues)



    def surface(self) -> "openstudio::model::PlanarSurface":

        return _openstudiomodelairflow.AirflowNetworkSurface_surface(self)



    def leakageComponent(self) -> "boost::optional< openstudio::model::AirflowNetworkComponent >":

        return _openstudiomodelairflow.AirflowNetworkSurface_leakageComponent(self)



    def externalNode(self) -> "boost::optional< openstudio::model::AirflowNetworkExternalNode >":

        return _openstudiomodelairflow.AirflowNetworkSurface_externalNode(self)



    def windowDoorOpeningFactorOrCrackFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_windowDoorOpeningFactorOrCrackFactor(self)



    def isWindowDoorOpeningFactorOrCrackFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isWindowDoorOpeningFactorOrCrackFactorDefaulted(self)



    def ventilationControlMode(self) -> "std::string":

        return _openstudiomodelairflow.AirflowNetworkSurface_ventilationControlMode(self)



    def isVentilationControlModeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isVentilationControlModeDefaulted(self)



    def ventilationControlZoneTemperatureSetpointSchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkSurface_ventilationControlZoneTemperatureSetpointSchedule(self)



    def minimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_minimumVentingOpenFactor(self)



    def isMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isMinimumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def isIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def isIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def isIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkSurface_indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def isIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_isIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self)



    def ventingAvailabilitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkSurface_ventingAvailabilitySchedule(self)



    def occupantVentilationControl(self) -> "boost::optional< openstudio::model::AirflowNetworkOccupantVentilationControl >":

        return _openstudiomodelairflow.AirflowNetworkSurface_occupantVentilationControl(self)



    def setLeakageComponent(self, surfaceAirflowLeakage: 'AirflowNetworkComponent') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setLeakageComponent(self, surfaceAirflowLeakage)



    def setExternalNode(self, externalNode: 'AirflowNetworkExternalNode') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setExternalNode(self, externalNode)



    def resetExternalNode(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetExternalNode(self)



    def setWindowDoorOpeningFactorOrCrackFactor(self, windowDoorOpeningFactorOrCrackFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setWindowDoorOpeningFactorOrCrackFactor(self, windowDoorOpeningFactorOrCrackFactor)



    def resetWindowDoorOpeningFactorOrCrackFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetWindowDoorOpeningFactorOrCrackFactor(self)



    def setVentilationControlMode(self, ventilationControlMode: 'std::string') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setVentilationControlMode(self, ventilationControlMode)



    def resetVentilationControlMode(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetVentilationControlMode(self)



    def setVentilationControlZoneTemperatureSetpointSchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setVentilationControlZoneTemperatureSetpointSchedule(self, schedule)



    def resetVentilationControlZoneTemperatureSetpointSchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetVentilationControlZoneTemperatureSetpointSchedule(self)



    def setMinimumVentingOpenFactor(self, minimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setMinimumVentingOpenFactor(self, minimumVentingOpenFactor)



    def resetMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetMinimumVentingOpenFactor(self)



    def setIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor)



    def resetIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def setIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor)



    def resetIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def setIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor)



    def resetIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def setIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor)



    def resetIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def setVentingAvailabilitySchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setVentingAvailabilitySchedule(self, schedule)



    def resetVentingAvailabilitySchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetVentingAvailabilitySchedule(self)



    def setOccupantVentilationControl(self, airflowNetworkOccupantVentilationControl: 'AirflowNetworkOccupantVentilationControl') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkSurface_setOccupantVentilationControl(self, airflowNetworkOccupantVentilationControl)



    def resetOccupantVentilationControl(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkSurface_resetOccupantVentilationControl(self)

AirflowNetworkSurface_swigregister = _openstudiomodelairflow.AirflowNetworkSurface_swigregister

AirflowNetworkSurface_swigregister(AirflowNetworkSurface)



def AirflowNetworkSurface_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkSurface_iddObjectType()

AirflowNetworkSurface_iddObjectType = _openstudiomodelairflow.AirflowNetworkSurface_iddObjectType



def AirflowNetworkSurface_ventilationControlModeValues() -> "std::vector< std::string,std::allocator< std::string > >":

    return _openstudiomodelairflow.AirflowNetworkSurface_ventilationControlModeValues()

AirflowNetworkSurface_ventilationControlModeValues = _openstudiomodelairflow.AirflowNetworkSurface_ventilationControlModeValues





def toAirflowNetworkSurface(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkSurface >":

    return _openstudiomodelairflow.toAirflowNetworkSurface(idfObject)

toAirflowNetworkSurface = _openstudiomodelairflow.toAirflowNetworkSurface



def getAirflowNetworkSurface(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkSurface >":

    return _openstudiomodelairflow.getAirflowNetworkSurface(t_model, t_handle)

getAirflowNetworkSurface = _openstudiomodelairflow.getAirflowNetworkSurface



def getAirflowNetworkSurfaces(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkSurface,std::allocator< openstudio::model::AirflowNetworkSurface > >":

    return _openstudiomodelairflow.getAirflowNetworkSurfaces(t_model)

getAirflowNetworkSurfaces = _openstudiomodelairflow.getAirflowNetworkSurfaces



def getAirflowNetworkSurfaceByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkSurface >":

    return _openstudiomodelairflow.getAirflowNetworkSurfaceByName(t_model, t_name)

getAirflowNetworkSurfaceByName = _openstudiomodelairflow.getAirflowNetworkSurfaceByName



def getAirflowNetworkSurfacesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkSurface,std::allocator< openstudio::model::AirflowNetworkSurface > >":

    return _openstudiomodelairflow.getAirflowNetworkSurfacesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkSurfacesByName = _openstudiomodelairflow.getAirflowNetworkSurfacesByName

class AirflowNetworkZone(AirflowNetworkNode):

    __swig_setmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkZone, name, value)

    __swig_getmethods__ = {}

    for _s in [AirflowNetworkNode]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkZone, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkZone

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkZone_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkZone_iddObjectType)

    __swig_getmethods__["ventilationControlModeValues"] = lambda x: _openstudiomodelairflow.AirflowNetworkZone_ventilationControlModeValues

    if _newclass:

        ventilationControlModeValues = staticmethod(_openstudiomodelairflow.AirflowNetworkZone_ventilationControlModeValues)

    __swig_getmethods__["singleSidedWindPressureCoefficientAlgorithmValues"] = lambda x: _openstudiomodelairflow.AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues

    if _newclass:

        singleSidedWindPressureCoefficientAlgorithmValues = staticmethod(_openstudiomodelairflow.AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues)



    def thermalZone(self) -> "openstudio::model::ThermalZone":

        return _openstudiomodelairflow.AirflowNetworkZone_thermalZone(self)



    def ventilationControlMode(self) -> "std::string":

        return _openstudiomodelairflow.AirflowNetworkZone_ventilationControlMode(self)



    def isVentilationControlModeDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isVentilationControlModeDefaulted(self)



    def ventilationControlZoneTemperatureSetpointSchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkZone_ventilationControlZoneTemperatureSetpointSchedule(self)



    def minimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_minimumVentingOpenFactor(self)



    def isMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isMinimumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def isIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def isIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def isIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactorDefaulted(self)



    def indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def isIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactorDefaulted(self)



    def ventingAvailabilitySchedule(self) -> "boost::optional< openstudio::model::Schedule >":

        return _openstudiomodelairflow.AirflowNetworkZone_ventingAvailabilitySchedule(self)



    def singleSidedWindPressureCoefficientAlgorithm(self) -> "std::string":

        return _openstudiomodelairflow.AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithm(self)



    def isSingleSidedWindPressureCoefficientAlgorithmDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isSingleSidedWindPressureCoefficientAlgorithmDefaulted(self)



    def facadeWidth(self) -> "double":

        return _openstudiomodelairflow.AirflowNetworkZone_facadeWidth(self)



    def isFacadeWidthDefaulted(self) -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_isFacadeWidthDefaulted(self)



    def occupantVentilationControl(self) -> "boost::optional< openstudio::model::AirflowNetworkOccupantVentilationControl >":

        return _openstudiomodelairflow.AirflowNetworkZone_occupantVentilationControl(self)



    def setVentilationControlMode(self, ventilationControlMode: 'std::string const &') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setVentilationControlMode(self, ventilationControlMode)



    def resetVentilationControlMode(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetVentilationControlMode(self)



    def setVentilationControlZoneTemperatureSetpointSchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setVentilationControlZoneTemperatureSetpointSchedule(self, schedule)



    def resetVentilationControlZoneTemperatureSetpointSchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetVentilationControlZoneTemperatureSetpointSchedule(self)



    def setMinimumVentingOpenFactor(self, minimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setMinimumVentingOpenFactor(self, minimumVentingOpenFactor)



    def resetMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetMinimumVentingOpenFactor(self)



    def setIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor)



    def resetIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetIndoorandOutdoorTemperatureDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def setIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor)



    def resetIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetIndoorandOutdoorTemperatureDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def setIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor)



    def resetIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetIndoorandOutdoorEnthalpyDifferenceLowerLimitForMaximumVentingOpenFactor(self)



    def setIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self, indoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor)



    def resetIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetIndoorandOutdoorEnthalpyDifferenceUpperLimitforMinimumVentingOpenFactor(self)



    def setVentingAvailabilitySchedule(self, schedule: 'Schedule') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setVentingAvailabilitySchedule(self, schedule)



    def resetVentingAvailabilitySchedule(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetVentingAvailabilitySchedule(self)



    def setSingleSidedWindPressureCoefficientAlgorithm(self, singleSidedWindPressureCoefficientAlgorithm: 'std::string const &') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setSingleSidedWindPressureCoefficientAlgorithm(self, singleSidedWindPressureCoefficientAlgorithm)



    def resetSingleSidedWindPressureCoefficientAlgorithm(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetSingleSidedWindPressureCoefficientAlgorithm(self)



    def setFacadeWidth(self, facadeWidth: 'double') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setFacadeWidth(self, facadeWidth)



    def resetFacadeWidth(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetFacadeWidth(self)



    def setOccupantVentilationControl(self, airflowNetworkOccupantVentilationControl: 'AirflowNetworkOccupantVentilationControl') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZone_setOccupantVentilationControl(self, airflowNetworkOccupantVentilationControl)



    def resetOccupantVentilationControl(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZone_resetOccupantVentilationControl(self)

AirflowNetworkZone_swigregister = _openstudiomodelairflow.AirflowNetworkZone_swigregister

AirflowNetworkZone_swigregister(AirflowNetworkZone)



def AirflowNetworkZone_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkZone_iddObjectType()

AirflowNetworkZone_iddObjectType = _openstudiomodelairflow.AirflowNetworkZone_iddObjectType



def AirflowNetworkZone_ventilationControlModeValues() -> "std::vector< std::string,std::allocator< std::string > >":

    return _openstudiomodelairflow.AirflowNetworkZone_ventilationControlModeValues()

AirflowNetworkZone_ventilationControlModeValues = _openstudiomodelairflow.AirflowNetworkZone_ventilationControlModeValues



def AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues() -> "std::vector< std::string,std::allocator< std::string > >":

    return _openstudiomodelairflow.AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues()

AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues = _openstudiomodelairflow.AirflowNetworkZone_singleSidedWindPressureCoefficientAlgorithmValues





def toAirflowNetworkZone(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkZone >":

    return _openstudiomodelairflow.toAirflowNetworkZone(idfObject)

toAirflowNetworkZone = _openstudiomodelairflow.toAirflowNetworkZone



def getAirflowNetworkZone(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkZone >":

    return _openstudiomodelairflow.getAirflowNetworkZone(t_model, t_handle)

getAirflowNetworkZone = _openstudiomodelairflow.getAirflowNetworkZone



def getAirflowNetworkZones(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkZone,std::allocator< openstudio::model::AirflowNetworkZone > >":

    return _openstudiomodelairflow.getAirflowNetworkZones(t_model)

getAirflowNetworkZones = _openstudiomodelairflow.getAirflowNetworkZones



def getAirflowNetworkZoneByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkZone >":

    return _openstudiomodelairflow.getAirflowNetworkZoneByName(t_model, t_name)

getAirflowNetworkZoneByName = _openstudiomodelairflow.getAirflowNetworkZoneByName



def getAirflowNetworkZonesByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkZone,std::allocator< openstudio::model::AirflowNetworkZone > >":

    return _openstudiomodelairflow.getAirflowNetworkZonesByName(t_model, t_name, t_exactMatch)

getAirflowNetworkZonesByName = _openstudiomodelairflow.getAirflowNetworkZonesByName

class AirflowNetworkZoneExhaustFan(openstudiomodelcore.ModelObject):

    __swig_setmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))

    __setattr__ = lambda self, name, value: _swig_setattr(self, AirflowNetworkZoneExhaustFan, name, value)

    __swig_getmethods__ = {}

    for _s in [openstudiomodelcore.ModelObject]:

        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))

    __getattr__ = lambda self, name: _swig_getattr(self, AirflowNetworkZoneExhaustFan, name)



    def __init__(self, *args, **kwargs):

        raise AttributeError("No constructor defined")

    __repr__ = _swig_repr

    __swig_destroy__ = _openstudiomodelairflow.delete_AirflowNetworkZoneExhaustFan

    __del__ = lambda self: None

    __swig_getmethods__["iddObjectType"] = lambda x: _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_iddObjectType

    if _newclass:

        iddObjectType = staticmethod(_openstudiomodelairflow.AirflowNetworkZoneExhaustFan_iddObjectType)



    def fanZoneExhaust(self) -> "boost::optional< openstudio::model::FanZoneExhaust >":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_fanZoneExhaust(self)



    def crack(self) -> "boost::optional< openstudio::model::AirflowNetworkCrack >":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_crack(self)



    def setCrack(self, crack: 'AirflowNetworkCrack') -> "bool":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_setCrack(self, crack)



    def resetCrack(self) -> "void":

        return _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_resetCrack(self)

AirflowNetworkZoneExhaustFan_swigregister = _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_swigregister

AirflowNetworkZoneExhaustFan_swigregister(AirflowNetworkZoneExhaustFan)



def AirflowNetworkZoneExhaustFan_iddObjectType() -> "openstudio::IddObjectType":

    return _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_iddObjectType()

AirflowNetworkZoneExhaustFan_iddObjectType = _openstudiomodelairflow.AirflowNetworkZoneExhaustFan_iddObjectType





def toAirflowNetworkZoneExhaustFan(idfObject: 'IdfObject') -> "boost::optional< openstudio::model::AirflowNetworkZoneExhaustFan >":

    return _openstudiomodelairflow.toAirflowNetworkZoneExhaustFan(idfObject)

toAirflowNetworkZoneExhaustFan = _openstudiomodelairflow.toAirflowNetworkZoneExhaustFan



def getAirflowNetworkZoneExhaustFan(t_model: 'Model', t_handle: 'UUID') -> "boost::optional< openstudio::model::AirflowNetworkZoneExhaustFan >":

    return _openstudiomodelairflow.getAirflowNetworkZoneExhaustFan(t_model, t_handle)

getAirflowNetworkZoneExhaustFan = _openstudiomodelairflow.getAirflowNetworkZoneExhaustFan



def getAirflowNetworkZoneExhaustFans(t_model: 'Model') -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan,std::allocator< openstudio::model::AirflowNetworkZoneExhaustFan > >":

    return _openstudiomodelairflow.getAirflowNetworkZoneExhaustFans(t_model)

getAirflowNetworkZoneExhaustFans = _openstudiomodelairflow.getAirflowNetworkZoneExhaustFans



def getAirflowNetworkZoneExhaustFanByName(t_model: 'Model', t_name: 'std::string const &') -> "boost::optional< openstudio::model::AirflowNetworkZoneExhaustFan >":

    return _openstudiomodelairflow.getAirflowNetworkZoneExhaustFanByName(t_model, t_name)

getAirflowNetworkZoneExhaustFanByName = _openstudiomodelairflow.getAirflowNetworkZoneExhaustFanByName



def getAirflowNetworkZoneExhaustFansByName(t_model: 'Model', t_name: 'std::string const &', t_exactMatch: 'bool') -> "std::vector< openstudio::model::AirflowNetworkZoneExhaustFan,std::allocator< openstudio::model::AirflowNetworkZoneExhaustFan > >":

    return _openstudiomodelairflow.getAirflowNetworkZoneExhaustFansByName(t_model, t_name, t_exactMatch)

getAirflowNetworkZoneExhaustFansByName = _openstudiomodelairflow.getAirflowNetworkZoneExhaustFansByName

# This file is compatible with both classic and new-style classes.





